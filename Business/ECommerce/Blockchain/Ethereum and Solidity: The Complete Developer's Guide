                    Ethereum and Solidity: The Complete Developer's Guide
                    Course Notes 


                    Section 1 - What is Ethereum?
1 - Introduction
A brief introduction to the course, what it will cover etc
There is also a brief into to the instructor

2 - Link to Github Repo
A link to the GitHub repo with code from the course

3 - A Short History Lesson
A brief history of the evolution of the Ethereum\Blockchain technology
  - The first paper came in 2008, Oct31st and was associated with Bitcoin
  - Unlike other tech fields an understanding of the evolution is worthwhile
  - The white paper described a peer to peer payment system without a bank
  - In Dec 2013 there was another white paper which was the basis of Ethereum

4 - Link to Original Bitcoin White Paper
A link to the original academic white paper for Bitcoin

5 - What is Ethereum?
This is the first discussion of many about Ethereum
  - This will develop during the course
  - Ethereum networks are used to both transfer money and store data
  - There are many different Ethereum networks 
  - Networks are formed by one or more nodes
  - Each node is a machine running an Ethereum client
  - Anybody can run a node
  - Each node can contain a full copy of the blockchain
  - The blockchain is a database that stores a record of all the transaction that has taken place

6 - Interfacing with Ethereum Networks
There are a few different ways to connect to the networks
There are a couple of main groups of technologies
  - For developers, the course will use Web3.js for developing apps
  - For consumers, there are 2 solutions which will be used in the course
    - Metamask which is a Chrome plugin
    - Mist Browser which is a full featured browser which will be able to browse different Ethereum applications

7 - Metamask Setup
Installing and configuring the Chrome metamask extension
  - This will be used to both interface with the Ethereum network and also the course apps
  - This is installed using the Web Store on the Chrome browser
  - Clicking on the Fox icon on the address bar will open the extension
  - There are some notices etc to be gone through and the accepted
  - After this the user will be prompted for a passwrod which will create and account on the Ethereum network
  - This will allow a user to send and receive money as well as deploy smart contract that they create
  - The course will create many different accounts
  - This will give some random words which will need to be saved as they are the only way an account can be restored
  - These 12 words are a mnemonic that are generated when the vault is created
  - After this is the main screen, the Main Network is the default network 
  - The main network is the real network which is used by the public when purchasing
  - There are several test networks listed
  - The course will use the Rinkeby-Test network
  - Doing stuff on the main network will cost real money
  - The localhost 8545 is used usually when hosting an ethereum node or a local test network
  - A lot of development is done on localhost
  - The custom RPC allow for connection to a custom remote network

8 - Ethereum Accounts
When Metamask created an account it created 3 distinct pieces of information
  - An account address
    - This is an account identifier and is similar to an email address, telling people who you are
  - A public key
  - A private key
    - These 2 pieces for something akin to a password
    - They are used to authorise transferring funds from your account to another account
  - All three values are in Hexidecimal format
    - Using the Dev-Tools entering a hex number into the JS console will be converted to base 10 and returned
    - Guessing a private key is almost impossible due to the size of the value
  - Unlike email address, 1 account is used across all networks

9 - Receiving Ether
Using the Rinkeby-Faucet example site
  - http://www.rinkeby-faucet.com
  - This is a test network to demonstrate the process of receiving and sending ether
To view address
  - On the Metamask window click ...
  - Select copy address to clipboard
  - Paste into the submit box and submit
  - Coin transfer is not immediate

10 - What's a Transaction?
Going to other networks will show a balance of 0
  - Other networks live in their own universe
The process that was gone through is as follows
  - Click submit on form 
  - Address sent to backend server
  - The backend server created a transaction object 
    - A transaction is record of one account trying to send money to another
      - The transaction object has several properties
        - Nonce -- How many times the sender has sent a transaction
          - Nonce is short for nonsense in this case
        - To -- The address of the account the money is going to
        - Value -- The amount of ether to send to the target address
        - GasPrice -- The amount the sender is willing to pay per unit gas to get this transactin processed
        - StartGas/GasLimit -- Units of gas that this transaction can consume
        - v/r/s -- Cryptographic pieces of data that can be used to generate the senders accoun address

11 - Why'd We Wait?
Finishing off the flow from the previous video
  - The backend server then sent the transaction to the Rinkeby test network
  - The backend server then waited for the transaction to be confirmed
    - The blockchain can be very complicated, this is an aside to why there was a wait for transaction confirmation
    - The systems are not complicated for the sake of it but it is needed for the transfer of large amounts of money
    - The transaction does not go straigh to the network, it goes to a node which communicates with the node
    - The Node has a copy of the entire blockchain
    - A list of transaction assembled by a node is called a block
    - The validation logic ran against the block is responsible for the delay
      - This validation logic is more properly called mining in crypto currency circles
  - The backend server then sent a success message back to the browser

12 - A Quick Note

13 - Basic Blockchains
A video demonstrating Blockchains from Anders
  - https://anders.com/blockchain/
There is a quick demo of SHA 256 hash
  - No matter the amount of information the hash length stays the same
A blockchain is basically a chain of blocks as defined previous
  - Each block points to the previous one
  - The longer the chain the harder to make changes which need to be remined
  - Looking at the hash value can tell when there has been remining

14 - Block Time

15 - Smart Contracts

16 - The Solidity Programming Language

17 - Our First Contract

18 - Contract Structure

19 - Function Declarations

20 - Testing with Remix

21 - Redeploying Contracts

22 - Behind the Scenes of Deployment

23 - More on Running Functions Than You Want to Know

24 - Wei vs Ether

25 - Gas and Transactions

26 - Mnemonic Phrases

27 - Getting More Ether



                    Section 2 – Smart Contracts with Solidity
1 - Don't Skip! Node JS Versioning

2 - Contract Deployment

3 - Boilerplate Requirements

4 - Project File Walkthrough

5 - Syntax Highlighters

6 - Compiling Solidity

7 - The Compile Script

8 - Testing Architecture

9 - Running Windows?

10 - Installing Modules

11 - Web3 Versioning

12 - Web3 Providers

13 - Testing with Mocha

14 - Mocha Structure

15 - Fetching Accounts from Ganache

16 - Refactor to Async/Await

17 - Deployment with Web3

18 - Deployed Inbox Overview

19 - Asserting Deployment

20 - Web3 Version Fix

21 - Verifying the Initial Message

22 - Testing Message Updates

23 - Deployment with Infura

24 - Infura Signup

25 - Wallet Provider Setup

26 - Deployment to Rinkeby

27 - Observing Deployment on Etherscan

28 - Deployed Contracts in Remix

29 - Project Review



                    Section 3 – Advanced Smart Contracts
1 - The Lottery Contract

2 - Lottery Design

3 - Basic Solidity Types

4 - Starting the Lottery Contract

5 - The Message Global Variable

6 - Overview of Arrays

7 - Overview of Mappings and Structs

8 - Big Solidity Gotcha

9 - Entering the Lottery

10 - Validation with Require Statements

11 - The Remix Debugger

12 - Psuedo Random Number Generator

13 - Selecting a Winner

14 - Sending Ether from Contracts

15 - Resetting Contract State

16 - Requiring Managers

17 - Function Modifiers

18 - Returning Players Array

19 - Contract Review

20 - New Test Setup

21 - Test Project Updates

22 - Test Helper Review

23 - Asserting Deployment

24 - Entering the Lottery

25 - Asserting Multiple Players

26 - Try-Catch Assertions
05:57
Testing Function Modifiers
03:29
End to End Test



                    Section 4 – Building Interactive Front-Ends
1 - Ethereum App Architecture

2 - Application Overview

3 - Getting Started with Create-React-App

4 - Multiple Web3 Instances

5 - Web3 Setup

6 - Deploying the Lottery Contract

7 - Local Contract Instances

8 - Rendering Contract Data

9 - Instance Properties

10 - Accessing More Properties

11 - The 'Enter' Form

12 - Form Setup

13 - Entering the Lottery

14 - Picking a Winner

15 - Project Review



                    Section 5 – Real Projects with Ethereum
1 - Solving Real Problems with Contracts

2 - Fixing Kickstarter's Issues
07:48
Campaign Contract Design
09:05
Campaign Constructor
04:16
Contributing to the Campaign
03:07
A Quick Test
02:14
The Request Struct
08:58
More on Function Modifiers
05:15
Creating Struct Instances
05:33
Instance Creation Syntax
09:31
Storage and Memory
06:27
More on Storage vs Memory
16:23
Voting System Requirements
02:49
The Wrong Voting System
05:12
Issues with Arrays
06:14
Mappings vs Arrays
04:01
Basics of Mappings
11:08
Refactoring to Mappings
06:45
Refactoring Request Stucts
02:15
More on Struct Initialization
02:52
Approving a Request
07:53
Testing Request Approvals
05:22
Finalizing a Request
07:24
Last Remix Test
03:03
Thinking about Deployment
09:46
Solution to Deployment
06:33
Adding a Campaign Factory
07:53
Testing the Factory
03:27
–
Ethereum Project Infrastructure
01:27:26
Project Setup
02:16
Directory Structure
02:56
A Better Compile Script
04:41
Single Run Compilation
08:46
More on Compile
06:20
Test File Setup
08:21
Creating Campaign Instances
10:19
Testing Warmup
03:11
Accessing Mappings
09:55
Requiring Minimum Contributinos
03:13
Array Getters
06:07
One End to End Test
13:00
Deployment
02:16
Refactoring Deployment
06:05
–
Advanced Multi-Page Front-Ends
06:53:21
App Mockups
11:05
CRA vs Next
04:59
Next's Pages Architecture
05:07
Basics of Next Routing
04:51
Root Routes
05:23
CampaignFactory Instance
07:12
Getting a Test Campaign
05:35
Fetching Deployed Campaigns
06:27
Why Next.js, Anyways?
09:50
Server vs Client Web3 Instances
10:41
GetInitialProps Function
10:14
Semantic UI React
05:49
Card Group Setup
06:42
Rendering Card Groups
06:10
Adding CSS
04:40
Adding a Button
06:47
The Need for a Layout
06:16
The Layout Component
07:13
Assembling a Header
07:35
Constraining Content Width
04:28
Two Column Layout
01:58
Nested Routing
04:27
Final CSS Fix
05:20
Form Creation
04:31
Input Change Handlers
06:20
Form Submittal
05:58
Testing Submittal
03:44
Form Error Handling
12:49
Button Spinners
06:56
Routing Issues
03:13
Next Routes Setup
10:54
Automatic Navigation
04:43
Header Navigation
05:52
Routing to Campaigns
05:52
Restarting the Server
00:05
Route Mappings
07:01
Planning CampaignShow
03:59
Redeploying CampaignFactory
08:53
CampaignShow's GetInitialProps
07:10
Accessing a Campaign
08:03
Summary Translation Layer
04:15
Custom Card Groups
07:44
One Card Per Property
04:38
The Contribute Form
07:22
Grid Layouts
04:07
Form State
02:44
Communicating the Campaign Address
04:24
Making a Contribution
04:55
Refreshing Contract Data
06:17
Spinners and Error Handlers
04:56
Listing Requests
06:29
Grids vs Columns
03:36
More Routing!
08:32
Request Creation Form
10:35
Creating a Request
09:51
Form Polish
07:43
Creating a Request
01:12
Requests One by One
03:32
Fancy Javascript
07:35
Small Typo!
00:19
Rendering a Table
03:22
Request Row Component
06:17
Request Row Content
07:23
Approvers Count Cell
05:51
Approving a Request
06:58
Finalizing Requests
05:19
Testing Finalization
02:33
Row Status Styling
06:45
Finishing Requests Index
02:30
Wrapup
00:44
–
Appendix: Basic React
03:07:28
A Note on This Section
00:10
Purpose of Boilerplate Projects
03:41
Environment Setup
01:45
Project Setup
02:53
JSX
11:29
More on JSX
04:35
ES6 Import Statements
03:58
ReactDOM vs React
02:26
Component Instances
03:38
Render Targets
05:53
Component Structure
06:26
Youtube Search API Signup
06:39
Export Statements
08:40
Class Based Components
08:11
Handling User Events
09:30
Introduction to State
05:13
State Continued
06:04
Controlled Components
07:47
Breather and Review
03:37
Youtube Search Response
04:26
Refactoring Functional Components to Class Components
07:43
Props
07:42
Building Lists with Map
07:06
List Item Keys
03:54
Video List Items
07:53
Detail Component and Template Strings
07:05
Handling Null Props
04:41
Video Selection
11:39
Styling with CSS
03:43
Searching for Videos
07:51
Throttling Search Term Input
05:46
React Wrapup
05:24
