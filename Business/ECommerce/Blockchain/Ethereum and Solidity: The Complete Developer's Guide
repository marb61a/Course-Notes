                    Ethereum and Solidity: The Complete Developer's Guide
                    Course Notes 


                    Section 1 - What is Ethereum?
1 - Introduction
A brief introduction to the course, what it will cover etc
There is also a brief into to the instructor

2 - Link to Github Repo
A link to the GitHub repo with code from the course

3 - A Short History Lesson
A brief history of the evolution of the Ethereum\Blockchain technology
  - The first paper came in 2008, Oct31st and was associated with Bitcoin
  - Unlike other tech fields an understanding of the evolution is worthwhile
  - The white paper described a peer to peer payment system without a bank
  - In Dec 2013 there was another white paper which was the basis of Ethereum

4 - Link to Original Bitcoin White Paper
A link to the original academic white paper for Bitcoin

5 - What is Ethereum?
This is the first discussion of many about Ethereum
  - This will develop during the course
  - Ethereum networks are used to both transfer money and store data
  - There are many different Ethereum networks 
  - Networks are formed by one or more nodes
  - Each node is a machine running an Ethereum client
  - Anybody can run a node
  - Each node can contain a full copy of the blockchain
  - The blockchain is a database that stores a record of all the transaction that has taken place

6 - Interfacing with Ethereum Networks
There are a few different ways to connect to the networks
There are a couple of main groups of technologies
  - For developers, the course will use Web3.js for developing apps
  - For consumers, there are 2 solutions which will be used in the course
    - Metamask which is a Chrome plugin
    - Mist Browser which is a full featured browser which will be able to browse different Ethereum applications

7 - Metamask Setup

8 - Ethereum Accounts

9 - Receiving Ether

10 - What's a Transaction?

11 - Why'd We Wait?

12 - A Quick Note

13 - Basic Blockchains

14 - Block Time

15 - Smart Contracts

16 - The Solidity Programming Language

17 - Our First Contract

18 - Contract Structure

19 - Function Declarations

20 - Testing with Remix

21 - Redeploying Contracts

22 - Behind the Scenes of Deployment

23 - More on Running Functions Than You Want to Know

24 - Wei vs Ether

25 - Gas and Transactions

26 - Mnemonic Phrases

27 - Getting More Ether



                    Section 2 – Smart Contracts with Solidity
1 - Don't Skip! Node JS Versioning

2 - Contract Deployment

3 - Boilerplate Requirements

4 - Project File Walkthrough

5 - Syntax Highlighters
00:25
Compiling Solidity
06:22
The Compile Script
06:09
Testing Architecture
03:48
Running Windows?
00:31
Installing Modules
04:15
Web3 Versioning
04:18
Web3 Providers
04:47
Testing with Mocha
18:16
Mocha Structure
04:44
Fetching Accounts from Ganache
06:43
Refactor to Async/Await
02:39
Deployment with Web3
06:11
Deployed Inbox Overview
11:18
Asserting Deployment
05:22
Web3 Version Fix
00:58
Verifying the Initial Message
08:25
Testing Message Updates
06:24
Deployment with Infura
06:57
Infura Signup
03:43
Wallet Provider Setup
06:40
Deployment to Rinkeby
07:21
Observing Deployment on Etherscan
04:51
Deployed Contracts in Remix
07:13
Project Review
09:27
–
Advanced Smart Contracts
02:28:12
The Lottery Contract
02:36
Lottery Design
02:49
Basic Solidity Types
09:43
Starting the Lottery Contract
04:44
The Message Global Variable
05:53
Overview of Arrays
11:06
Overview of Mappings and Structs
03:42
Big Solidity Gotcha
06:28
Entering the Lottery
03:57
Validation with Require Statements
09:48
The Remix Debugger
04:03
Psuedo Random Number Generator
10:34
Selecting a Winner
04:58
Sending Ether from Contracts
05:08
Resetting Contract State
04:07
Requiring Managers
05:03
Function Modifiers
06:18
Returning Players Array
02:13
Contract Review
02:51
New Test Setup
03:04
Test Project Updates
02:04
Test Helper Review
04:33
Asserting Deployment
02:54
Entering the Lottery
06:27
Asserting Multiple Players
02:39
Try-Catch Assertions
05:57
Testing Function Modifiers
03:29
End to End Test
11:04
–
Building Interactive Front-Ends
01:30:10
Ethereum App Architecture
09:20
Application Overview
07:56
Getting Started with Create-React-App
02:36
Multiple Web3 Instances
08:42
Web3 Setup
06:10
Deploying the Lottery Contract
05:32
Local Contract Instances
06:26
Rendering Contract Data
07:04
Instance Properties
01:58
Accessing More Properties
05:33
The 'Enter' Form
03:50
Form Setup
06:47
Entering the Lottery
06:35
Picking a Winner
08:34
Project Review
03:07
–
Real Projects with Ethereum
02:57:15
Solving Real Problems with Contracts
06:01
Fixing Kickstarter's Issues
07:48
Campaign Contract Design
09:05
Campaign Constructor
04:16
Contributing to the Campaign
03:07
A Quick Test
02:14
The Request Struct
08:58
More on Function Modifiers
05:15
Creating Struct Instances
05:33
Instance Creation Syntax
09:31
Storage and Memory
06:27
More on Storage vs Memory
16:23
Voting System Requirements
02:49
The Wrong Voting System
05:12
Issues with Arrays
06:14
Mappings vs Arrays
04:01
Basics of Mappings
11:08
Refactoring to Mappings
06:45
Refactoring Request Stucts
02:15
More on Struct Initialization
02:52
Approving a Request
07:53
Testing Request Approvals
05:22
Finalizing a Request
07:24
Last Remix Test
03:03
Thinking about Deployment
09:46
Solution to Deployment
06:33
Adding a Campaign Factory
07:53
Testing the Factory
03:27
–
Ethereum Project Infrastructure
01:27:26
Project Setup
02:16
Directory Structure
02:56
A Better Compile Script
04:41
Single Run Compilation
08:46
More on Compile
06:20
Test File Setup
08:21
Creating Campaign Instances
10:19
Testing Warmup
03:11
Accessing Mappings
09:55
Requiring Minimum Contributinos
03:13
Array Getters
06:07
One End to End Test
13:00
Deployment
02:16
Refactoring Deployment
06:05
–
Advanced Multi-Page Front-Ends
06:53:21
App Mockups
11:05
CRA vs Next
04:59
Next's Pages Architecture
05:07
Basics of Next Routing
04:51
Root Routes
05:23
CampaignFactory Instance
07:12
Getting a Test Campaign
05:35
Fetching Deployed Campaigns
06:27
Why Next.js, Anyways?
09:50
Server vs Client Web3 Instances
10:41
GetInitialProps Function
10:14
Semantic UI React
05:49
Card Group Setup
06:42
Rendering Card Groups
06:10
Adding CSS
04:40
Adding a Button
06:47
The Need for a Layout
06:16
The Layout Component
07:13
Assembling a Header
07:35
Constraining Content Width
04:28
Two Column Layout
01:58
Nested Routing
04:27
Final CSS Fix
05:20
Form Creation
04:31
Input Change Handlers
06:20
Form Submittal
05:58
Testing Submittal
03:44
Form Error Handling
12:49
Button Spinners
06:56
Routing Issues
03:13
Next Routes Setup
10:54
Automatic Navigation
04:43
Header Navigation
05:52
Routing to Campaigns
05:52
Restarting the Server
00:05
Route Mappings
07:01
Planning CampaignShow
03:59
Redeploying CampaignFactory
08:53
CampaignShow's GetInitialProps
07:10
Accessing a Campaign
08:03
Summary Translation Layer
04:15
Custom Card Groups
07:44
One Card Per Property
04:38
The Contribute Form
07:22
Grid Layouts
04:07
Form State
02:44
Communicating the Campaign Address
04:24
Making a Contribution
04:55
Refreshing Contract Data
06:17
Spinners and Error Handlers
04:56
Listing Requests
06:29
Grids vs Columns
03:36
More Routing!
08:32
Request Creation Form
10:35
Creating a Request
09:51
Form Polish
07:43
Creating a Request
01:12
Requests One by One
03:32
Fancy Javascript
07:35
Small Typo!
00:19
Rendering a Table
03:22
Request Row Component
06:17
Request Row Content
07:23
Approvers Count Cell
05:51
Approving a Request
06:58
Finalizing Requests
05:19
Testing Finalization
02:33
Row Status Styling
06:45
Finishing Requests Index
02:30
Wrapup
00:44
–
Appendix: Basic React
03:07:28
A Note on This Section
00:10
Purpose of Boilerplate Projects
03:41
Environment Setup
01:45
Project Setup
02:53
JSX
11:29
More on JSX
04:35
ES6 Import Statements
03:58
ReactDOM vs React
02:26
Component Instances
03:38
Render Targets
05:53
Component Structure
06:26
Youtube Search API Signup
06:39
Export Statements
08:40
Class Based Components
08:11
Handling User Events
09:30
Introduction to State
05:13
State Continued
06:04
Controlled Components
07:47
Breather and Review
03:37
Youtube Search Response
04:26
Refactoring Functional Components to Class Components
07:43
Props
07:42
Building Lists with Map
07:06
List Item Keys
03:54
Video List Items
07:53
Detail Component and Template Strings
07:05
Handling Null Props
04:41
Video Selection
11:39
Styling with CSS
03:43
Searching for Videos
07:51
Throttling Search Term Input
05:46
React Wrapup
05:24
