                    Ethereum and Solidity: The Complete Developer's Guide
                    Course Notes 


                    Section 1 - What is Ethereum?
1 - Introduction
A brief introduction to the course, what it will cover etc
There is also a brief into to the instructor

2 - Link to Github Repo
A link to the GitHub repo with code from the course

3 - A Short History Lesson
A brief history of the evolution of the Ethereum\Blockchain technology
  - The first paper came in 2008, Oct31st and was associated with Bitcoin
  - Unlike other tech fields an understanding of the evolution is worthwhile
  - The white paper described a peer to peer payment system without a bank
  - In Dec 2013 there was another white paper which was the basis of Ethereum

4 - Link to Original Bitcoin White Paper
A link to the original academic white paper for Bitcoin

5 - What is Ethereum?
This is the first discussion of many about Ethereum
  - This will develop during the course
  - Ethereum networks are used to both transfer money and store data
  - There are many different Ethereum networks 
  - Networks are formed by one or more nodes
  - Each node is a machine running an Ethereum client
  - Anybody can run a node
  - Each node can contain a full copy of the blockchain
  - The blockchain is a database that stores a record of all the transaction that has taken place

6 - Interfacing with Ethereum Networks
There are a few different ways to connect to the networks
There are a couple of main groups of technologies
  - For developers, the course will use Web3.js for developing apps
  - For consumers, there are 2 solutions which will be used in the course
    - Metamask which is a Chrome plugin
    - Mist Browser which is a full featured browser which will be able to browse different Ethereum applications

7 - Metamask Setup
Installing and configuring the Chrome metamask extension
  - This will be used to both interface with the Ethereum network and also the course apps
  - This is installed using the Web Store on the Chrome browser
  - Clicking on the Fox icon on the address bar will open the extension
  - There are some notices etc to be gone through and the accepted
  - After this the user will be prompted for a passwrod which will create and account on the Ethereum network
  - This will allow a user to send and receive money as well as deploy smart contract that they create
  - The course will create many different accounts
  - This will give some random words which will need to be saved as they are the only way an account can be restored
  - These 12 words are a mnemonic that are generated when the vault is created
  - After this is the main screen, the Main Network is the default network 
  - The main network is the real network which is used by the public when purchasing
  - There are several test networks listed
  - The course will use the Rinkeby-Test network
  - Doing stuff on the main network will cost real money
  - The localhost 8545 is used usually when hosting an ethereum node or a local test network
  - A lot of development is done on localhost
  - The custom RPC allow for connection to a custom remote network

8 - Ethereum Accounts
When Metamask created an account it created 3 distinct pieces of information
  - An account address
    - This is an account identifier and is similar to an email address, telling people who you are
  - A public key
  - A private key
    - These 2 pieces for something akin to a password
    - They are used to authorise transferring funds from your account to another account
  - All three values are in Hexidecimal format
    - Using the Dev-Tools entering a hex number into the JS console will be converted to base 10 and returned
    - Guessing a private key is almost impossible due to the size of the value
  - Unlike email addresses on different providers, 1 account is used across all networks

9 - Receiving Ether
Using the Rinkeby-Faucet example site
  - http://www.rinkeby-faucet.com
  - This is a test network to demonstrate the process of receiving and sending ether
To view address
  - On the Metamask window click ...
  - Select copy address to clipboard
  - Paste into the submit box and submit
  - Coin transfer is not immediate

10 - What's a Transaction?
Going to other networks will show a balance of 0
  - Other networks live in their own universe
The process that was gone through is as follows
  - Click submit on form 
  - Address sent to backend server
  - The backend server created a transaction object 
    - A transaction is record of one account trying to send money to another
      - The transaction object has several properties
        - Nonce -- How many times the sender has sent a transaction
          - Nonce is short for nonsense in this case
        - To -- The address of the account the money is going to
        - Value -- The amount of ether to send to the target address
        - GasPrice -- The amount the sender is willing to pay per unit gas to get this transactin processed
        - StartGas/GasLimit -- Units of gas that this transaction can consume
        - v/r/s -- Cryptographic pieces of data that can be used to generate the senders accoun address

11 - Why'd We Wait?
Finishing off the flow from the previous video
  - The backend server then sent the transaction to the Rinkeby test network
  - The backend server then waited for the transaction to be confirmed
    - The blockchain can be very complicated, this is an aside to why there was a wait for transaction confirmation
    - The systems are not complicated for the sake of it but it is needed for the transfer of large amounts of money
    - The transaction does not go straigh to the network, it goes to a node which communicates with the node
    - The Node has a copy of the entire blockchain
    - A list of transaction assembled by a node is called a block
    - The validation logic ran against the block is responsible for the delay
      - This validation logic is more properly called mining in crypto currency circles
  - The backend server then sent a success message back to the browser

12 - A Quick Note

13 - Basic Blockchains
A video demonstrating Blockchains from Anders
  - https://anders.com/blockchain/
There is a quick demo of SHA 256 hash
  - No matter the amount of information the hash length stays the same
A blockchain is basically a chain of blocks as defined previous
  - Each block points to the previous one
  - The longer the chain the harder to make changes which need to be remined
  - Looking at the hash value can tell when there has been remining

14 - Block Time
The definition used in the previous video example was a very generic blockchain
  - For example having a leading 4 zeros is not strictly true
  - What we are really looking for is a hash less than some target value
  - Hashes are 64 bit long which means values can be from 0 - 1.15 x 10^77
  - The time it takes to hash everything from 0 to the nonce value is called block time
  - Solutions when found will take extra time while the solutions are sent to other nodes
  - The Ethereum network has a target blocktime of 15 seconds
  - Raising a target value can help it be found quicker
  - There is a demo time chart recommended by the course instructor
    - https://etherscan.io/chart/blocktime
    - This shows block times over a couple of years

15 - Smart Contracts
This will be the main topic of the course
  - A Smart Contract can be thought of as an account controlled by code
  - This code will tell the Smart Contract how to behave
There are several different properties contained within a Smart Contract account
  - These are different from the account properties previously discussed
    - Balance -- The amount of Ether that this account owns
    - Storage -- Data storage for this contract
    - Code -- Raw machine code for this contract
Accounts that we create are referred to as External Accounts
  - Contract Accounts are specific to a network and cannot be accessed across networks
The process for Contract Accounts
  - Contract Source is created on our computer
  - It is deployed on to the network
  - When deployed it creates a Contract Instance or Contract Account
  - One contract source can be deployed to multiple networks
  - It can also be deploed multiple time to the same network
  
16 - The Solidity Programming Language
Solidity was invented specifically for writing Smart Contracts
It is written in .sol files
  - Nearly all editors work with Solidity
The language itself is strongly typed
It is similar to JavaScript from a syntax point of view
There are several very large gotchas
Contracts tend to be quite small
  - Being an expert is not necessary it is usually the app code around the contract that takes more time
The way that Solidity contracts are executed on the network is
  - The Contract Definition will be fed into a Solidity compiler
  - The compiler generates 2 separate files
    - Byte code ready for deployment
    - ABI -- The application binary interface which will be an interface for working with the Bytecode

17 - Our First Contract

18 - Contract Structure

19 - Function Declarations

20 - Testing with Remix

21 - Redeploying Contracts

22 - Behind the Scenes of Deployment

23 - More on Running Functions Than You Want to Know

24 - Wei vs Ether

25 - Gas and Transactions

26 - Mnemonic Phrases

27 - Getting More Ether



                    Section 2 – Smart Contracts with Solidity
The project Github Repo for this section is                    
  - https://github.com/marb61a/Ethereum-inbox
  
1 - Don't Skip! Node JS Versioning

2 - Contract Deployment

3 - Boilerplate Requirements
To set up the boilerplate project
  - Ensure that NodeJS is installed
  - It is better to have a directory for projects so create one
  - Make a directory especially for this project and change into it
  - Use the npm init command to add the NPM package manager to the project
  - Accept all defaults that are asked and the project should have a package.json file
  - There is not definitive IDE recommended but Atom is used in the example
    - https://atom.io

4 - Project File Walkthrough

5 - Syntax Highlighters

6 - Compiling Solidity

7 - The Compile Script

8 - Testing Architecture

9 - Running Windows?

10 - Installing Modules

11 - Web3 Versioning

12 - Web3 Providers

13 - Testing with Mocha

14 - Mocha Structure

15 - Fetching Accounts from Ganache

16 - Refactor to Async/Await

17 - Deployment with Web3

18 - Deployed Inbox Overview

19 - Asserting Deployment

20 - Web3 Version Fix

21 - Verifying the Initial Message

22 - Testing Message Updates

23 - Deployment with Infura

24 - Infura Signup

25 - Wallet Provider Setup

26 - Deployment to Rinkeby

27 - Observing Deployment on Etherscan

28 - Deployed Contracts in Remix

29 - Project Review



                    Section 3 – Advanced Smart Contracts
1 - The Lottery Contract

2 - Lottery Design

3 - Basic Solidity Types

4 - Starting the Lottery Contract

5 - The Message Global Variable

6 - Overview of Arrays

7 - Overview of Mappings and Structs

8 - Big Solidity Gotcha

9 - Entering the Lottery

10 - Validation with Require Statements

11 - The Remix Debugger

12 - Psuedo Random Number Generator

13 - Selecting a Winner

14 - Sending Ether from Contracts

15 - Resetting Contract State

16 - Requiring Managers

17 - Function Modifiers

18 - Returning Players Array

19 - Contract Review

20 - New Test Setup

21 - Test Project Updates

22 - Test Helper Review

23 - Asserting Deployment

24 - Entering the Lottery

25 - Asserting Multiple Players

26 - Try-Catch Assertions

27 - Testing Function Modifiers

28 - End to End Test



                    Section 4 – Building Interactive Front-Ends
1 - Ethereum App Architecture

2 - Application Overview

3 - Getting Started with Create-React-App

4 - Multiple Web3 Instances

5 - Web3 Setup

6 - Deploying the Lottery Contract

7 - Local Contract Instances

8 - Rendering Contract Data

9 - Instance Properties

10 - Accessing More Properties

11 - The 'Enter' Form

12 - Form Setup

13 - Entering the Lottery

14 - Picking a Winner

15 - Project Review



                    Section 5 – Real Projects with Ethereum
1 - Solving Real Problems with Contracts

2 - Fixing Kickstarter's Issues

3 - Campaign Contract Design

4 - Campaign Constructor

5 - Contributing to the Campaign

6 - A Quick Test

7 - The Request Struct

8 - More on Function Modifiers

9 - Creating Struct Instances

10 - Instance Creation Syntax

11 - Storage and Memory

12 - More on Storage vs Memory

13 - Voting System Requirements

14 - The Wrong Voting System

15 - Issues with Arrays

16 - Mappings vs Arrays

17 - Basics of Mappings

18 - Refactoring to Mappings

19 - Refactoring Request Stucts

20 - More on Struct Initialization

21 - Approving a Request

22 - Testing Request Approvals

23 - Finalizing a Request

24 - Last Remix Test

25 - Thinking about Deployment

26 - Solution to Deployment

27 - Adding a Campaign Factory

28 - Testing the Factory



                    Section 6 – Ethereum Project Infrastructure
1 - Project Setup

2 - Directory Structure

3 - A Better Compile Script

4 - Single Run Compilation

5 - More on Compile

6 - Test File Setup

7 - Creating Campaign Instances
10:19
Testing Warmup
03:11
Accessing Mappings
09:55
Requiring Minimum Contributinos
03:13
Array Getters
06:07
One End to End Test
13:00
Deployment
02:16
Refactoring Deployment
06:05
–
Advanced Multi-Page Front-Ends
06:53:21
App Mockups
11:05
CRA vs Next
04:59
Next's Pages Architecture
05:07
Basics of Next Routing
04:51
Root Routes
05:23
CampaignFactory Instance
07:12
Getting a Test Campaign
05:35
Fetching Deployed Campaigns
06:27
Why Next.js, Anyways?
09:50
Server vs Client Web3 Instances
10:41
GetInitialProps Function
10:14
Semantic UI React
05:49
Card Group Setup
06:42
Rendering Card Groups
06:10
Adding CSS
04:40
Adding a Button
06:47
The Need for a Layout
06:16
The Layout Component
07:13
Assembling a Header
07:35
Constraining Content Width
04:28
Two Column Layout
01:58
Nested Routing
04:27
Final CSS Fix
05:20
Form Creation
04:31
Input Change Handlers
06:20
Form Submittal
05:58
Testing Submittal
03:44
Form Error Handling
12:49
Button Spinners
06:56
Routing Issues
03:13
Next Routes Setup
10:54
Automatic Navigation
04:43
Header Navigation
05:52
Routing to Campaigns
05:52
Restarting the Server
00:05
Route Mappings
07:01
Planning CampaignShow
03:59
Redeploying CampaignFactory
08:53
CampaignShow's GetInitialProps
07:10
Accessing a Campaign
08:03
Summary Translation Layer
04:15
Custom Card Groups
07:44
One Card Per Property
04:38
The Contribute Form
07:22
Grid Layouts
04:07
Form State
02:44
Communicating the Campaign Address
04:24
Making a Contribution
04:55
Refreshing Contract Data
06:17
Spinners and Error Handlers
04:56
Listing Requests
06:29
Grids vs Columns
03:36
More Routing!
08:32
Request Creation Form
10:35
Creating a Request
09:51
Form Polish
07:43
Creating a Request
01:12
Requests One by One
03:32
Fancy Javascript
07:35
Small Typo!
00:19
Rendering a Table
03:22
Request Row Component
06:17
Request Row Content
07:23
Approvers Count Cell
05:51
Approving a Request
06:58
Finalizing Requests
05:19
Testing Finalization
02:33
Row Status Styling
06:45
Finishing Requests Index
02:30
Wrapup
00:44
–
Appendix: Basic React
03:07:28
A Note on This Section
00:10
Purpose of Boilerplate Projects
03:41
Environment Setup
01:45
Project Setup
02:53
JSX
11:29
More on JSX
04:35
ES6 Import Statements
03:58
ReactDOM vs React
02:26
Component Instances
03:38
Render Targets
05:53
Component Structure
06:26
Youtube Search API Signup
06:39
Export Statements
08:40
Class Based Components
08:11
Handling User Events
09:30
Introduction to State
05:13
State Continued
06:04
Controlled Components
07:47
Breather and Review
03:37
Youtube Search Response
04:26
Refactoring Functional Components to Class Components
07:43
Props
07:42
Building Lists with Map
07:06
List Item Keys
03:54
Video List Items
07:53
Detail Component and Template Strings
07:05
Handling Null Props
04:41
Video Selection
11:39
Styling with CSS
03:43
Searching for Videos
07:51
Throttling Search Term Input
05:46
React Wrapup
05:24
