                    Streams, Collectors, and Optionals for Data Processing in Java 8
                    Course Notes


                    Section 1 - Connecting Streams to Custom Sources: The Spliterator Pattern
1 - Introduction to the Course
Intro to the course and a brief welcome from the author
The course is mainly about advanced data processing topics
There is a brief overview of what the course is about

2 - What Are You Going to Learn in This Course?
There are a few different areas that the student will learn
  - To connect streams to non-standard sources
  - To use flatMap streams of numbers
  - To efficiently use parallel streams
  - To master the concept of optionals from the JDK
  - To use and create Collectors

3 - What Should You Know to Follow This Course? Agenda of This Module

4 - What Is a Spliterator?

5 - The Spliterator Interface, What Do We Need to Implement?

6 - The ArrayListSpliterator: the tryAdvance() Method

7 - The ArrayListSpliterator: the trySplit() Method

8 - Introduction to the Live Coding: How to Write a Spliterator

9 - Using Our Own Spliterator: Setting up the Application

10 - Using Our Own Spliterator: Writing the Use Case Pattern

11 - Implementing Our Own Spliterator: The First Methods

12 - Implementing Our Own Spliterator: The tryAdvance() Method

13 - Implementing the tryAdvance() Method: Setting the Returned Object

14 - Implementing Our Own Spliterator: Running the Example

15 - Live Coding Session Wrap-up

16 - Module Wrap-up



                    Section 2 - Advanced Java 8 Stream Patterns: FlatMap, Streams of Numbers
1 - Introduction and Agenda of the module

2 - Concatenating Streams: The Stream.concat Pattern

3 - Merging Streams: The Stream.of and flatMap Pattern

4 - How Does the flatMap Pattern Work: Examples

5 - Splitting a Text into Words Using the flatMap Pattern

6 - Splitting a Text into Words: Putting the Result in a Set

7 - State of a Stream: The Stream.characteristics() Method

8 - What Are the Eight Characteristics of a Stream?

9 - How Does the Steam Methods Modify the State of a Stream

10 - State of a Stream: A First Example

11 - How to Use the Stream.sorted() Method with a Comparator

12 - Live Coding Session: Presentation of the Example

13 - Live Coding: Merging Streams Using Stream.of and flatMap

14 - Live Coding: Splitting a Large Text in Words Using flatMap

15 - Live Coding Session Summary

16 - Streams of Numbers: Converting from a Stream of Objects

17 - Optimizing the Conversion from a Stream of Objects

18 - Patterns to Build Streams of Numbers

19 - Specialized Methods: min(), max() and summaryStatistics()

20 - Live Coding Session: Introduction of the Scrabble Example

21 - Live Coding: Computing the Score of a Word in Scrabble

22 - Live Coding: Getting the Word with the Best Score

23 - Live Coding: Computing Statistics on the Words of Shakespeare

24 - Live Coding Session and Module Wrap-up



                    Section 3 - Parallel Data Processing Pipelines Using Java 8 Streams
1 - Introduction and Agenda of the Module

2 - Building Parallel Processing on Multithread

3 - Tools for Parallel Processing in the JDK

4 - Parallel Streams: First Patterns

5 - Caveats in Parallel Processing: Synchronization and Visibility

6 - Stateful and Stateless Operations: The Limit Method Example

7 - How to Tell a Stateless Operation from a Stateful One

8 - Parallel Performance Analysis: Description of the Use Case

9 - Parallel Performance Analysis: Understanding the Computing Times

10 - A Sneaky Stateful Operation: The unordered() Method

11 - Parallel Reduction: What Not to Do!

12 - Tuning Parallelism: Setting the Size of the Common Fork Join Pool

13 - Tuning Parallelism: Setting the Executor of a Computation

14 - Live Coding: Understanding the Multithreaded Computation

15 - Live Coding: Parallel Reduction, How Can It Go Wrong?

16 - Live Coding: Parallel Reduction, Hint at the Collector Pattern

17 - Live Coding Session Summary

18 - Module Wrap-up



                    Section 4 - Building Errorless Processing Pipelines with Optionals
1 - Introduction and Agenda of the Module

2 - Optional: A First Explanation of the Concept

3 - Patterns to Use an Optional as a Wrapper Type That Can Be Empty

4 - Patterns to Build an Optional from Scratch

5 - More Optional Patterns: The Map, Filter and ifPresent Patterns

6 - How We Can See an Optional as a Special Kind of Stream

7 - Introduction to Advanced Optional Patterns: The NewMath Example

8 - Building a First Data Processing Pipeline with the NewMath Class

9 - How Does the Optional.flatMap Pattern Work?

10 - Leveraging the flatMap Pattern to Convert an Optional to a Stream

11 - Building a Parallel Data Processing Pipeline with NewMath

12 - Introduction to the Live Coding Session

13 - Live Coding: How Not to Process Doubles with NewMath

14 - Live Coding: Failing to Go Parallel with the Wrong Pattern

15 - Live Coding: Building an Optional flatMapper for NewMath

16 - Live Coding: Analyzing the Optional flatMapper

17 - Live Coding: Parallel Stream with the Optional flatMapper

18 - Live Coding Session Summary

19 - Module Wrap-up



                    Section 5 - Collecting Data in Complex Containers Using Collectors
1 - Introduction and Agenda of the Module

2 - What Is a Collector? A Look Back at the Reduction Step

3 - A First Anti-pattern to Reduce a Stream in a List

4 - Reduction in a List: The Right Pattern with a Collector

5 - The Collectors Class: We Have a Collector for That

6 - Computing a Max and an Average with a Collector

7 - Building Strings with a Collector

8 - Collecting Data in a Set

9 - Collecting in a Map: The partiionningBy and groupingBy Patterns

10 - Adding a Downstream Collector to Process Map Values

11 - Specifying Built Containers, the collectingAndThen Pattern

12 - Live Coding: Introducing the Shakespeare Plays Scrabble Use Case

13 - Live Coding: Building Histograms to Extract the Best Words

14 - Live Coding: Writing Whizzing with a Blank Letter

15 - Live Coding: Computing the Histogram of the Letters of a Word

16 - Live Coding: Computing the Number of Blanks Need for Whizzing

17 - Live Coding: Computing the Score of Words with Blank Letters

18 - Live Coding: Computing the Best Words with Blanks

19 - Live Coding Session Summary

20 - Module Wrap-up



                    Section 6 - Building Custom Collectors for Advanced Data Processing
1 - Introduction and Agenda of the Module

2 - What if We Need Collectors that Are Not in the Collectors Class?

3 - Collectors Made of a Supplier, an Accumulator, and a Combiner

4 - Example of a Supplier and Accumulator for an ArrayList

5 - Example of a Combiner for an ArrayList

6 - Putting it All Together: The Collector.of Pattern

7 - Live Coding: Presenting the Actors and Movies Use Case

8 - Live Coding: Counting the Number of Actors

9 - Live Coding: Finding the Actor That Played in the Most Movies

10 - Live Coding: Adding the Year Constraint, Introduction

11 - Live Coding: Setting the Custom Downstream Collector

12 - Live Coding: Writing the Supplier for the Custom Collector

13 - Live Coding: Writing the Accumulator

14 - Live Coding: Writing the Combiner by Merging Maps

15 - Live Coding: Taking a Global Look at the Custom Collector

16 - Live Coding: Extracting the Max of the Submap

17 - Live Coding: Extracting the Max of the Main Map

18 - Live Coding Session Summary

19 - Other Custom Collectors: The summaryStatistics Pattern

20 - Module Wrap-up

