Instruction
Since you're doing so well, you should be ready for another operator. See the example:

SELECT *
FROM country
WHERE area > ALL (
  SELECT area
  FROM city
);

As you can see, we've got a new operator ALL on the right side of the logical operator >. 
In this case, > ALL means "greater than every other value from the parentheses".
As a result, we'll get all the countries whose area is bigger than every other area of all cities.
Liechtenstein, for instance, is a very small country. It is bigger than some cities (like Lyon, for example), 
but it is not bigger than every other city (Berlin is bigger, for example) so Liechtenstein won't be shown in the result.
You can also use ALL with other logical operators: = ALL, != ALL, < ALL, <= ALL, >= ALL.

Exercise
Find all information about the cities which are less populated than all countries in the database.

Solution
SELECT
  * 
FROM city
WHERE POPULATION < ALL (
	SELECT POPULATION
  	FROM COUNTRY
)


Instruction
To conclude this section, let's find out about one more operator: ANY. Take a look:

SELECT *
FROM trip
WHERE price < ANY (
  SELECT price
  FROM hiking_trip
  WHERE mountain_id = 1
);

In the above example, we want to find trips to the cities which are cheaper than any hiking trip to the mountain with id 1 (Mont Blanc, just to let you know). 
There are two hiking trips to Mont Blanc: one which costs 1000 and one which costs 300. 
If we find a city trip which is cheaper than any of these values, we show it in the result.
Again, other logical operators are possible: = ANY, != ANY, < ANY, <= ANY, >= ANY.

Exercise
Find all information about all the city trips which have the same price as any hiking trip

Solution
SELECT
  * 
FROM trip 
WHERE PRICE = ANY(
	SELECT price 
  	FROM hiking_trip 
)


Instruction
So far, we've only used subqueries which were independent of the main query – you could first run the subquery alone and then put its result in the main query.
We are now going to learn subqueries which are dependent on the main query. They are called correlated subqueries.
Study the example:

SELECT *
FROM country
WHERE area <= (
  SELECT MIN(area)
  FROM city
  WHERE city.country_id = country.id
);

We want to find all countries whose area is equal to or smaller than the minimum city area in that particular country. 
In other words, if there is a country smaller than its smallest city, it will be shown. Why would we use such a query? 
It can be very convenient if we want to check whether there any are errors in our database. 
If this query returned anything other than nothing, we would know that something fishy is going on in our records.
What's the new piece here? Take a look at the WHERE clause in the subquery. That's right, it uses country.id. 
Which country does it refer to? The country from the main clause of course. 
This is the secret behind correlated subqueries – if you ran the subquery alone, your database would say:
'Hey, you want me to compare city.country_id to country.id, but there are tons of ids in the table country, so I don't know which one to choose'.
But if you run the instruction as a subquery and the main clause browses the table country,
then the database will each time compare country.id from the subquery with the current country.id from the main clause.
Just remember the golden rule: subqueries can use tables from the main query, but the main query can't use tables from the subquery!

Exercise
Let's check if the database contains any errors in a sample exercise.
Find all information about each country whose population is equal to or smaller than the population of the least populated city in that specific country.

Solution
SELECT
  *
FROM COUNTRY 
WHERE POPULATION <= (
  SELECT 
  MIN(POPULATION)
  FROM CITY
  WHERE CITY.COUNTRY_ID = COUNTRY.ID
);
