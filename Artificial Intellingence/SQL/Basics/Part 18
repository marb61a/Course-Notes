Instruction
Now, there may be examples where the same table is used in the main query as well as in the correlated subquery. Try to find out what the following example returns:

SELECT *
FROM city main_city
WHERE population > (
  SELECT AVG(population)
  FROM city  average_city
  WHERE average_city.country_id = main_city.country_id
);

In this example, we want to find cities with a population greater than the average population in all cities of the specific country. 
The problem is that we look for cities in the main clause and check the average population value for cities in the subquery. 
The same table appears twice â€“ no good.
This is why we must use aliases for tables. Take a look: in the subquery we put ... FROM city average_city ... and in the main query  ... FROM city main_city. 
As you can see, we gave new temporary names for the table city, different for the main query and for the subquery. 
The temporary name (the so-called alias) is put after the table name, separated by a space. No commas here, remember!

Exercise
Find all information about cities with a rating higher than the average rating for all cities in that specific country.

Solution
SELECT
  *
FROM CITY MAIN_CITY
WHERE RATING > (
  SELECT 
  AVG(RATING)
  FROM CITY AVERAGE_CITY
  WHERE AVERAGE_CITY.COUNTRY_ID =
  MAIN_CITY.COUNTRY_ID
);


Instruction
Now, remember the operator IN? It allowed us to specify a few values in the WHERE clause, so it worked a bit like the OR operator. Now, take a look:

SELECT *
FROM city
WHERE country_id IN (
  SELECT id FROM country
  WHERE country.population < 40000
);

Can you predict what the above instruction does? It shows all cities from countries where the total population of the country is less than 40,000.

Exercise
Show all information about all trips to cities which have a rating lower than 4.

Solution
SELECT * FROM TRIP
WHERE CITY_ID IN(
	SELECT ID FROM CITY
  	WHERE RATING < 4
)
