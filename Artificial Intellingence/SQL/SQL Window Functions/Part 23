Instruction
Of course, you can use any other ranking function in the same way:

SELECT
  id,
  country,
  city,
  rating,
  NTILE(2) OVER(PARTITION BY country ORDER BY opening_day)
FROM store;

In the above query, the stores are divided into two groups: older and more recent stores. These groups are created separately for each country.

Exercise
Take the sales between August 1 and August 10, 2016. For each row, show the store_id, the day, the revenue on that day and quartile number 
(quartile means we divide the rows into four groups) based on the revenue of the given store in the descending order.

Solution
select
    store_id,
    day,
    revenue,
    ntile(4) over(
      partition by store_id
      order by revenue desc
    )
from sales
where day between '2016-08-01' 
and '2016-08-10' 



Instruction
Do you remember queries that introduced WITH? We used them to find the row with a certain rank. 
Now, we can find even more rows with a certain rank, each for a different group. Take a look:

WITH ranking AS (
  SELECT
    country,
    city,
    RANK() OVER(PARTITION BY country ORDER BY rating DESC) AS rank
  FROM store
)

SELECT
  country,
  city
FROM ranking
WHERE rank = 1;

The CTE in the parentheses creates a separate ranking of stores in each country based on their rating. 
In the outer query, we simply return the rows with the right rank. As a result, we'll see the best store in each country.
