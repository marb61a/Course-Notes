Exercise
Let's define conversion rate as the number of clicks divided by the number of impressions, multiplied by 100 to obtain percentages.
For website_id = 1 and dates between May 15 and May 31, show each statistics row: 
day, clicks, impressions, conversion rate (as the conversion column) and the conversion rate on the previous day (as the previous_conversion column).

Solution
select  
    day,
    clicks,
    impressions,
    (clicks / cast(impressions as numeric)) * 100 as conversion,
    lag((clicks / cast(impressions as numeric)) * 100) over(
      order by day
    ) as previous_conversion
from statistics 
where day between '2016-05-15' and '2016-05-31'
and website_id = 1



Instruction
LEAD and LAG are 2 functions which are always relative to the current row. Now, we'll get to know three other functions that are independent of the current row.
The first one is FIRST_VALUE(x). As you may guess, it returns the first value in the column x in the given order. Take a look:

SELECT
  name,
  opened,
  budget,
  FIRST_VALUE(budget) OVER(ORDER BY opened)
FROM website;

Here, we still sort rows by the opening date (ORDER BY opened), but we show the budget for the earliest opening date (FIRST_VALUE(budget)). 
In this way, we can show the budget for the website that was opened first.
Note that this would be impossible to achieve with a simple MIN(...) function. MIN(budget) would simply show the smallest budget: 500 in this case. 
That is not the same as the budget of the first website (3000).

Exercise
Show the statistics for website_id = 2. For each row, show the day, the number of users and the smallest number of users ever.

Solution
select
    day,
    users,
    first_value(users) over(order by users)
from statistics
where website_id = 2


Exercise
Show the statistics for website_id = 3. For each row, show the day, the revenue and the revenue on the first day.

Solution
select
	day,
    revenue,
    first_value(revenue) over(order by revenue)
from statistics
where website_id = 3



Instruction
Of course, we can also find the last value: simply use LAST_VALUE(x) instead:

SELECT
  name,
  opened,
  LAST_VALUE(opened) OVER(ORDER BY opened)
FROM website;

Now, we'll see the opening date of each website plus the opening day of the last (most recent) website... or will we? Let's find out.

Exercise
Run the template from the instruction.
As you can see, the result is a bit different from our expectations. LAST_VALUE shows the current value instead of the highest value.

Solution
SELECT
  name,
  opened,
  LAST_VALUE(opened) OVER(ORDER BY opened)
FROM website;



Instruction
Well... The query didn't work! Instead of the latest opening date, we saw the current opening date.
In order to understand why this happened, we need to refer to the previous part of our course, where we talked about default window frames:
If there is an ORDER BY clause, RANGE UNBOUNDED PRECEDING will be used as the default window frame.
And this is precisely the cause of our troubles. We indeed used ORDER BY within OVER(...), 
which is why LAST_VALUE(x) only considers the rows from the first row until the current row. 
The solution is quite simple: we need to define the right window frame:

SELECT
  name,
  opened,
  LAST_VALUE(opened) OVER(
    ORDER BY opened
    ROWS BETWEEN UNBOUNDED PRECEDING
      AND UNBOUNDED FOLLOWING)
FROM website;

Exercise
Alright, let's run the new template to see if it works.

Solution
SELECT
  name,
  opened,
  LAST_VALUE(opened) OVER(
    ORDER BY opened
    ROWS BETWEEN UNBOUNDED PRECEDING
      AND UNBOUNDED FOLLOWING)
FROM website;
