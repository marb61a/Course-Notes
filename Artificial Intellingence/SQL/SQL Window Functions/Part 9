Instruction
Yet another thing you can do is rank by multiple columns, each of them in the ascending or descending order of your choice. 
Let's pretend that a player named John has limited space on his phone, but he wants to install a relatively recent game. Take a look:

SELECT
  name,
  genre,
  editor_rating,
  RANK() OVER(ORDER BY released DESC, size ASC)
FROM game;

We first sort the rows by the release date, with the latest games coming first, and then by size, with the smallest games appearing before bigger games.

Exercise
We want to find games which were both recently released and recently updated. 
For each game, show name, date of release and last update date, as well as their rank: use ROW_NUMBER(), 
sort by release date and then by update date, both in the descending order.

Solution
select 
    name,
    released,
    updated,
    row_number() over(order by released desc, updated desc)
from game



Instruction
You may wonder if you can use regular ORDER BY with the ranking functions. Of course, you can. 
The ranking function and the external ORDER BY are independent. 
The ranking function returns the rank with the respect to the order provided within OVER. Let's look at the example:

SELECT
  name,
  RANK() OVER (ORDER BY editor_rating)
FROM game
ORDER BY size DESC;

The query returns the name of the game and the rank of the game with respect to editor ranking. 
The returned rows are ordered by size of the game in descending way.

Exercise
For each game find its name, genre, its rank by size. Order the games by date of release with newest games coming first.

Solution
select
    name,
    genre,
    rank() over(order by size)
from game
order by released asc


Exercise
For each purchase, find the name of the game, the price, and the date of the purchase. 
Give purchases consecutive numbers by date when the purchase happened, so that the latest purchase gets number 1. 
Order the result by editor's rating of the game.

Solution
select
    g.name,
    p.price,
    p.date,
    row_number() over(order by p.date desc)
from purchase p
join game g
on g.id = p.game_id
order by g.editor_rating



Instruction
The last function we'll introduce in this section is NTILE(X). It distributes the rows into a specific number of groups, provided as X. For instance:

SELECT
  name,
  genre,
  editor_rating,
  NTILE(3) OVER (ORDER BY editor_rating DESC)
FROM game;

In the above example, we create three groups with NTILE(3) that are divided based on the values in the column editor_rating. 
The "best" games will be put in group 1, "average" games in group 2, "worst" games in group 3. See the picture below:
Note that if the number of rows is not divisible by the number of groups, 
some groups will have one more element than other groups, with larger groups coming first.

Exercise
We want to divide games into 4 groups with regard to their size, with biggest games coming first. 
For each game, show its name, genre, size and the group it belongs to

Solution
select
    name,
    genre,
    size,
    ntile(4) over(order by size desc)
from game
