Exercise
Select all the information from the table route.
A route in our system is, in other words, a railroad connection between point A and B.
Each route has its own id, its friendly name, the from_city and the to_city, as well as the distance between these two cities in kilometers.
For simplicity, we assume that we only have intercity trains, i.e. there are no stations between from_city and to_city where the train could stop.

Solution
select * from route


Exercise
Select all the information from the table journey.
Journey in our database is what passengers can buy tickets for. Each journey has its own id, is operated by a certain train, goes via a certain route on a certain day.
Take a look at the first row: if you had wanted to go from Sheffield to Manchester with train 1 on 3 Jan 2016, you would have bought a ticket for journey with id 1.

Solution
select * from journey


Exercise
Finally, there are tickets. Each ticket has its own id, price, seat class (1st or 2nd class) and the journey id for which it was bought. Show all these columns.

Solution
select * from ticket



Instruction
In this part, we'll learn one construction which can be put in OVER(), namely PARTITION BY. The basic syntax looks like this:

<window_function> OVER (PARTITION BY column1, column2 ... column_n)

PARTITION BY works in a similar way as GROUP BY: it partitions the rows into groups, based on the columns in PARTITION BY clause. 
Unlike GROUP BY, PARTITION BY does not collapse rows.
Let's see the example. For each train, the query returns its id, model, first_class_places and the sum of first class places from the same models of trains.
With PARTITION BY, you can easily compute the statistics for the whole group but keep details about individual rows.
What functions can you use with PARTITION BY? You can use an aggregate function that you already know (COUNT(), SUM(), AVG(), etc.), 
or another function, such as a ranking or an analytical function that you'll get to know in this course. 
Within parentheses, in turn, we've now put PARTITION BY, followed by the columns by which we want to partition (group).

Exercise
Press next exercise to continue

Solution
SELECT
  id,
  model,
  first_class_places,
  SUM(first_class_places) OVER (PARTITION BY model)
FROM train;


Instruction
As you can see, the query works fine. Imagine writing the same query using regular GROUP BY: you'd have to use a correlated subquery and a JOIN. 
The query would neither be readable nor efficient.
We no longer want to pay that price and PARTITION BY is the solution. 
Thanks to PARTITION BY, we can easily get the information about individual rows AND the information about the groups these rows belong to. 

Exercise
Show the id of each journey, its date and the number of journeys that took place on that date

Solution
select
	id, 
    date, 
    count(train_id) over(partition by date)
from journey



Instruction
Remember: window functions only work for those rows which are indeed returned by the query. Take a look at this query:

SELECT
  id,
  model,
  max_speed,
  COUNT(id) OVER (PARTITION BY max_speed)
FROM train
WHERE production_year != 2012;

We cut out the trains with production_year = 2012 and the query would not show them – that's pretty obvious. 
But the window function would not even count them – we could find out that there are only 2 trains with max_speed = 240, 
even though there is a third one which was produced in 2012. Note that a GROUP BY clause with a WHERE clause will behave in the same way – 
GROUP BY will only take into account rows which match the condition(s).

Exercise
Show id, model,first_class_places, second_class_places, and the number of trains of each model with more than 30 first class places 
and more than 180 second class places.

Solution
select
	id,
    model,
    first_class_places,
    second_class_places,
    count(id) over(partition by id)
from train
where first_class_places > 30
and second_class_places > 180
