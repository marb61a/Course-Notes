Instruction
As you can see, the query failed. However, let's take a look at another modification of this example:

SELECT
  category_id,
  MAX(final_price) AS max_final, 
  AVG(MAX(final_price)) OVER()
FROM auction
GROUP BY category_id;

What will happen now?

Exercise
Run the template.
As you can see, the query now succeeded because we used an aggregate function (MAX(final_price)) that was indeed available after grouping the rows. 
By the way, this is the only place where you can nest aggregate functions inside one another.

Solution
SELECT 
  category_id, 
  MAX(final_price) AS max_final, 
  AVG(MAX(final_price)) OVER() 
FROM auction 
GROUP BY category_id



Instruction
The best way to correctly create queries with window functions and GROUP BY is as follows: first, create the query with GROUP BY, but without window functions. 
Run the query (in the database or in your head). Now, the columns you see in the result are the only columns you can use in your window functions.

Exercise
Group the auctions by the country. Show the country, the minimal number of participants in an auction
and the average minimal number of participants across all countries.

Solution
select
    country,
    min(participants),
    avg(min(participants)) over()
from auction
group by country


Exercise
Group the auctions by category_id and show the category_id and maximal asking price in that category alongside the average maximal price across all categories.

Solution
select
    category_id,
    max(asking_price),
    avg(max(asking_price)) over()
from auction
group by category_id



Instruction
As you can see, it's fairly simple to create quite advanced statistics very easily thanks to how window functions behave with GROUP BY. 
Let's take a look at other use cases.
For instance, we may make a ranking based on an aggregate function. Take a look:

SELECT
  country,
  COUNT(id),
  RANK() OVER(ORDER BY COUNT(id) DESC)
FROM auction
GROUP BY country;

We grouped auctions with respect to the country, counted the number of auctions from each country... and then we created a ranking based on that count of auctions.

Exercise
Now, group the auctions based on the category. Show category_id, the sum of final prices for auctions from this category and a ranking based on that sum,
with the highest sum coming first.

Solution
select
    category_id,
    sum(final_price),
    rank() over(order by sum(final_price) desc)
from auction
group by category_id


Exercise
Group the auctions based on the day they ended and show the following columns: ended, 
the average number of views from auctions on that day and the ranking based on that average (the highest average should get the rank of 1).

Solution
select
    ended,
    avg(views),
    rank() over(order by avg(views) desc)
from auction
group by ended
