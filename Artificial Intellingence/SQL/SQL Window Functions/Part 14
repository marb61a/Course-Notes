Exercise
For each single_order, show its placed date, total_price and the average price from the current single_order and three previous orders (in terms of the placed date).

Solution
select
	placed,
    total_price,
    avg(total_price) over(
      order by placed
      rows between 3 preceding and current row
    )
from single_order



Instruction
It's time to look at another type of window frame: RANGE.
The difference between ROWS and RANGE is that RANGE will take into account all rows that have the same value in the column which we order by. 
This might be helpful with dates. Consider the following problem: we want to calculate the running sum from all orders sorted by date. 
We could write something like this:

SELECT
  id,
  placed,
  total_price,
  SUM(total_price) OVER (ORDER BY placed ROWS UNBOUNDED PRECEDING)
FROM single_order;

And it works fine. But our boss could say: hey, I don't really need to see how the running sum changed during single days. 
Just show the values at the end of the day; if there are multiple orders on a single day, add them together.
The above may be implemented by changing ROWS to RANGE. Look how we highlighted the rows which now share the same running sum because they come from the same date.

SELECT
  id,
  placed,
  total_price,
  SUM(total_price) OVER(ORDER BY placed RANGE UNBOUNDED PRECEDING)
FROM single_order;

Exercise
Modify the example so that it shows the average total_price for single days for each row.

Solution
SELECT
  id,
  placed,
  total_price,
  avg(total_price) OVER(ORDER BY placed RANGE current row)
FROM single_order;



Instruction
The difference between ROWS and RANGE is similar to the difference between the ranking functions ROW_NUMBER and RANK()
The query with ROWS sums the total_price for all rows which have their ROW_NUMBER less than or equal to the row number of the current row.

SELECT
  id,
  placed,
  total_price,
  ROW_NUMBER() OVER(ORDER BY placed),
  SUM(total_price) OVER(
    ORDER BY placed
    ROWS UNBOUNDED PRECEDING)
FROM single_order

The query with RANGE sums the total_price for all rows which have their RANK() less than or equal to the rank of the current row.

SELECT
  id,
  placed,
  total_price,
  RANK() OVER(ORDER BY placed),
  SUM(total_price) OVER(
    ORDER BY placed
    RANGE UNBOUNDED PRECEDING)
FROM single_order

Exercise
Press Next exercise to continue

Solution
No solution needed



Instruction
The window frame of RANGE is defined just like the window frame of ROWS: use BETWEEN ... AND ..., or the abbreviated version.
You can use RANGE UNBOUNDED PRECEDING and RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING, as well as RANGE CURRENT ROW, 
but you can't use n PRECEDING and n FOLLOWING with RANGE.
Why? With ROWS, we always knew that there was a single current row, and so we could easily calculate the previous/next rows. 
With RANGE, the database must understand what "three preceding values" means. It's easy to understand "three preceding days" 
but what are "three numbers preceding 14.5"? The SQL standard defined the meaning of n PRECEDING and n FOLLOWING for RANGE, 
but the database usually do not implement it. Refer to the documentation of your database to make sure.

Exercise
For each stock_change with product_id = 7, show its id, quantity, changed date and another column 
which will count the number of stock changes with product_id = 7 on that particular date

Solution
select
    id,
    quantity,
    changed,
    count(changed) over(
      order by changed
      range current row
    )
from stock_change
where product_id = 7
