Exercise
Select all the information from the store table.
Each store has its own id, country and city. There is only one store per city in our table to make things a bit easier. 
Apart from that, you can see when the store was opened and what rating it has (1-5), based on customers' opinions.

Solution
select * from store


Exercise
Select all the information from the sales table.
In this table, the sales results are gathered for each store from the period between August 1 and August 14 2016. 
You can find the id of the store, the date, and three important values: the total revenue on that day, 
the number of transactions and the number of customers who entered the store (but not necessarily bought anything).

Solution
select * from sales



Instruction
Before we start writing queries with PARTITION BY ORDER BY, let's quickly revise queries with PARTITION BY alone. Take a look:

SELECT
  country,
  city,
  rating,
  AVG(rating) OVER(PARTITION BY country)
FROM store;

In the above query, we show the rating of each store plus the average rating calculated for the respective country. 
If we hadn't used PARTITION BY country, we would have ended up with an average across all stores. This way, we get separate average values for each country.

Exercise
For each sales row, show the store_id, day, revenue on that day and the average revenue in that store.

Solution
select
    store_id,
    day,
    revenue,
    avg(revenue) over(partition by store_id)
from sales


Exercise
For each sales row between August 1 and August 7, 2016, show the store_id, day, number of transactions,
the total number of transactions on that day in any store and the ratio of the two last columns shown as percentage rounded to integer values.

Solution
select
    store_id,
    day,
    transactions,
    sum(transactions) over(
      partition by day
    ),
    round(cast(transactions as numeric) * 100/sum(transactions)
    over(partition by day))
from sales
where day between '2016-08-01' 
and '2016-08-07'



Instruction
We'll introduce the features chronologically. In part 4, you learned ranking functions. 
They are one of the places where you can apply PARTITION BY and ORDER BY together.
So far, all the rankings we calculated were performed for all the rows from the query result. 
With that knowledge, we could have calculated the position of each store in the global network based on their ratings:

SELECT
  id,
  country,
  city,
  rating,
  RANK() OVER(ORDER BY rating DESC)
FROM store;

Diagram A

Now, we can add PARTITION BY to calculate the positions independently for each country:

SELECT
  id,
  country,
  city,
  rating,
  RANK() OVER(PARTITION BY country ORDER BY rating DESC)
FROM store;

In this way, we create a separate ranking for each country, so Paris and Frankfurt can both get rank = 1 for the separate rankings in France and Germany:


Exercise
Take into account the period between August 10 and August 14, 2016. 
For each row of sales, show the following information: store_id, day, number of customers 
and the rank based on the number of customers in the particular store (in descending order).

Solution
select
    store_id,
    day,
    customers,
    rank() over(
      partition by store_id
      order by customers desc
    )
from sales
where day between '2016-08-10' 
and '2016-08-14' 
