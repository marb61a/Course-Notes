                    Linux Kernel Fundamentals - Course Notes


                    Section 1 - Introduction
1 - Welcome
Brief introduction to both the syllabus of the course and the instructor

2 - Using the exercise files
A quick guide on how to use the provided exercise files

3 - Prerequisites and Takeaways
The student should already be familiar with
  - The Linux Command Line
  - C Programming
  - Know how to edit files on Linux
The student should have
  - A Linux Machine with Root access
  - A virtual machine would be helpful
  - Ensure the safety of your data before doing anything
  - A distro of your choice the instructor is using CentOS 

4 - What is the Linux kernel
The Kernel is a progam
  - It often has a name like vmlinuz-<KERNEL VERSION>
  - It is loaded and run by a bootloader eg GRUB
  - It has command line interface as various commands can be ran against it
The Kernel is an API
  - System calls which are functions that we can call from userspace into the Kernel
  - The Kernel also provides virtual file systems such as  proc, sys and debugfs
  - System Calls such as device files
The Kernel is a Gatekeeper
  - It enforces privileges or capabilities as they are known also
  - Executes Supervisor instructions which are special CPU instructions for Supervisor mode
  - It implements a number of security policies
  - It controls access to hardware and other resources
The Kernel is modular
  - The Kernel image itself is relatively small
  - The Kernel image is sufficient to boot to userspace
  - Optional functionality is added after booting
  - It allows for alternative setups such as only loading drivers for a specific set of hardware

5 - Where`s the kernel
  - cd boot     // change to the boot directory
  - ls          // list fies which will show vmlinuz files
  - uname -r    // will check kernel version being run



                    Section 2 - Surveying The Linux Kernel
1 - Discover and control hardware
Software layers to and from hardware
  - Applications call functions in the libraries
    - Some of these functions invoke kernel system calls
  - Some system calls interact with hardware
  - Some commands for getting information about hardware
    - lshw    // Lists hardware
    - lspci   // Lists pci devices
      - combined with -v to get detailed verbose information
    - lsusb   // Lists USB devices
    - lsbk    // Lists block devices
    - lscpu   // Lists CPU
    - lsdev   // Lists other devices
  - Not all Linux distros have these commands available
  - There are also commands available for configuring and controlling hardware
    - hdparm  // This is used for hard disks eg what speed it is
    - echo to proc dev or sys files
    - inb\outb  // This tranfers bytes to or from the bus eg writing a byte to a specific address
    - setpci  // You are able to change registers

2 - Understand system call mechanics
System Calls are functions implemented by the kernel and are meant to be called from user space
  - In Linux there are about 300 different System Calls available
     - See include/uapi/asm-generic/unistd.h
Applications do not make System Calls directly
  - They are called through the standard library
The Standard library uses architecture dependent means to invoke the system call mechanism
  - It usually makes use of registers and suitably sized parameters are placed into these registers
  - The kernel is then invoked which determines the appropriate System Call and calls it
The System Call Return
  - If errors occur System Calls return a negative value to the library
  - If there has been an error the library sets a value called errno to abs(return value0 and returns a -1
  - If there has been no error occuring errno is not set and the value it obtains from the kernel is returned
System Calls are in Section 2 of the manual
  - man 2 read // for the read section
  - There are man pages available for all System Calls 

3 - Read messages from the kernel
printk() is the most commonly called function in the Linux kernel
printk() is the kernel function for code to print messages
  - It is similar to the C function printf()
It is sent to the RAM buffer and the system console
Important enough messages are shown on the console
  - They are filtered by  printk
  - The logging daemon that is running may send messages to file or elsewhere
To display Kernel messages 
  - dmesg shows RAM buffer messages from the kernel
  - messages from the kernel start very early in the boot process
  - RAM buffer is limited in size
  - The log file has kernel messages and more
    - In linux is is located at /var/log/messages
    - /var/log/messages has elevated priviliege levels
  - The tail -f /var/log/messages can be handy to use as you will have a continuous scrolling of messages

4 - Use the -proc and -sys filesystems
The proc and sysfs file systems are virtual filesystems
  - Their contents are not stored on harddrive
  - Each file and directory entry has has an associated function in the kernel that produces the content on demand
/proc
  - The proc filesystem is mounted on /proc at boot
  - proc gets its name from process
  - proc contains lots of process information and more
  

5 - Challenge - Hardware, system calls, messages, proc, and sysfs
The challenges for the chapter are
  1. What kernel version is your Linux system running?
  2. What is the size of the kernel file that corresponds to the kernel your system is running?
  3. How much RAM is available to your running kernel? Note: It may or may not be the amount of
  physical RAM on your system.
  4. The command strace will display the system calls that a process makes as it runs. Using the man
  command, determine what option for strace will show a summary, with a count, of the number of
  times a process called each system call. Using that option, what system call is called the most by the
  command date ?
  5. Can you determine, using strace , what system call is used to change the directory?
  6. Run a sleep 100 with & (to put it in the background). What files does its process have open?
  7. Does your system have a PCI Ethernet device?
  8. Is the kernel variable ip_forward (under /proc/sys/ ...) set to 1 or 0 on your system?
  9. According to /sys/block , do you have a block device (disk) sda ? If so, do you have device files for
  partitions of sda ? How many? Using strace , does the command fdisk -l (run it as root), open any
  files under /sys/dev/block ?
  10. Using dmesg and grep , do you see the kernel reporting the kernel command line? If not, can you
  determine if the boot messages from the kernel were lost? Does your system have a log file that
  recorded the boot messages? You can grep for BOOT_IMAGE under /var/log to look.
  11. What other device files are character devices and share the same major number with /dev/null ?
  12. What other device files are character devices and share the same major number with /dev/null ?

6 - Challenge solution
Solutions to the challenges of the previous section
  - uname -r
  - ls -l /boot/vmlinuz*
  - head /proc/meminfo
  - strace -c date
  - strace cd /tmp
  - sleep 100 &
  - lscpi | grep i ethernet

7 - Challenge solution, part 2
Continuing from the previous section
  - find .-name ip_forward
  


                    Section 3 - Booting
1 - Understand the bootloader GRUB
GRUB is an acronym standing for
  - GRand Unified Bootloader
GRUB is executed after POST & BIOS
It is installed on a special place on the disk
GRUB does several things, it loads
  - The kernel
  - The initial root filesystem
  - It sets up the kernel command line
  - It then transfers control to the kernel
GRUB can be interrupted and can be interacted with
GRUB is very flexible
  - It is built with support for filesystems, this means it can find files even kernel files by name
  - It can do filename completion
  - It has a lot of utilities that it can use

2 - Configure GRUB
There were different files for the different GRUB versions
GRUB 2 is much more sophisticated than its predecessor
  - /etc/grub.d
  - /etc/default/grub
To create new GRUB entries
  - Edit or add a config file in /etc/grub.d 
  - The number in front of the filename affects the order in which the file is processed
    - 40_custom is the usual file if adding a new entry
  - Run grub2-mkconfig to generate a new config file
GRUB is interactive
  - It normally pauses before launching Linux
  - You can interrupt by hitting a key
  - You are able to temporarily edit grub configuration
    - To continue with your changes the b key or ctr-x is usually used

3 - Identify and use the kernel command-line parameters
GRUB passes the command line parameters to the kernel
  - The kernel then processes those command line arguments
  - Unrecognised parameters are just ignored
  - User space may look at kernel level command line arguments too
  - You can use either dmesg of /proc/cmdline to see
Kernel Parameters
  - In the kernel source tree it is Documentation/kernel-parameters.txt
    - There are about 500 different parameters documented here
  - Many of them are registered with _setup() in source

4 - Configure run levels and targets
The initial Root filesystem
  - Linux systems ferquently start by mounting a file system from RAM
    - The filesystem that contains a "/" is called the root filesystem
  - The initial RAM filesystem(initrd) is used to provide drivers and support for mounting the systems real root filesystem
  - The initrd has an init that the kernel runs first
The first process (from disk)
  - When the init from the initrd terminates the linux kernel starts init again from the real filesytem (usually on disk)
  - On modern systems init is a link to systemd
  - This process is responsible for starting up system services suach as daemons like a web server
System Services
  - On older Linux systems there were runlevel scripts to start services under etc/rc.d
  - Systemd files are under the /etc/systemd/system directory
  - These are user space services not kernel level

5 - Debug initramfs images

6 - Challenge - Configure GRUB and the targets and customize the initramfs

7 - Challenge solution



                    Section 4 - Working With Loadable Kernel Modules
1 - Introduction to the loadable kernel modules (LKMs)

2 - Find the LKMs

3 - Use LKM commands

4 - Identify how LKMs work

5 - Challenge - Work with the LKMs

6 - Challenge solution



                    Section 5 - Examining Kernel Source Code
1 - Get the kernel source

2 - Explore the kernel makefile

3 - Examine and build kernel documentation

4 - Search the kernel source

5 - Examine kernel driver source

6 - Examine additional selected subdirectories

7 - Challenge - Work with the Linux kernel source code

8 - Challenge solution



                    Section 6 - Configuring And Building A Linux Kernel
1 - Configure the kernel using make menuconfig

2 - Configure the kernel using make xconfig

3 - Explore kernel config files

4 - Build and install modules and the Linux kernel

5 - Challenge - Configure, build, and install a new Linux kernel and LKMs

6 - Challenge solution

7 - Goodbye
Final video of the course
