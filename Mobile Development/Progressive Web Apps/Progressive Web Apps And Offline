                    Progressive Web Apps And Offline
                    Course Notes


                    Section 1 - Progressive Web Applications and Offline
1 - Introduction
Introduction to the course & instructor

2 - Defining PWA
What is a Progressive Web App
  - It uses the latest advanced web technologies
  - Adopts a progressive enhancement tenet
  - It transcends what users will normally expect from a browser
    - EG Offline working and Push notifications
    - This limits some of the need for native app development
  - It also offers a native like experience
There are 10 characteristics of PWA's
  - Progressive in that they work for a variety of browsers
  - Responsive because mobile traffic has eclipsed desktop traffic
  - Works offline because PWA's should work regardless of absent or poor quality connections
  - App Like because you can add them and launch them from the home screen
  - Fresh because they should get up to date content without complex process
  - Safe because security is very important, HTTPS is used by about 60% of the web
  - Discoverable, they should have rich metadata for search engines
  - Re-engageable in the form of notifications so that users can be bought back into an app
  - Durable in that they should be able to store data so that it survives
  - Linkable, so that url linking is possible along with native deep linking
The course will cover all of this

3 - Project: Frontend Grocer
The course has a sample app which will be used during the course
  - It will need to be set up as part of Exercise 0
  - At the beginning of the course it works like a standard single page app
    - It is built in React but the work will be done in Vanilla JS
    - The React will work only as a thin view layer
  - During the course there will be support added for
    - Background Tasks
    - Notifications
    - Offline Boot
    - Custom 404 images
    - Offline Add-To-Cart
    - Background Sync
    - Native Look And Feel
    - Offline on iOS
    


                    Section 2 - Measuring Apps
1 - Quantifying Web App Success

2 - Chrome DevTools
Devtools are available at
  - https://developers.google.com/web/tools/chrome-devtools/
  
3 - Lighthouse & WebPageTest
Measuring Apps
  - There are important metrics which will be watched
    - Time to first paint
    - Time to interactive
    - Time to dynamic data
  - The chrome devtools course is recommended
    - There are notes on this course available
      - https://github.com/marb61a/Course-Notes/blob/master/General Web Development/Tools/Mastering Chrome Developer Tools
  - The course will be touching on HTTP2
  - Web Apps should perform at about 60 fps if performing well
    - Knowing how to read the flame chart on the performance tab in devtools is important
      - The flame chart shows how long each function takes to invoke
    - Keeping an eye on this chart during development is recommended
  - Lighthouse is a new tool for measuring performance
    - https://developers.google.com/web/tools/lighthouse/
    - This is a very new tool but has a great advantage as it can be run from Chrome Devtools
  - Webpagetest is a much older but extremely useful tool
    - https://www.webpagetest.org
    - It allows you to run speed tests from around the world
    - It uses real browsers at real connection speeds
      - This gives a much more realistic view of user experience
    - It supports many advanced features such as
      - Multi-Step Transactions, Scripting, Video Capture, Content Blocking and  Single Point of Failure Testing
    - This is free but the domain must be public if using the website version
      - A way around this is to host it yourself as the application is open source
      
4 - Challenge 0: Baseline
The first item will be to set up the project, get it running and test with Lighthouse
    - Clone the github repo
    - Use the yarn command to install
    - Beginning app should be available on the browser
    - Vapid keys are necessary for web push
      - web-push generate-vapid-keys --json > ./private/vapid.json
      - This command generates both public and private keys
      - This file is in json format so should be kept secret
    - The node version should be at least 7.10
    - To start the app use the following command
      - npm run watch
      - Also there are a couple of other options available for running everything
        // This first option is deprecated and npm run watch is recommended instead
        - ./run serve 
        - node ./server/cli/cli.js serve
    - To build the app use the following command
      - npm run build:prod
      - This may take a few minutes to do the first time
      - Webpack will do some tree shaking for unused code
    - Gzip works really well compressing reoccuring string
    - An environmental variable is added which will open a web based tool when building the app
      - ANALYZE=true npm run build:prod
      - This will show a graphical representation of what is making up the compressed app file

5 - Challenge 0: Solution
Windows 10 users are recommended to install the Linux subsystem
The installation procedure is available at the following url
  - https://msdn.microsoft.com/en-us/commandline/wsl/install-win10
  - This installs pieces of Ubuntu alongside Windows
  - This gives a true Bash environment
    - This means that setup is much faster



                    Section 3 - Mobile Simulation
1 - DevTools Devices Mode
Mobile Simulation
  - When running the app in Chrome/Firefox/Safari etc, the devices mode is the first thing to be reached for
  - The devices mode can do several things
    - It simulates device web experiences
    - It simulates sensor input
      - This includes GPS co-ordinates which can be simulated
      - Also device orientation and items like long press simulating righ-click
    - It is closer to Android than iOS
    - There is responsive breakpoint visualisation
    - This is still in Chrome
    
2 - iOS Simulator
iOS Simulator
  - Localhost is your machine
  - This is critical for testing Apple-specific features
  - This emulates even CPU architecture
  - This is more similar to a virtual machine
  - It allows you to test things you would not otherwise be able to do
  - Mobile Safari is different then desktop Safari
  - It is easy to connect Safari to the simulator
  - It is useful for validating against the 2 iOS JS engines
    
3 - Android Simulator
Android Simulator
  - 10.0.2.2 is the machine address
  - The simulator can be connected to devtools
  - You will need to install Android Studio
  - This can be an involved process
  - At least one member of the team should have this setup
  - Some of the PWA technology appears on Android first
  - Use standard sizes when creating a virtual device



                    Section 4 - Progressive Metadata
1 - Viewport Metatag
Progressive Metadata
The example application is at this point as if no-one had thought of mobile experience
The first thing to be examined is the viewport
Example Syntax
  // Viewport can be set so as to approximate what viewers expect from native apps
  // The name attribute and content attribute are convention and can be thought of as key-value pairs
  // Reccomended that user scalable be set to no as it will better approximate native app settings where zooming
  // is not available on many native apps eg Twitter on the address bar where no zoom is
  <meta name="viewport" content="width=device-width, initial-scale=1">
    - width is a positive integer or device-width
    - initial-scale is a positive number between 1.0 and 10.0
    - maximum-scale is a positive number between 1.0 and 10.0
    - minimum-scale is a positive number between 1.0 and 10.0
    - user-scalable is a yes or no

2 - Fullscreen Metatags
Apple-Specific Metatags
  - There are hundreds of platform specific tags
  - There is a cheet sheet available as part of the course
Example Syntax
  // Fullscreen
  <meta name="apple-mobile-web-app-capable" content="yes">
  // Black Status Bar
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  // Home Screen Title
  <meta name="apple-mobile-web-app-title" content="Home Screen">
  
3 - manifest.json
The manifest.json file display option has several different settings to choose from
  - fullscreen -- This is where are available area is used
  - standalone -- It looks and feels like a standalone app
  - minimal-ui -- "light-browser" ui, it does not have it's own window
  - browser -- This is a conventional app in a browser
    - This is the default setting

Not all versions of iOS or Android will read this app manifest
  - Older versions of Android for example used to use meta-tags but the trtend is towards an icon array
  
4 - Home Screen Icons
Application Manifest
  - This is part of the PWA standard
Example Syntax
  // The manifest.json file
  // This is the link that would be in the index.html file
  <link rel="manifest" href="manifest.json">
  
  {
    "name": "MyApp",                        //App name
    "icons": [                              //Various icon sizes
      // A 192px square is recommended for "add to home screen"
      // This is used for Android high resolution
      // There is no image resizing so images must be correct
      {
        "src": "image_src_path",
        "sizes": 192x192,
        "type": "image/png"
      },
      // A 512px square is recommended for the startup screen
      {
         "src": "image_src_path",
        "sizes": 512x512,
        "type": "image/png"
      }
    ]
    "theme_color": "#2d89ef",               //Theme bar styling
    "background_color": "#2d89ef",          //Used for startup screen
    "display": "standalone"                 //Launch as an app
  }

5 - schema.org
PWA's should be linkable
  - They should also be discoverable
  - This means that they show up in search results
Example Syntax
  // Schema/org Metadata
  // There are notes on structured data available at
  // - https://github.com/marb61a/Course-Notes/blob/master/HTML5/HTML Structured Data
  // The script tags allow for inert data to be added to html, there is another way which
  // uses attributes. These give machines more information on what the data actually is and what it is doing
  // This description will improve the SEO of the app
  <script type="application/ld+json">
    "@context": "http://schema.org",
    "@type": "Product",
    "image": "image_path",
    "name": "product_or_service_name",
    "offers": {
      "@type": "Offer",
      "price": "price_of_offer"
    }
  </script>

6 - Challenge 1: Metadata
The exercise for the section involves making enhancements to the app
  - Add to home screen
  - FEGrocer should be used as the app name
  - Home screen icon
  - Remover Browser UI 
  - Theme bar is the same as the app bar
  - Icons for 192, 96, 48
  // This is ensure an app is entered through a certain url
  // This is not the same experience as a true native app
  - start_url is "."
  - Viewport suitable for mobile devices and applike
Tips for solving the exercise
  - index.html is generated from /client/index.ejs
  - Webpack can be used to generate a file via file-loader
    - import 'file-loader?name=web-app-manifest.json!./web-app-maifest.json';
      - This file will exist when the app is built as a result of this lin
    - This goes at the top of the ./client/index.js or./client/app.jsx file
  - Use the simulator to verify changes are working
  - Add schema.org product metadata for grocery items
    - ./client/components/grocery-item/index.jsx
  - There maybe a need to change a setting is some IDE's due to build errors caused by tab size
    - Tab size should be 2 and is 4 by default in VS Code
    - This may need to be set although some plugins cause issues

7 - Challenge 1: Solution
Solving the challenges from the end of the previous section
  - Create a web-app-manifest.json file in the client folder
  - Copy the sample code for the manifest file
    - This can then be adjusted for the app
  - index.ejs will represent the index.html file
    - The ejs stands for embedded javascript
  - The course will use up to 4 types of manifest file
    - This means that they should be named properly
  - Rebuild the app and then run
    - Open up the devtools panel on Chrome
    - Under the application tab you should see a manifest 
  - Debugging can be challenging in the PWA world as warnings are not given
    - In the course the presence of comments was affecting the manifest file
  - After the app is runing  there is a short name property added to the manifest file
  - Then the icons can be added beginning with the 192x192 size
    - Each size will have to be added individually
    - When the page is refereshed these icons can be seen in the manifest
  - Next the start_url property is added to the manifest file
    - In this case it is set to "."
  - After these few changes the app will be ran to see what the Lighthouse score will be
    - There are a few steps which must be taken before running Lighthouse due to HTTPS
      - Make a build of the app
      - Then serve it over HTTP2
        - ./run serve --http2 is used in the course but is deprecated
  - The Lighthouse score will probably differ from machine to machine
    - The report it generates is very in-depth so is very good to have
  - Add a meta tag with the theme-color will get rid of the warning about it being missing
    - The theme-color can be the one specified in the manifest file
    - <meta name="theme-color" content="#2d89ef">
  - A viewport tag needs to be added
    - This can be added along with the Apple specific tags to index.ejs
      - <meta name="viewport" content="width=device-width, initial-scale=1">
      - <meta name="apple-mobile-web-app-capable" content="yes">
      - <meta name="apple-mobile-web-app-status-bar-style" content="black">
      - <meta name="apple-mobile-web-app-title" content="Home Screen">
  - There may be a web-socket problem on the ios-simulator
    - This is down to an implementation problem on browser implementation


                    Section 5 - Enhanced Server-side Rendering
1 - Performance Timeline
Server Side Rendering
  - There is a full set of notes on SSR (React oriented) at
    - https://github.com/marb61a/Course-Notes/blob/master/Javascript/React/Server Side Rendering with React and Redux
  - At the present moment in the app there is nothing visible in the body
  - It is very important to pay attention to the 3 main metrics brifely discussed earlier
    - Time to first paint, time to data, time to interactive
  - Pure client-side rendering requires JS to land before anything interesting can happen
    - CSS payloads are much smaller than JS payloads
  - The general solution for Server Side Rendering is difficult
    - Remember that browser JS  != to NodeJS
    - There is a sustainable and quick middleground available for many apps
    - The course will show this which the instructor calls enhanced client side rendering

2 - Enhanced Client-side Rendering
Enhanced Client-Side Rendering
  - This works for a wide range of apps with some URL-agnostic high level UI
  - There are 3 steps involved in the process
    - Boot the app with URL-agnostic HTML
    - Embed any critical CSS into the index.html file
    - Then add a loading spinner
  - This maybe a good use case for using CSS for interactivity rather than just JS
    - On example is instead of a onClick() JS maybe a CSS Hover effect
    - The instructor recommends using as much CSS in top level navigation as possible
Server Side Rendering
  - You wont have static hosting you will instead have a rendering server
  - There are dynamic HTML responses on a per request basis
  - It involves some special treatment of browser-only concepts
    - When using SSR you will need to be aware of JS core standards vs accepted conventions
      - When using libraries like JQuery that need AJAX and a full DOM then SSR is going to be very slow
      - This will require using alot of work arounds eg Stubbing & DOM virtualisation
    - XMLHttpRequest
    - window, navigator, sensors, localstorage etc
      - These will be very problematic for SSR (at least at the start)
  - Initial HTML response is slowed down considerably
    - However this is offset by URL-specific content being ready when it arrives
    
3 - Server-side Rendering

4 - Challenge 2: Enhanced Client-side Rendering

5 - Challenge 2: Solution



                    Section 6 - Promises
1 - Reviewing Promises

2 - Chaining & Creation




                    Section 7 - JavaScript Workers
1 - Introducing Web Workers

2 - Dedicated vs. Shared Workers

3 - Limitations & Features

4 - Terminating a Worker

5 - Challenge 3: Web Workers

6 - Challenge 3: Solution



                    Section 8 - Async Data
1 - Reviewing Async Methods

2 - Fetch API

3 - Fetch Requests

4 - Fetch & CORS

5 - Challenge 4: Using Fetch, Part 1

6 - Challenge 5: Using Fetch, Part 2

7 - Challenges 4 & 5: Solutions



                  Section 9 - Service Worker
1 - Introducing Service Worker

2 - Service Worker Features

3 - Challenge 6: Simple Service Worker

4 - Challenge 6: Solution

5 - Service Worker Review

6 - Intercepting Network Requests

7 - Service Worker Demo



                    Section 10 - Cache API
1 - Introducing Cache API

2 - Challenge 7: Fallback Image

3 - Challenge 7: Solution

4 - Introducing Caching Strategies

5 - Precache Caching

6 - Network with Cache Backup

7 - Cache, Update, and Refresh

8 - Challenge 8: Integrating Precache

9 - Challenge 8: Solution

10 - Challenge 9: Caching Dynamic Data

11 - Challenge 9: Solution

12 - Challenge 10: SPA Treatment of index.html

13 - Challenge 10: Solution



                      Section 11 -IndexedDB
1 - Introducing IndexedDB

2 - IndexedDB API

3 - IndexedDB & Promises

4 - Challenge 11: IndexedDB

5 - Challenge 11: Solution



                    Section 12 - Web Push
1 - Push API and Notification API

2 - VAPID for Web Push

3 - Structure of PushSubscription

4 - Challenge 12: Web Push

5 - Challenge 12: Solution



                    Section 13 - Notifications
1 - Introducing Notifications

2 - Challenge 13: Notifications

3 - Challenge 13: Solution



                    Section 14 - Background Sync
1 - Introducing Background Sync

2 - Background Sync Strategies

3 - Background Sync Demo

4 - Problems with App Cache



                    Section 15 - HTTP/2
1 - Introducing HTTP/2



                    Section 16 - Patterns for PWAs
1 - Application Shell Pattern

2 - PRPL Pattern



                    Section 17 - Wrapping Up
1 - Reviewing PWA Technologies

2 - Final Measurements


