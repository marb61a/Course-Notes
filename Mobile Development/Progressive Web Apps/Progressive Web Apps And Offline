                    Progressive Web Apps And Offline
                    Course Notes


                    Section 1 - Progressive Web Applications and Offline
1 - Introduction
Introduction to the course & instructor

2 - Defining PWA
What is a Progressive Web App
  - It uses the latest advanced web technologies
  - Adopts a progressive enhancement tenet
  - It transcends what users will normally expect from a browser
    - EG Offline working and Push notifications
    - This limits some of the need for native app development
  - It also offers a native like experience
There are 10 characteristics of PWA's
  - Progressive in that they work for a variety of browsers
  - Responsive because mobile traffic has eclipsed desktop traffic
  - Works offline because PWA's should work regardless of absent or poor quality connections
  - App Like because you can add them and launch them from the home screen
  - Fresh because they should get up to date content without complex process
  - Safe because security is very important, HTTPS is used by about 60% of the web
  - Discoverable, they should have rich metadata for search engines
  - Re-engageable in the form of notifications so that users can be bought back into an app
  - Durable in that they should be able to store data so that it survives
  - Linkable, so that url linking is possible along with native deep linking
The course will cover all of this

3 - Project: Frontend Grocer
The course has a sample app which will be used during the course
  - It will need to be set up as part of Exercise 0
  - At the beginning of the course it works like a standard single page app
    - It is built in React but the work will be done in Vanilla JS
    - The React will work only as a thin view layer
  - During the course there will be support added for
    - Background Tasks
    - Notifications
    - Offline Boot
    - Custom 404 images
    - Offline Add-To-Cart
    - Background Sync
    - Native Look And Feel
    - Offline on iOS
    


                    Section 2 - Measuring Apps
1 - Quantifying Web App Success

2 - Chrome DevTools
Devtools are available at
  - https://developers.google.com/web/tools/chrome-devtools/
  
3 - Lighthouse & WebPageTest
Measuring Apps
  - There are important metrics which will be watched
    - Time to first paint
    - Time to interactive
    - Time to dynamic data
  - The chrome devtools course is recommended
    - There are notes on this course available
      - https://github.com/marb61a/Course-Notes/blob/master/General Web Development/Tools/Mastering Chrome Developer Tools
  - The course will be touching on HTTP2
  - Web Apps should perform at about 60 fps if performing well
    - Knowing how to read the flame chart on the performance tab in devtools is important
      - The flame chart shows how long each function takes to invoke
    - Keeping an eye on this chart during development is recommended
  - Lighthouse is a new tool for measuring performance
    - https://developers.google.com/web/tools/lighthouse/
    - This is a very new tool but has a great advantage as it can be run from Chrome Devtools
  - Webpagetest is a much older but extremely useful tool
    - https://www.webpagetest.org
    - It allows you to run speed tests from around the world
    - It uses real browsers at real connection speeds
      - This gives a much more realistic view of user experience
    - It supports many advanced features such as
      - Multi-Step Transactions, Scripting, Video Capture, Content Blocking and  Single Point of Failure Testing
    - This is free but the domain must be public if using the website version
      - A way around this is to host it yourself as the application is open source
      
4 - Challenge 0: Baseline
The first item will be to set up the project, get it running and test with Lighthouse
    - Clone the github repo
    - Use the yarn command to install
    - Beginning app should be available on the browser
    - Vapid keys are necessary for web push
      - web-push generate-vapid-keys --json > ./private/vapid.json
      - This command generates both public and private keys
      - This file is in json format so should be kept secret
    - The node version should be at least 7.10
    - To start the app use the following command
      - npm run watch
      - Also there are a couple of other options available for running everything
        // This first option is deprecated and npm run watch is recommended instead
        - ./run serve 
        - node ./server/cli/cli.js serve
    - To build the app use the following command
      - npm run build:prod
      - This may take a few minutes to do the first time
      - Webpack will do some tree shaking for unused code
    - Gzip works really well compressing reoccuring string
    - An environmental variable is added which will open a web based tool when building the app
      - ANALYZE=true npm run build:prod
      - This will show a graphical representation of what is making up the compressed app file

5 - Challenge 0: Solution
Windows 10 users are recommended to install the Linux subsystem
The installation procedure is available at the following url
  - https://msdn.microsoft.com/en-us/commandline/wsl/install-win10
  - This installs pieces of Ubuntu alongside Windows
  - This gives a true Bash environment
    - This means that setup is much faster



                    Section 3 - Mobile Simulation
1 - DevTools Devices Mode
Mobile Simulation
  - When running the app in Chrome/Firefox/Safari etc, the devices mode is the first thing to be reached for
  - The devices mode can do several things
    - It simulates device web experiences
    - It simulates sensor input
      - This includes GPS co-ordinates which can be simulated
      - Also device orientation and items like long press simulating righ-click
    - It is closer to Android than iOS
    - There is responsive breakpoint visualisation
    - This is still in Chrome
    
2 - iOS Simulator
iOS Simulator
  - Localhost is your machine
  - This is critical for testing Apple-specific features
  - This emulates even CPU architecture
  - This is more similar to a virtual machine
  - It allows you to test things you would not otherwise be able to do
  - Mobile Safari is different then desktop Safari
  - It is easy to connect Safari to the simulator
  - It is useful for validating against the 2 iOS JS engines
    
3 - Android Simulator
Android Simulator
  - 10.0.2.2 is the machine address
  - The simulator can be connected to devtools
  - You will need to install Android Studio
  - This can be an involved process
  - At least one member of the team should have this setup
  - Some of the PWA technology appears on Android first
  - Use standard sizes when creating a virtual device



                    Section 4 - Progressive Metadata
1 - Viewport Metatag

2 - Fullscreen Metatags

3 - manifest.json

4 - Home Screen Icons

5 - schema.org
PWA's should be linkable
  - They should also be discoverable
  - This means that they show up in search results
Example Syntax
  // Schema/org Metadata
  // There are notes on structured data available at
  // - https://github.com/marb61a/Course-Notes/blob/master/HTML5/HTML Structured Data
  // The script tags allow for inert data to be added to html, there is another way which
  // uses attributes. These give machines more information on what the data actually is and what it is doing
  // This description will improve the SEO of the app
  <script type="application/ld+json">
    "@context": "http://schema.org",
    "@type": "Product",
    "image": "image_path",
    "name": "product_or_service_name",
    "offers": {
      "@type": "Offer",
      "price": "price_of_offer"
    }
  </script>

6 - Challenge 1: Metadata

7 - Challenge 1: Solution



                    Section 5 - Enhanced Server-side Rendering
1 - Performance Timeline
Server Side Rendering
  - There is a full set of notes on SSR (React oriented) at
    - https://github.com/marb61a/Course-Notes/blob/master/Javascript/React/Server Side Rendering with React and Redux
  - At the present moment in the app there is nothing visible in the body
  - It is very important to pay attention to the 3 main metrics brifely discussed earlier
    - Time to first paint, time to data, time to interactive
  - Pure client-side rendering requires JS to land before anything interesting can happen
    - CSS payloads are much smaller than JS payloads
  - The general solution for Server Side Rendering is difficult
    - Remember that browser JS  != to NodeJS
    - There is a sustainable and quick middleground available for many apps
    - The course will show this which the instructor calls enhanced client side rendering

2 - Enhanced Client-side Rendering

3 - Server-side Rendering

4 - Challenge 2: Enhanced Client-side Rendering

5 - Challenge 2: Solution



                    Section 6 - Promises
1 - Reviewing Promises

2 - Chaining & Creation




                    Section 7 - JavaScript Workers
1 - Introducing Web Workers
02:08:05 - 02:14:52
Introducing Web Workers
Mike introduces web workers, which is a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the UI.
Dedicated vs. Shared Workers
02:14:53 - 02:16:29
Dedicated vs. Shared Workers
Mike illustrates the differences between dedicated and shared workers.
Limitations & Features
02:16:30 - 02:20:01
Limitations & Features
To avoid potential problems coding workers such as deadlocks, Mike reviews the limitations of web workers.
Terminating a Worker
02:20:02 - 02:25:55
Terminating a Worker
Mike illustrates how and when to terminate a worker.
Challenge 3: Web Workers
02:25:56 - 02:30:55
Challenge 3: Web Workers
In this challenge, students create a call for a QR code reader into a web worker.
Challenge 3: Solution
02:30:56 - 02:47:41
Challenge 3: Solution
Mike walks through the solution to Challenge 3 with Steve's help.
Async Data

Reviewing Async Methods
02:47:42 - 02:51:35
Reviewing Async Methods
After reviews web technologies on the client side to create asynchronous web applications.
Fetch API
02:51:36 - 02:57:30
Fetch API
Steve introduces Fetch API, a modern interface for accessing and manipulating resources that has a more flexible feature set than XMLHttpRequest.
Fetch Requests
02:57:31 - 03:00:33
Fetch Requests
Steve and Mike review how to create a basic Fetch request.
Fetch & CORS
03:00:34 - 03:11:49
Fetch & CORS
After reviewing Cross-Origin Resource Sharing (CORS), a system for restricted resources on a web page to be requested from another domain outside, Steve demonstrates how to handle external resources through Fetch.
Challenge 4: Using Fetch, Part 1
03:11:50 - 03:16:06
Challenge 4: Using Fetch, Part 1
In this challenge, students fix the store cart, so it persists to course's example API.
Challenge 5: Using Fetch, Part 2
03:16:07 - 03:16:54
Challenge 5: Using Fetch, Part 2
In this challenge, students code the cart so that when a user checks out the contents of their cart are persisted so than an order is created.
Challenges 4 & 5: Solutions
03:16:55 - 03:30:59
Challenges 4 & 5: Solutions
Steve walks through the solution to Challenges 4 and 5 with Steve's help.
Service Worker

Introducing Service Worker
03:31:00 - 03:38:07
Introducing Service Worker
Steve introduces Service Worker, which is a crucial technology in constructing WPAs.
Service Worker Features
03:38:08 - 03:54:01
Service Worker Features
Steve illustrates the features of Service Workers, which can run in the background, allow for checking network availability, updating assets, access to push notifications, and more.
Challenge 6: Simple Service Worker
03:54:02 - 03:57:57
Challenge 6: Simple Service Worker
In this challenge, students implement a service worker.
Challenge 6: Solution
03:57:58 - 04:22:02
Challenge 6: Solution
Steve walks through the solution to Challenge 6 and answers student questions with Mike's help.
Service Worker Review
04:22:03 - 04:29:52
Service Worker Review
Steve reviews features and coding structures of Service Workers.
Intercepting Network Requests
04:29:53 - 04:35:28
Intercepting Network Requests
Steve discusses Service Worker's ability for an application to intercept any network requests and respond back with custom responses. Steve also takes questions from students.
Service Worker Demo
04:35:29 - 04:39:41
Service Worker Demo
Steve demonstrates using conditional logic with a Service Worker that can intercept network request. - http://intercepting-fetch.glitch.me/
Cache API

Introducing Cache API
04:39:42 - 04:53:56
Introducing Cache API
Steve introduces Cache API, a utility for fine-grain control over caching assets from inside of a service worker.
Challenge 7: Fallback Image
04:53:57 - 04:57:32
Challenge 7: Fallback Image
In this challenge, students implement a fallback image in the event the application encounters a response status for image requests.
Challenge 7: Solution
04:57:33 - 05:20:19
Challenge 7: Solution
Steve walks through the solution to Challenge 7.
Introducing Caching Strategies
05:20:20 - 05:26:16
Introducing Caching Strategies
Mike reviews Cache API strategies including Cache-Only, Network-Only, and Cache with Network Backup.
Precache Caching
05:26:17 - 05:35:16
Precache Caching
Mike breaks down precaching strategy and reviews a demo of how precaching works.
Network with Cache Backup
05:35:17 - 05:42:37
Network with Cache Backup
Mike demonstrates a caching strategy that first tries to use the network before falling back to the cache.
Cache, Update, and Refresh
05:42:38 - 05:48:05
Cache, Update, and Refresh
After reviewing Cache, Update, and Refresh Caching Strategy, which is when an app updates an asset when it detects a new version on the network, Mike discusses best practices for approaching caching strategies.
Challenge 8: Integrating Precache
05:48:06 - 05:52:33
Challenge 8: Integrating Precache
In this challenge, students implement precaching in the course project application.
Challenge 8: Solution
05:52:34 - 06:34:39
Challenge 8: Solution
After reviewing CORS related to credentialed requests and wildcard requests, Mike walks through the solution to Challenge 8 with Steve's help.
Challenge 9: Caching Dynamic Data
06:34:40 - 06:49:54
Challenge 9: Caching Dynamic Data
In this challenge, students implement a fetech event handler that uses a cache fallback strategy for all GET requests that are not precached in advanced.
Challenge 9: Solution
06:49:55 - 07:17:02
Challenge 9: Solution
Mike walks through the solution to Challenge 9.
Challenge 10: SPA Treatment of index.html
07:17:03 - 07:23:33
Challenge 10: SPA Treatment of index.html
In this challenge, students incoporate preacaching approaches to an index.html of a SPA.
Challenge 10: Solution
07:23:34 - 07:35:31
Challenge 10: Solution
Mike walks through the solution to Challenge 10.
IndexedDB

Introducing IndexedDB
07:35:32 - 07:40:57
Introducing IndexedDB
Mike introduces indexedDB (Indexed Database API), which is a low-level API for client-side storage of structured data, including files and blobs.
IndexedDB API
07:40:58 - 07:50:06
IndexedDB API
After reviewing the IndexedDB API including opening or creating the database, migrating, transactions, and more, Mike examines current browser support for IndexedDB.
IndexedDB & Promises
07:50:07 - 07:52:02
IndexedDB & Promises
Mike reviews IDB, an open source library that replaces the IDBRequest objects with promises. - https://github.com/jakearchibald/idb
Challenge 11: IndexedDB
07:52:03 - 07:57:28
Challenge 11: IndexedDB
In this challenge, students populate an IndexedDB store with grocery store items in the install handler and then utilize IndedexedDB to provide better contextual fallback images.
Challenge 11: Solution
07:57:29 - 08:20:48
Challenge 11: Solution
Mike walks through the solution to Challenge 11.
Web Push

Push API and Notification API
08:20:49 - 08:28:10
Push API and Notification API
Mike reviews Web Push, which uses the Push API and Notification APIs to send timely updates to site visitors.
VAPID for Web Push
08:28:11 - 08:30:40
VAPID for Web Push
After introducing Voluntary Application Server Identification (VAPID) for Web Push, which helps distinguish legitimate traffic from bad, Mike demonstrates how to generate VAPID keys.
Structure of PushSubscription
08:30:41 - 08:35:30
Structure of PushSubscription
Mikes shows showing PushSubscription code and underscores the importance of using a library for sending notifications. Mike takes questions from students. - https://github.com/web-push-libs
Challenge 12: Web Push
08:35:31 - 08:39:44
Challenge 12: Web Push
In this challenge, students generate a web push subscription.
Challenge 12: Solution
08:39:45 - 08:55:02
Challenge 12: Solution
Mike walks through the solution to Challenge 12 and takes questions from students.
Notifications

Introducing Notifications
08:55:03 - 09:04:24
Introducing Notifications
Steve reviews Notifications including how to approach implementing notifications including options for the user's visual and behavioral interactions.
Challenge 13: Notifications
09:04:25 - 09:05:08
Challenge 13: Notifications
In this challenge, students implement notifications in course example application.
Challenge 13: Solution
09:05:09 - 09:12:07
Challenge 13: Solution
Steve walks through the solution to Challenge 13.
Background Sync

Introducing Background Sync
09:12:08 - 09:20:25
Introducing Background Sync
Steve introduces background sync, which is a web API that defers actions until the application has access to a stable Internet connection.
Background Sync Strategies
09:20:26 - 09:23:20
Background Sync Strategies
Steve reviews best practices and techniques for working with background sync.
Background Sync Demo
09:23:21 - 09:30:05
Background Sync Demo
Using a simple To Do list application, Steve demonstrates how a service worker is used to implement background sync.
Problems with App Cache
09:30:06 - 09:34:52
Problems with App Cache
To work around Safari's lack of support of Service Worker reviews how an alternative with App Cache might be used and the problems associated with this approach.
HTTP/2

Introducing HTTP/2
09:34:53 - 09:49:11
Introducing HTTP/2
Mike reviews the features and browser support of HTTP/2, a revision of the HTTP network protocol.
Patterns for PWAs

Application Shell Pattern
09:49:12 - 09:52:57
Application Shell Pattern
Mike starts reviewing common PWA patterns by first examining the Application Shell Pattern, which focuses on the core components necessary for an app rather than data.
PRPL Pattern
09:52:58 - 09:55:22
PRPL Pattern
Mike introduces the Push Render Pre-Cache Lazy-load (PRPL) pattern for PWAs. In this pattern, a developer would Push critical resources for the initial URL route, Render initial route, Pre-cache remaining routes, and Lazy-load and then create remaining routes on demand.
Wrapping Up

Reviewing PWA Technologies
09:55:23 - 09:58:32
Reviewing PWA Technologies
Mike reviews PWA technologies and how they work on a user's first and return visit to an application.
Final Measurements
09:58:33 - 10:03:01
Final Measurements
Now updated for PWA support, Mike re-evaluates the metrics of the course demo application with the Lighthouse Chrome extension.








  
  


Progressive Metadata
The example application is at this point as if no-one had thought of mobile experience
The first thing to be examined is the viewport
Example Syntax
  // Viewport can be set so as to approximate what viewers expect from native apps
  // The name attribute and content attribute are convention and can be thought of as key-value pairs
  // Reccomended that user scalable be set to no as it will better approximate native app settings where zooming
  // is not available on many native apps eg Twitter on the address bar where no zoom is
  <meta name="viewport" content="width=device-width, initial-scale=1">
    - width is a positive integer or device-width
    - initial-scale is a positive number between 1.0 and 10.0
    - maximum-scale is a positive number between 1.0 and 10.0
    - minimum-scale is a positive number between 1.0 and 10.0
    - user-scalable is a yes or no
Apple-Specific Metatags
  - There are hundreds of platform specific tags
  - There is a cheet sheet available as part of the course
Example Syntax
  // Fullscreen
  <meta name="apple-mobile-web-app-capable" content="yes">
  // Black Status Bar
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  // Home Screen Title
  <meta name="apple-mobile-web-app-title" content="Home Screen">
Application Manifest
  - This is part of the PWA standard
Example Syntax
  // The manifest.json file
  // This is the link that would be in the index.html file
  <link rel="manifest" href="manifest.json">
  
  {
    "name": "MyApp",                        //App name
    "icons": [                              //Various icon sizes
      // A 192px square is recommended for "add to home screen"
      // This is used for Android high resolution
      // There is no image resizing so images must be correct
      {
        "src": "image_src_path",
        "sizes": 192x192,
        "type": "image/png"
      },
      // A 512px square is recommended for the startup screen
      {
         "src": "image_src_path",
        "sizes": 512x512,
        "type": "image/png"
      }
    ]
    "theme_color": "#2d89ef",               //Theme bar styling
    "background_color": "#2d89ef",          //Used for startup screen
    "display": "standalone"                 //Launch as an app
  }

The manifest.json file display option has several different settings to choose from
  - fullscreen -- This is where are available area is used
  - standalone -- It looks and feels like a standalone app
  - minimal-ui -- "light-browser" ui, it does not have it's own window
  - browser -- This is a conventional app in a browser
    - This is the default setting

Not all versions of iOS or Android will read this app manifest
  - Older versions of Android for example used to use meta-tags but the trtend is towards an icon array
  

  
The exercise for the section involves making enhancements to the app
  - Add to home screen
  - FEGrocer should be used as the app name
  - Home screen icon
  - Remover Browser UI 
  - Theme bar is the same as the app bar
  - Icons for 192, 96, 48
  // This is ensure an app is entered through a certain url
  // This is not the same experience as a true native app
  - start_url is "."
  - Viewport suitable for mobile devices and applike
Tips for solving the exercise
  - index.html is generated from /client/index.ejs
  - Webpack can be used to generate a file via file-loader
    - import 'file-loader?name=web-app-manifest.json!./web-app-maifest.json';
      - This file will exist when the app is built as a result of this lin
    - This goes at the top of the ./client/index.js or./client/app.jsx file
  - Use the simulator to verify changes are working
  - Add schema.org product metadata for grocery items
    - ./client/components/grocery-item/index.jsx
  - There maybe a need to change a setting is some IDE's due to build errors caused by tab size
    - Tab size should be 2 and is 4 by default in VS Code
    - This may need to be set although some plugins cause issues


3 -
Solving the challenges from the end of the previous section
  - Create a web-app-manifest.json file in the client folder
  - Copy the sample code for the manifest file
    - This can then be adjusted for the app
  - index.ejs will represent the index.html file
    - The ejs stands for embedded javascript
  - The course will use up to 4 types of manifest file
    - This means that they should be named properly
  - Rebuild the app and then run
    - Open up the devtools panel on Chrome
    - Under the application tab you should see a manifest 
  - Debugging can be challenging in the PWA world as warnings are not given
    - In the course the presence of comments was affecting the manifest file
  - After the app is runing  there is a short name property added to the manifest file
  - Then the icons can be added beginning with the 192x192 size
    - Each size will have to be added individually
    - When the page is refereshed these icons can be seen in the manifest
  - Next the start_url property is added to the manifest file
    - In this case it is set to "."
  - After these few changes the app will be ran to see what the Lighthouse score will be
    - There are a few steps which must be taken before running Lighthouse due to HTTPS
      - Make a build of the app
      - Then serve it over HTTP2
        - ./run serve --http2 is used in the course but is deprecated
  - The Lighthouse score will probably differ from machine to machine
    - The report it generates is very in-depth so is very good to have
  - Add a meta tag with the theme-color will get rid of the warning about it being missing
    - The theme-color can be the one specified in the manifest file
    - <meta name="theme-color" content="#2d89ef">
  - A viewport tag needs to be added
    - This can be added along with the Apple specific tags to index.ejs
      - <meta name="viewport" content="width=device-width, initial-scale=1">
      - <meta name="apple-mobile-web-app-capable" content="yes">
      - <meta name="apple-mobile-web-app-status-bar-style" content="black">
      - <meta name="apple-mobile-web-app-title" content="Home Screen">
  - There may be a web-socket problem on the ios-simulator
    - This is down to an implementation problem on browser implementation


Enhanced Client-Side Rendering
  - This works for a wide range of apps with some URL-agnostic high level UI
  - There are 3 steps involved in the process
    - Boot the app with URL-agnostic HTML
    - Embed any critical CSS into the index.html file
    - Then add a loading spinner
  - This maybe a good use case for using CSS for interactivity rather than just JS
    - On example is instead of a onClick() JS maybe a CSS Hover effect
    - The instructor recommends using as much CSS in top level navigation as possible
Server Side Rendering
  - You wont have static hosting you will instead have a rendering server
  - There are dynamic HTML responses on a per request basis
  - It involves some special treatment of browser-only concepts
    - When using SSR you will need to be aware of JS core standards vs accepted conventions
      - When using libraries like JQuery that need AJAX and a full DOM then SSR is going to be very slow
      - This will require using alot of work arounds eg Stubbing & DOM virtualisation
    - XMLHttpRequest
    - window, navigator, sensors, localstorage etc
      - These will be very problematic for SSR (at least at the start)
  - Initial HTML response is slowed down considerably
    - However this is offset by URL-specific content being ready when it arrives

