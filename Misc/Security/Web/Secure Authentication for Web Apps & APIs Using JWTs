                    Secure Authentication for Web Apps & APIs Using JWTs


                    Section 1 - JSON Web Tokens
1 - Getting Started
Quick run through of the agenda
Course has made demo application available in angular 1 & 2 and also React
Course will use Angular 2 code samples
  - https://github.com/chenkie/angular2-user-authentication
  - https://github.com/chenkie/angular1-user-authentication
  - https://github.com/chenkie/react-user-authentication
    - ** if using the React version you may need to create an env file at the root of the project
API that course will be using, it requires having MongoDB installed
  - https://github.com/chenkie/user-authentication-api
Live version of the API is being served at this link
  - https://user-authentication-api-ocokqryugz.now.sh/api/


2 - Application & API Demonstration
Quick demonstration of the example application
The different frameworks are pretty much the same apart from a couple of lines
The Demo API
  - Is a simple REST APi that allows users to sign up and log in
  - When a user has been authenticated a JSON Web Token is returned in the response
  - The API has a resource called instructors which returns a list of instructors
A quick demonstration of what a JSON Web Token looks like under the bonnet
  - Response has the key token and long string
  - Postman is used as part of the demo and is a chrome based add on
    - https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en


3 - Challenge: Run the Finished Application
The challenge is to to run the finished app in any of the frameworks available
You will need to access the API and view the documentation for its endpoints
You can also clone and run the API locally
There is also the option of creating a user for yourself at the /api/users endpoint in Postman
  - https://github.com/chenkie/user-authentication-api  
  - https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop


4 - JSON Web Token Basics
There may be a bug in the react version login.js file
  - The onSignupSubmit should say this.props.auth.signup instead of this.props.auth.login
Also if Postman is causing payload errors set as form-data for the type
A JSON Web Token
  - It is an Open Standard RFC 7519
  - It is a method for transferring claims(assertions) between two parties securely through a JSON payload
  - A digitally signed and compact, self-contained package
  - It is also a great mechanism for stateless authentication
A JWT has 3 main sections
  - A header
    - JSON object that describes the token
    - Includes token type and signing algorithm
    - Signing algorithm is necessary for token verification
    - Commonly tokens are signed with HS256 or RS256
  - Payload 
    - JSON object that contains any claims abouth the entity for which it was issued
    - The JWT standard has a set of reserved claims
      - iss, sub, aud, exp, nbf, iat, jti
    - It can also contain arbitrary claims defined at will
  - Signature
    - A JSON object produced by Base64URL encoding the header and payload and then running through a hashing algorithm
    with a secret key
    - The signature is used as a means to digitally sign a token so that its validity can be verified later
    - If anything in the header or payload is modified the token will be invalidated
  

5 - Challenge: Inspecting a JWT
  - https://jwt.io/
  - JWT are often pronounced jot
  - The site allows you to decode, verify and generate JWT



                    Section 2 - JSON Web Tokens & Single Page Applications
1 - Traditional Authentication
Traditional client - server interactions were straightforware
  request <----> response
Modern interactions have become much more complex
Traditional authentication process
  - The user submits their credentials which are checked against a database
  - If everything checks out a session is created for them on the server and a cookie with session_id is sent back to the 
    browser
  - The cookie is sent back to the server on all subsequent requests and is verified against the session

There are some downside to this approach to authentication
  - Since a Single Page App does not refresh  how does it know that a user is logged in
    - Traditional apps construct views on the backend  which is where the authentication is checked
  - How do Single Page Apps receive their data, normally its a REST api through a XHR
    - REST api should be stateless and traditional authentication is stateful
  - Modern architecture relies on micro services and downstrem servers but cookies do not flow downstream
    - Communication between multiple servers with traditional auth is not easy
  - Access control will require database queries
    - This introduces a lot of general chattiness on the backend
  - This type of authentiaction does not scale well and can become very memory intensive
  - In traditional authentication the server does the heavy lifting

2 - JWT Authentication
User submits credentials which are then checked against a database
If everything is good then a token is signed and returned to the client in response
The token is saved on the client usually in a cookie or web storage
  - Using cookies will create some limitations
The token is sent as an Authorization header on every HTTP request
When the request is received on the backend, the JWT is verified against the secret that only the server knows
The payload is checked to route the the request based on the JWT's claims
  - This is usually done with middleware
If the JWT is valid the request is returned
If the JWT is invalid a 401 is returned

How Does This Help
The Single Page App (SPA) no longer relies on the backend to tell it whether the user is authenticated 
The backend can receive requests from multiple clients and the backend only cares that the token is valid
Requests can flow to downstreeam servers if necessary
The client tells the backend what is permissable instead of asking
  - This means that there is no need for user access lookups 

JWT's may be vulnerable if there is CSRF attacks to grab tokens

3 - Securing the Payload
Taking Q & A from the audience
JWT's can be implemented in SPA's but will look different
JWT supports encryption via JWE
More information available at
  - https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3
Demo app uses BCrypt for password hashing and is recommended by the instructor
Signing JWT Sunction Syntax
  // First the the user will be verified in the database
  // Then a token will be issued
  return jwt.sign({
    sub: user.id,
    username: user.username,
    email: user.email,
    gravatar: createGravatarUrl(user.email),
    scope
  // Secret should be unguessable, strings, about 64 in length
  // Best practice is to have it as an environmental variable and not to have it in a repository
  }, secret, { 
    algorithm: 'HS256',
    expiresIn: "1h" 
  });


4 - Implementing Authentication with JWT
How implementing JWT actually works in practice
How does the SPA get the JWT
  - The user submits their credentials
  - If the credentials are valid a JWT is signed and returned in response
  - A secret key known only by the server is used to sign the JWT
JWT Storage
Once the JWT comes back it will be stored somewhere in the user's browser
Storing in memory would be a poor choice as the token would be lost when the page is refreshed
JWT's are typically stored in browser storage(local storage or session storage) or in HTTP only cookies
Example Syntax -> uses the Angular 2 example app
  finishAuthentication(token): void{
    localStorage.setItem('token', token);
    this.router.navigate([profile]);
  }
  
  logout(): void{
    localStorage.removeItem('token');
  }
Its very important to keep secret keys protected
Good practice is to have short lived tokens you should not have tokens with long expiry times
Expiry time should be around 10 hours
Expiry time is checked when the token is sent to the server
Removing the token from where it is being stored will logout due to it being stateless
If the user has copied the token it could mean that they are still logged in
Some organisations have issues with the way JWT's operate as revoking is not easy in JWT authentication
Login Component Syntax
  export class LoginComponent{
    errorMessage: string;
    
    constructor(private auth: AuthService){};
    
    onLoginSubmit(credentials){
      this.auth.login(credentials)
      .map(res => res.json())
      .subscribe(
        response => this.auth.finishAuthentication(response.token),
        error => this.errorMessage = error.josn().message;
      )
    }
    
    onSignupSubmit(credentials){
      this.auth.signup(credentials)
      .map(res => res.json())
      .subscribe(
        response => this.auth.finishAuthentication(response.token),
        error => this.errorMessage = error.josn().message;
      )
    }
  }

Auth Service Syntax
  @Injectable
  export class AuthService{
    constructor(private http: Http, private router: Router){}
    
    login(credentials): Observable<Response>{
      return this.http.post(`${API_URL}/users/authenticate`, credentials);
    }
    
    signup(credentials): Observable<Response>{
      return this.http.post('${API_URL}/users', credentials);
    }
    
    finishAuthentication(token): void{
      localStorage.setItem('token', token);
      this.router.navigate(['profile']);
    }
    
    logout(): void{
      localStorage.removeItem('token');
    }
  }


5 - Challenge: Creating the Login & Signup
The challenges for the section are
  - Checkout branch 01-implmenting-auth-starter
  - Create a screen for login and signup
  - Make a POST request with the user's credentials
  - Store the JWT that comes back in local storage
  - Create a logout method that removes the token from local storage
  - Provide buttons for Log In and Log Out in home view and toolbar
  
  // The Angular 2 version is available at
  - https://github.com/chenkie/angular2-user-authentication/tree/01-implementing-auth-starter

6 - Creating the Login & Signup Solution
Solution to Login and Signup Exercise - Uses the Angular 2 solution
App runs on port 4200 by default
Solution Syntax
  export class LoginComponent{
    errorMessage: string;
    constructor(private auth: AuthService){};
    
    onLoginSubmit(credentials){
      this.auth.login(credentials)
      .map(res => res.json())
      .subscribe(
        response => this.auth.finishAuthentication(response.token),
        error => this.errorMessage = error.josn().message;
      )
    }
    
    onSignupSubmit(credentials){
      this.auth.signup(credentials)
      .map(res => res.json())
      .subscribe(
        response => this.auth.finishAuthentication(response.token),
        error => this.errorMessage = error.josn().message;
      )
    }
  }
  
  @Injectable
  export class AuthService{
    constructor(private http: Http, private router: Router){}
    
    login(credentials): Observable<Response>{
      return this.http.post(`${API_URL}/users/authenticate`, credentials);
    }
    
    signup(credentials): Observable<Response>{
      return this.http.post('${API_URL}/users', credentials);
    }
    
    finishAuthentication(token): void{
      localStorage.setItem('token', token);
      this.router.navigate(['profile']);
    }
    
    logout(): void{
      localStorage.removeItem('token');
    }    
  }
  
  HTML Syntax
  <button class="btn btn-primary" routerLink="/login">
    Log In
  </button>
  // Auth is used because auth is injected in the component
  <button class="btn btn-primary" (click)="auth.logout" routerLink="/home">
    Log Out
  </button>

Token will be stored in local stotage
Official Repository is at
  - https://github.com/chenkie/angular2-user-authentication/tree/01-implementing-auth-solution
