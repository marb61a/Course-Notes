The Ultimate XSS Training Course
                    Course Notes Part 2


XSS Filter Evasion (Cont)
  - Creativity and persistence will be needed in some cases
    - What would happen if each instance of javascript: or alert() was filtered
  - Using the JavaScript URLs with Filtering example
    - This will filter out the javascript:alert()
  - You may be able to get past some of the filtering by changing character cases
    - Other things to try include adding tabs and spaces
    - There will be a lot of examples online
  - Custom filtering is not going to save a site from attack

How To Use Event Handlers For XSS Exploits
  - Fine-tuning event handlers for exploits
  - In order to understand XSS you must understand exploit techniques
  - You should understand how attackers are going to attack your applications
  - There are 2 qualities that must be met for an exploit to be high quality
    - It must execute quickly
    - The attack must remain undetected
  - Using event handlers properly in exploits will require a higher level of skill
  - Using the Exploit With Event Handlers example
  - There is a small "share this page" link at the end of the page
    - Using the dev tools inspector shows a data-url attribute currently set to its present URL
    - Adding a payload to the url is the vulnerability
      - url#"onclick="alert() - each time that the element is click will cause the alert to popup
      - onclick may not be the best choice, onmouseover may be a better option along with some CSS styling
      - CSS styles can be used in tags with the style attribute
  - Continuing the above example using the mouseover with styles combination instead
    - url#"onmouseover=alert() style=position:fixed;top:0;left:0;width:100%25;height:100%25;
      - Elements are usually positioned where they appear in the html but can be changed in this case using the position attribute
      - This will position the element at the top of the page and beginning
      - Some characters will need to be URLEncoded
        - This is done by taking the % character and adding the Hex value eg % becomes %25
      - Semi colons can be left at this juncture as it is in the URL hash rather than as a query parameter
      - With all the options added to the URL the element covers the whole page
      - This will run very quickly
    - url#"onmouseover=alert() style=position:fixed;top:0;left:0;width:100%25;height:100%25;color:transparent;
      - The next goal is to make the element unseen, this is done using the color attribute and the value transparent
  - At this stage the HTML needs to be cleaned as it contains exploit code
    - The onmouseover and style attributes need to be removed
    - This can be done in an event handler eg before an alert add code that deletes itself
    - In JS the word this can be used to refer to the same element
      - url#"onmouseover=this.removeAttribute('onmouseover')alert() style=position:fixed;top:0;left:0;width:100%25;height:100%25;color:transparent;
    - Like CSS, JS expressions can be separated by semi-colons
      - url#"onmouseover=this.removeAttribute('onmouseover');
          this.removeAttribute('style')alert() style=position:fixed;top:0;left:0;width:100%25;height:100%25;color:transparent;
  - The attack runs once and then is removed by itself
  - Using the XSS with progress events example
    - Script tags will be stripped out
    - This example needs immediate execution and onmouseover needs user interaction so is not suitable
    - JavaScript URL's and progress events will be the way as they give perfect immediate execution
    - Progress events in JS are things such as load, timeout, progress etc
    - An example of progress events with immediate execution are IFrame elements with JS URL's
      - <iframe src=javascript:alert()></iframe>
    - JavaScript URL's will not work with every element that uses source attributes such as images
      - You should still be able to use progress events to get code to run
  - A common payload is to use an image attibute with an invalid source and then use the onerror event handler
    - <img src=x onerror=alert()>
  - There is still the issue of hiding the attack
    - Using CSS values to hide elements only partially solves the problem
    - There is still the code inside the HTML on the page
      - The element needs to be destroyed, this can be done using element.remove()
        - <img src=x onerror=this.remove();alert()>
  - Automatically destroyed payloads are very difficult to find

XSS Attacks Inside JavaScript
  - Injecting into HTML is not the only place that XSS can occur
    - Sometime JavaScript code can also be vulnerable
  - Attacking through JavaScript requires proper syntax
    - JavaScript is much less forgiving than HTML so ensure syntax is correct to avoid issues
  - JS Strings are the most likely place to find XSS vulnerabilities
    - Single and double quotes can be used to create Strings as can back ticks `` 
    - Back ticks can contain code inside them, these are called template literals
      - The code iside is marked using a dollar and brackets eg `fasfsd ${Code} swg`
    - You may not need to break out of a template literal to inject code
      - You may just have to use ${}
  - One method of breaking out properly is to surround your payload with the proper quotes or ticks
    - Then add  + or - characters between the original string, the payload and the final string just created
  - Strings are often assigned to variables in JS but that is not always the case
    - There are 3 other areas where you might find strings
      - Function arguments, there can be multiple comma separated arguments passed in including strings
      - Array elements which can also be vulnerable strings
      - Objects names and values eg {name: value}
        - You can have vulnerable strings in names but it is more common to find them in values
  - You can use the console to enter vulnerable JS code
    - 
  - Polyglots The Ultimate XSS Payloads
  -
