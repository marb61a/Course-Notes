                    Four Semesters of Computer Science in 5 Hours
                    Course Notes


                    Section 1 - Big O & Recursion
1 - Introduction
Introduction to the course
The GitHub site associated with the course is 
  - https://btholt.github.io/four-semesters-of-cs/
The course will help with interviews which may not be related to day to day jobs
  - It will also help to create more complex but readable code
  - Learning this material will make a better developer

2 - Big O

3 - Finding Big O

4 - Recursion

5 - Recursion Example

6 - Exercise 1: Recursion

7 - Exercise 1 Solution



                    Section 2 - Sorting Algorithms
1 - Bubble Sort

2 - Exercise 2: Bubble Sort

3 - Exercise 2 Solution

4 - Insertion Sort

5 - Exercise 3: Insertion Sort

6 - Exercise 3 Solution

7 - Merge Sort

8 - Exercise 4: Merge Sort

9 - Exercise 4 Solution

10 - Median Values

11 - Quick Sort

12 - Exercise 5: Quick Sort

13 - Exercise 5 Solution



                    Section 3 - Data Structure Interfaces
1 - Interfaces Data Structure

2 - Set Data Structure

3 - Map Data Structure

4 - Stack Data Structure

5 - Queue Data Structure



                    Section 4 - Implementing Data Structures
1 - Array List

2 - Exercise 6: Array List
02:36:08 - 02:39:51
Exercise 6: Array List
- In this exercise you will approximate an implementation of ArrayList. Brian begins the exercise by stubbing out the class and member functions needed in the implementation. He then gives the group time to complete the exercise.
Exercise 6 Solution
02:39:52 - 02:47:53
Exercise 6 Solution
- Brian walks through the solution to exercise 6.
Linked List
02:47:54 - 02:59:13
Linked List
- Brian spends a few minutes diagramming linked lists and comparing their specifications with array lists. Linked lists are composed of nodes which point to the next node in the list. While item retrieval is slower with a linked list, adding and removing is much faster.
Exercise 7: Linked List
02:59:14 - 03:05:31
Exercise 7: Linked List
- In this exercise, you will implement a linked list. Like the previous exercise, Brian begins by stubbing out the the two classes necessary for his implementation.
Exercise 7 Solution Part 1
03:05:32 - 03:14:47
Exercise 7 Solution Part 1
- Brian begins walking through the solution to exercise 7.
Exercise 7 Solution Part 2
03:14:48 - 03:22:34
Exercise 7 Solution Part 2
- Brian finishes the solution to exercise 7.
Binary Search Tree
03:22:35 - 03:28:27
Binary Search Tree
- Trees are useful middle ground between array lists and linked lists. Brian introduces the Binary Search Tree which is composed of nodes with 0, 1, or 2 subtrees. Elements in the left subtree are lesser than the node value. Elements in the right subtree are greater than the node value.
Exercise 8: Binary Search Tree
03:28:28 - 03:34:46
Exercise 8: Binary Search Tree
- In this exercise, you will create a binary search tree. The Tree class will keep track of a root which will be the first item added. From there, if the item is less than the value of that node, it will go into its left subtree and if greater it will go to the right subtree.
Exercise 8 Solution
03:34:47 - 03:43:07
Exercise 8 Solution
- Brian walks through the solution to exercise 8.
AVL Tree
03:43:08 - 03:48:34
AVL Tree
- AVL trees are a specialized binary search tree. When values are added to an AVL tree, a recursive call will check to see if any rebalancing is necessary. A tree is considered out of balance if the difference in height of any two subtrees is greater that one.
Single Rotation
03:48:35 - 03:59:09
Single Rotation
- Brian demonstrates how rotations are performed. They are necessary when one side of the tree is too heavy and needs rebalancing. Single rotations can take the form of either a right rotation or a left rotation.
Double Rotation
03:59:10 - 04:05:17
Double Rotation
- A double rotation is necessary when the opposite child is heavy during a rotation. For example, if the execution of a right rotation causes the left side to be heavy, a left rotation should be performed first on the child node.
Exercise 9 Solution Part 1
04:05:18 - 04:12:21
Exercise 9 Solution Part 1
- Brian begins walking through the solution to exercise 9. In this first part, he creates the Node class and implements the add() method which handles creating left and right child nodes.
Exercise 9 Solution Part 2
04:12:22 - 04:21:26
Exercise 9 Solution Part 2
- Brian finishes the solution to exercise 9. He implements the balance() method in the Node class. He also looks at the left and right rotation code.
Hash Table
04:21:27 - 04:30:05
Hash Table
- Hash tables are key-value stores used to implement maps or sets. With hash tables, the key is used as the index for where to find the value in memory. This is done by passing the key through a hashing function which converts it to an addressable space. After introducing hash tables, Brian talks through some of the code from the hash table exercise.


Functional Programming 101
1 - Functional Programming Concepts
04:30:06 - 04:34:46
Functional Programming Concepts
- Brian explains the foundations of functional programming and talks about why using functional programming will help you create code that itâ€™s more maintainable, composeable, and easier to reason about. He also talks about using higher order functions and how to avoid side effects.
Map Function
04:34:47 - 04:39:03
Map Function
- Map is a higher order function that has similarities to forEach. It takes a function as a parameter and applies that function individually to each element in an array. It returns a new array of the values without modifying the original list.
Reduce Function
04:39:04 - 04:43:53
Reduce Function
- The reduce function combines a list into a single meaningful value. It takes a reducer function as a parameters. Each time the reducer function is called, it is passed an accumulator, which is an the interim value, along with the current value from the list.
Filter Function
04:43:54 - 04:46:54
Filter Function
- The filter function takes a list of items and decides which items should stay in the list and which items should be removed by returning either true or false each time it is called. The result is a new list containing only the items that returned true.
