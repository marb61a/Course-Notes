                    Modern Asynchronous Javascript
                    Course Notes


                    Section 1 - Callbacks
1 -Callback Nesting Nightmare
Introduction to the instructor and a brief welcome
  - The instructors aim is to help get past issues using Node & Javascript
Example Syntax
  // This is a snag that the course instructor ran into in a project
  // The project is an Express & Node app that uses MySQL to store data
    // This is an endpoint which can receive a form submission
    // The code is overly verbose for what it does
    app.post('/users', function(req, res) {
      connection.query('INSERT INTO users SET ?', req.body,
        // Callback function
        function(err, result){
          if(err) throw err;
          res.send('User has been added to the database with an ID of : ' + result.insertId);
        }
      )
    })

2 - What You Will Get out of This Course

3 - What You Need to Know 
There are some prerequisites for the course for students
  - 

4 - How to Use This Course 

5 - Callbacks 

6 - Double-edged Sword: Explicit Async Seams

7 - Con: Seams Rip Across Program

8 - Con: Another Error Mechanism

9 - Con: Hard to Reuse Error-handling Logic 

10 - Con: Difficult to Understand 

11 - Challenge: Synchronize Multiple Callbacks

12 - Solution 

13 - Parallelism: Wouldn't This Be Nice?

14 - One-shot Events 

15 - Takeaways



                    Section 2 - Lab Setup
1 - Cloning the Starting Point from GitHub 
A quick howto on cloning the course GitHub repo so that you can follow along with the course

2 - Operation Examples

3 - Running the Tests

4 - WebStorm Settings

5 - Auto Running Tests

6 - A Few Pointers About Using Mocha

7 - Callback Examples

8 - Debugging



                    Section 3 - Building a Promise Framework
1 - Why Build a Promise Framework?

2 - Challenge - Split Success and Error Callbacks

3 - Solution - Split Success and Error Callbacks

4 - Add an Operations Suite

5 - Using Done to Assert

6 - Challenge - Pass the Callback Later

7 - Solution - Pass the Callback Later

8 - Question - Why Might This Separation Be Helpful?

9 - Timing Safety without Coupling and Nesting 

10 - Challenge - Register Multiple Callbacks

11 - Solution 

12 - Splitting Registration of Success and Error Callbacks

13 - Convert getWeather to fetchWeather

14 - Extracting the Operation Type

15 - Operation Type Benefits 



                    Section 4 - Chaining Operations (Promises)
1 - Get Me a Cup of Coffee

2 - Challenge - Register a Callback Asynchronously

3 - Solution - Register a Callback Asynchronously

4 - Challenge - Parallelism

5 - Solution - Parallelism

6 - Challenge - Unnesting 

7 - Solution - Unnesting

8 - Forwarding Completion

9 - Waiting for the Completion of the Completion

10 - Operation Does the Forwarding

11 - Where Did the Nesting Go?

12 - And Then 

13 - Chaining Recap



                    Section 5 Cushioning Callbacks
1 - Shifting Perspective 

2 - Challenge - Error Recovery

3 - Solution - Error Recovery 

4 - Async Error Recovery and Challenge - Forwarding Success

5 - Forwarding Success and Challenge

6 - Solution - Forwarding Errors

7 - Reusing Error Handlers

8 - Synchronous Result Transformation

9 - Recover from Thrown Errors Too

10 - Recover from Error Errors

11 - Operations Should Only Complete One Time

12 - Block Multiple Failures

13 - Surrepticious Synchronicity

14 - Ensuring Asynchronicity 

15 - Summary of Protections 



                    Section 6 - ES6 Promises and Beyond
1 - Promises are Not New 

2 - Terminology

3 - Why Is it Called Resolve?

4 - Reworking Resolve

5 - Challenge - Fixing Resolve 

6 - Defining Resolved 

7 - Executor - the Revealing Module Pattern 

8 - Deferred Versus Thenable 

9 - Executor with Callbacks

10 - Static Resolve and Reject Functions

12 - Testing with Promises and ES6 Promise Backward Compatibility

13 - Why Third Party Promise Libraries Are Still Useful

14 - Finally

15 - Promisifying Existing Librarires You Love 

16 - Promise Collection Ops

17 - Unhandled Rejection

18 - Quizzary 



                    Section 7 - Building a Generator-based Control Flow Function
1 - Promises Aren't Perfect

2 - Iterators 7m 38s

3 - Generators

4 - Generators Are Suspendable and Resumable Functions

5 - When Resuming a Generator We Can Pass Errors 

6 - Calendars

7 - Debugging Generators 

8 - I Would Like to Yield Promises

9 - Yielding a Promise to My Assistant 

10 - Assisting with Infinite Promises 

11 - Four Async Ops in Four Lines of Code 

12 - Safety with Promise.resolve 

13 - Throwing Errors Back into the Generator 

14 - Catching Exceptions Throw from Generators 

15 - Catching Unhandled Errors in Our Assistant 

16 - Knowing When the Assistant Is Done

17 - Wow



                    Section 8 - ES2018 Async/Await and Other Generator Control Flow Libraries
1 - co and Bluebird's Promise.coroutine 

2 - Server Side Web Apps 

3 - Async and Await 

4 - Challenge - Parallel Requests with Async Await

5 - Parallel Solutions and Catching Async Function Errors 

6 - Awaiting Promise.all

7 - Challenge - Promises A+ and ES6 Spec Tests 

8 - The End - Value Proposition Revisited 
