                    Learn Ramda.js
                    Course Notes 


1 - Refactor to Point Free Functions with Ramda using compose and converge
Example Syntax
  // The lambda library must be included, code starting off example
  const R = require('ramda');
  
  const person = {
    id: 1,
    name: Joe
  }
  
  const generateUrl = (id) => "avatar-url";
  
  const getUpdatedPerson = (person) => {
    const url = generateUrl(person.id);
    return R.assoc('avatar', url, person);
  }
  
  const result = getUpdatedPerson(person);
  console.log(result);
  
  // Code at the end of example, this refactors the existing code
  const R = require('ramda');
  
  const person = {
    id: 1,
    name: Joe
  };
  
  const generateUrl = (id) => `https://img.socialnetwork.com/avatar/${id}.png`;
  
  // Using the built-in Compose property, the arguments are passed in right to left
  // The propOr property is so that default values can be defined
  const getUrlFromPerson = R.compose(generateUrl, R.propOr('default', 'id'));
  
  // This will take 2 arguments because all of these functions are automatically curried
  // The getUrlFromPerson array will be an array of transformation functions
  // The identity property from Ramda will essentially take in the person and just return it
  // This will then go into the getUrlFromPerson and is passed left until resolved
  const getUpdatedPerson = R.converge(R.assoc('avatar'), [getUrlFromPerson, R.identity]);
  
  const result = getUpdatedPerson(person);
  console.log(result);
  
  

2 - Eliminate Function Arguments (Point-Free Style) with Ramda's Converge
Example Syntax
  // Index.js, using standard JS syntax
  const shouldBeTrue = [6, 3, 4, 5, 2, 1];
  const shouldBeFalse = [3, 4, 5, 2, 1];
  
  // xs is an array passed in 
  const isFirstBiggest = xs => {
    // Comparator function and the biggest always goes to the front in the example
    xs[0] == xs.sort((a, b) => b-a)[0]
  } 
  
  console.log(isFirstBiggest(shouldBeTrue));
  console.log(isFirstBiggest(shouldBeFalse));
  
  // Index.js after using the Ramda functions
  const shouldBeTrue = [6, 3, 4, 5, 2, 1];
  const shouldBeFalse = [3, 4, 5, 2, 1];
  import {converge, equals, head, sort, descend, identity} from 'ramda';
  
  const isFirstBiggest = converge(equals, [
    head,
    // This can be swapped out and assigned to a variable eg const biggestItem = compose(head, (sort(descend(identity))))
    compose(head, (sort(descend(identity))))
  ])

  console.log(isFirstBiggest(shouldBeTrue));
  console.log(isFirstBiggest(shouldBeFalse));
  
  

3 - Convert a QueryString to an Object using Function Composition in Ramda
// Beginning Code
  // Requiring Ramda and using destructuring to get some of its functions
  const { identity, compose, fromPairs, map, split, tail } = require('ramda');
  
  const queryString = '?page=2&pageSize=10&total=203';
  
  const parseQs = identity;
  
  const result = parseQs(queryString);
  console.log(result);
  
// Ending Code
  const { identity, compose, fromPairs, map, split, tail } = require('ramda');
  
  const queryString = '?page=2&pageSize=10&total=203';
  
  // The process will again go from left to right
  // Tail is used to eliminate the question mark at the start of the string
  // This leaves only key-value pairs which are then split at the ampersand
  // what is left at this point is an array of key-value pair strings, these
  // are then mapped over and split at the equals sign which will give an array of
  // arrays the inner arrays which will each have a key and a value string, the Ramda fromPairs 
  // will take in the 2 value arrays and return them in property value format in an object
  // it will look like {page: '2', pageSize: '10', total: '203'}
  const parseQs = compose(fromPairs, map(split('=')), split('&'), tail);
  
  const result = parseQs(queryString);
  console.log(result);
  
  

4 - Select a Subset of Properties from a Collection of Objects in Ramda
// Beginning Code
  // Requiring Ramda
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Hoodie', price: 60, category: 'clothes'},
    {name: 'Jacket', price: 120, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Sauce Pan', price: 100, category: 'housewares'},
  ];
  
  const result = products;
  console.log(result);

// Ending Code
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Hoodie', price: 60, category: 'clothes'},
    {name: 'Jacket', price: 120, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Sauce Pan', price: 100, category: 'housewares'},
  ];
  
  // Picking a subset of an array can be donse several different ways
  // Many use the array.map function and then use each property, this
  // may not be suitable when selecting a large number of properties
  // Ramda itself has serveral options such as its own map function which
  // can be used in conjunction with Pick to select properties to pick
  // from an array. This is such a common operation however that instead
  // of doing the 2 operations seperately it can be done at once using the
  // built-in project function
  const getNameAndPrice = R.project(['name', 'price']);
  
  const result = getNameAndPrice(products);
  console.log(result);
  
  

5 - Handle Branching Logic with Ramda's Conditional Functions
// Beginning Code
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Freaknomics', price: 30, category: 'books'}
  ];
  
  const pLens = R.lensProp('price');
  
  const applyDiscount = R.curry((perc, amt) => amt - (amt * (perc/100)));
  
  const adjustPrice = R.over(pLens, applyDiscount(50));
  
  const result = R.map(adjustPrice, products);
  console.log(result);

// Ending Code
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Freaknomics', price: 30, category: 'books'}
  ];
  
  const pLens = R.lensProp('price');
  
  const applyDiscount = R.curry((perc, amt) => amt - (amt * (perc/100)));
  
  // This will have the Ramda ifElse function applied
  // The ifElse function takes 3 arguments, the first argument is a
  // predicate function, the second argument is the function to be run
  // on the object if the predicate evaluates to true, the third is if
  // the predicate evaluates to false.
        const adjustPrice = R.ifElse(
          R.propEq('category', 'clothes'),
          R.over(pLens, applyDiscount(50)),
          R.identity
        )
   
  // Another way of running the above is to use the Ramda when function, this runs when a condition is
  // matched, this has a counterpart which does the opposite, the unless function
        const adjustPrice = R.when(
          R.propEq('category', 'clothes'),
          R.over(pLens, applyDiscount(50)),
        );
      
      
  // It maybe the case where you want different properties to have different actions, eg you will want
  // different discounts to different items. This will then use the cond function, this function takes
  // arrays of arrays as its first argument, each inner array conatains a predicate function and a function
  // incase the predicate evaluates to true, this will return undefined for values not handled. In order to
  // eliminate these the Ramda T function is used, this will essentially do nothing but return true, identtity
  // will then return the remaining items untouched, the R.cond function is not limited to a couple of different
  // conditions, many different conditions can be used
  const adjustPrice = R.cond(
    [
      [
        R.propEq('category', 'clothes'), R.over(pLens, applyDiscount(50))],
        R.propEq('category', 'electronics'), R.over(pLens, applyDiscount(10))],
        [R.T, R.identity]
    ]
  );
  
  const result = R.map(adjustPrice, products);
  console.log(result);



6 - Declaratively Map Predicates to Object Properties Using Ramda where
// Beginning Code
  const R = require('ramda');

  const products = [
    {name: 'Jeans', price: 80, category: 'clothes', stock: 100},
    {name: 'Hoodie', price: 60, category: 'clothes', stock: 20},
    {name: 'Sneakers', price: 120, category: 'clothes', stock: 30}
    {name: 'Cards', price: 35, category: 'games', stock: 10},
    {name: 'iPhone', price: 649, category: 'electronics', stock: 5},
    {name: 'Sauce Pan', price: 100, category: 'housewares', stock: 200},
  ];
  
  const predicate = R.T;
  
  const getResults = R.pipe(R.filter(predicate), R.pluck('name'));
  
  const result = getResults(products);
  console.log(result);

// Ending Code
  const R = require('ramda');

  const products = [
    {name: 'Jeans', price: 80, category: 'clothes', stock: 100},
    {name: 'Hoodie', price: 60, category: 'clothes', stock: 20},
    {name: 'Sneakers', price: 120, category: 'clothes', stock: 30}
    {name: 'Cards', price: 35, category: 'games', stock: 10},
    {name: 'iPhone', price: 649, category: 'electronics', stock: 5},
    {name: 'Sauce Pan', price: 100, category: 'housewares', stock: 200},
  ];
  
  // R.where takes an object as its first argument, this maps keys from the target object
  // to predicate functions that will check that property individually
  const predicate = R.where({
    category: R.equals('clothes'),
    
    // Arguments are passed in to lt (less-than) in different order than normal
    // The R.__ is a placeholder
    stock: R.lt(R.__, 50)
  });
  
  const getResults = R.pipe(R.filter(predicate), R.pluck('name'));
  
  const result = getResults(products);
  console.log(result);



7 - Change Object Properties with Ramda Lenses
// Beginning Code
  const R = require('ramda');
  
  const person = {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }

// Ending Code
  const R = require('ramda');
  
  const person = {
    firstName: 'Fred',
    lastName: 'Flintstone'
  }
  
  // To create a lense in Ramda pass 2 functions to lens(), the first function will be a getter function
  // the second function will then be a setter
  const fLens = R.lens(R.prop('firstName'), R.assoc('firstName'));
  
  // The view function will take the fLens const and the person object to be used on
        const result = R.view(fLens, person);
  
  // R.set will take the fLens const as the first argument, the second argument will be the value that the
  // function wishes to set
  const result = R.set(fLens, 'Wilma', person);
  
  console.log(result);

8 - Add and Remove Items in Arrays using Filter, Reject and Partition in Ramda

9 - Build a Functional Pipeline with Ramda.js

10 - Pick and Omit Properties from Objects Using Ramda

11 - Curry and Uncurry Functions with Ramda

12 - Declaratively Map Data Transformations to Object Properties Using Ramda evolve

13 - Count Words in a String with Ramda's countBy and invert

14 - Handle Errors in Ramda Pipelines with tryCatch

15 - Create an Array From a Seed Value with Ramda's unfold

16 - Convert a Promise.all Result to an Object with Ramda's zip and zipObj

17 - Filter an Array Based on Multiple Predicates with Ramda's allPass Function

18 - Create a Query String from an Object using Ramda's toPairs function

19 - Convert Object Methods into Composable Functions with Ramda

20 - Sort an Array of Objects by Multiple Fields with Ramda's sortWith

21 - Refactor a Promise Chain to Function Composition using Ramda

22 - Refactor to a Point Free Function with Ramda's useWith Function

23 - Get a List of Unique Values From Nested Arrays with Ramda


24 - Debug Function Compositions with Ramda's Tap Function
