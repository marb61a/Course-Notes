                    Learn Ramda.js
                    Course Notes 


1 - Refactor to Point Free Functions with Ramda using compose and converge
Example Syntax
  // The lambda library must be included, code starting off example
  const R = require('ramda');
  
  const person = {
    id: 1,
    name: Joe
  }
  
  const generateUrl = (id) => "avatar-url";
  
  const getUpdatedPerson = (person) => {
    const url = generateUrl(person.id);
    return R.assoc('avatar', url, person);
  }
  
  const result = getUpdatedPerson(person);
  console.log(result);
  
  // Code at the end of example, this refactors the existing code
  const R = require('ramda');
  
  const person = {
    id: 1,
    name: Joe
  };
  
  const generateUrl = (id) => `https://img.socialnetwork.com/avatar/${id}.png`;
  
  // Using the built-in Compose property, the arguments are passed in right to left
  // The propOr property is so that default values can be defined
  const getUrlFromPerson = R.compose(generateUrl, R.propOr('default', 'id'));
  
  // This will take 2 arguments because all of these functions are automatically curried
  // The getUrlFromPerson array will be an array of transformation functions
  // The identity property from Ramda will essentially take in the person and just return it
  // This will then go into the getUrlFromPerson and is passed left until resolved
  const getUpdatedPerson = R.converge(R.assoc('avatar'), [getUrlFromPerson, R.identity]);
  
  const result = getUpdatedPerson(person);
  console.log(result);
  
  

2 - Eliminate Function Arguments (Point-Free Style) with Ramda's Converge
Example Syntax
  // Index.js, using standard JS syntax
  const shouldBeTrue = [6, 3, 4, 5, 2, 1];
  const shouldBeFalse = [3, 4, 5, 2, 1];
  
  // xs is an array passed in 
  const isFirstBiggest = xs => {
    // Comparator function and the biggest always goes to the front in the example
    xs[0] == xs.sort((a, b) => b-a)[0]
  } 
  
  console.log(isFirstBiggest(shouldBeTrue));
  console.log(isFirstBiggest(shouldBeFalse));
  
  // Index.js after using the Ramda functions
  const shouldBeTrue = [6, 3, 4, 5, 2, 1];
  const shouldBeFalse = [3, 4, 5, 2, 1];
  import {converge, equals, head, sort, descend, identity} from 'ramda';
  
  const isFirstBiggest = converge(equals, [
    head,
    // This can be swapped out and assigned to a variable eg const biggestItem = compose(head, (sort(descend(identity))))
    compose(head, (sort(descend(identity))))
  ])

  console.log(isFirstBiggest(shouldBeTrue));
  console.log(isFirstBiggest(shouldBeFalse));
  
  

3 - Convert a QueryString to an Object using Function Composition in Ramda
// Beginning Code
  // Requiring Ramda and using destructuring to get some of its functions
  const { identity, compose, fromPairs, map, split, tail } = require('ramda');
  
  const queryString = '?page=2&pageSize=10&total=203';
  
  const parseQs = identity;
  
  const result = parseQs(queryString);
  console.log(result);
  
// Ending Code
  const { identity, compose, fromPairs, map, split, tail } = require('ramda');
  
  const queryString = '?page=2&pageSize=10&total=203';
  
  // The process will again go from left to right
  // Tail is used to eliminate the question mark at the start of the string
  // This leaves only key-value pairs which are then split at the ampersand
  // what is left at this point is an array of key-value pair strings, these
  // are then mapped over and split at the equals sign which will give an array of
  // arrays the inner arrays which will each have a key and a value string, the Ramda fromPairs 
  // will take in the 2 value arrays and return them in property value format in an object
  // it will look like {page: '2', pageSize: '10', total: '203'}
  const parseQs = compose(fromPairs, map(split('=')), split('&'), tail);
  
  const result = parseQs(queryString);
  console.log(result);
  
  

4 - Select a Subset of Properties from a Collection of Objects in Ramda
// Beginning Code
  // Requiring Ramda
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Hoodie', price: 60, category: 'clothes'},
    {name: 'Jacket', price: 120, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Sauce Pan', price: 100, category: 'housewares'},
  ];
  
  const result = products;
  console.log(result);

// Ending Code
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Hoodie', price: 60, category: 'clothes'},
    {name: 'Jacket', price: 120, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Sauce Pan', price: 100, category: 'housewares'},
  ];
  
  // Picking a subset of an array can be donse several different ways
  // Many use the array.map function and then use each property, this
  // may not be suitable when selecting a large number of properties
  // Ramda itself has serveral options such as its own map function which
  // can be used in conjunction with Pick to select properties to pick
  // from an array. This is such a common operation however that instead
  // of doing the 2 operations seperately it can be done at once using the
  // built-in project function
  const getNameAndPrice = R.project(['name', 'price']);
  
  const result = getNameAndPrice(products);
  console.log(result);
  
  

5 - Handle Branching Logic with Ramda's Conditional Functions
// Beginning Code
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Freaknomics', price: 30, category: 'books'}
  ];
  
  const pLens = R.lensProp('price');
  
  const applyDiscount = R.curry((perc, amt) => amt - (amt * (perc/100)));
  
  const adjustPrice = R.over(pLens, applyDiscount(50));
  
  const result = R.map(adjustPrice, products);
  console.log(result);

// Ending Code
  const R = require('ramda');
  
  const products = [
    {name: 'Jeans', price: 80, category: 'clothes'},
    {name: 'Cards', price: 35, category: 'games'},
    {name: 'iPhone', price: 649, category: 'electronics'},
    {name: 'Freaknomics', price: 30, category: 'books'}
  ];
  
  const pLens = R.lensProp('price');
  
  const applyDiscount = R.curry((perc, amt) => amt - (amt * (perc/100)));
  
  // This will have the Ramda ifElse function applied
  // 
  const adjustPrice =
  
  const result = R.map(adjustPrice, products);
  console.log(result);


6 - Declaratively Map Predicates to Object Properties Using Ramda where

7 - Change Object Properties with Ramda Lenses

8 - Add and Remove Items in Arrays using Filter, Reject and Partition in Ramda

9 - Build a Functional Pipeline with Ramda.js

10 - Pick and Omit Properties from Objects Using Ramda

11 - Curry and Uncurry Functions with Ramda

12 - Declaratively Map Data Transformations to Object Properties Using Ramda evolve

13 - Count Words in a String with Ramda's countBy and invert

14 - Handle Errors in Ramda Pipelines with tryCatch

15 - Create an Array From a Seed Value with Ramda's unfold

16 - Convert a Promise.all Result to an Object with Ramda's zip and zipObj

17 - Filter an Array Based on Multiple Predicates with Ramda's allPass Function

18 - Create a Query String from an Object using Ramda's toPairs function

19 - Convert Object Methods into Composable Functions with Ramda

20 - Sort an Array of Objects by Multiple Fields with Ramda's sortWith

21 - Refactor a Promise Chain to Function Composition using Ramda

22 - Refactor to a Point Free Function with Ramda's useWith Function

23 - Get a List of Unique Values From Nested Arrays with Ramda

24 - Debug Function Compositions with Ramda's Tap Function
