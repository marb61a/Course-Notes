                    JavaScript: The Hard Parts
                    Course Notes


                    Section 1 - Introduction
1 - Introduction
Introduction to the course and the author
There are 5 capabilities that the instructors teaching company looks for in students
  - Analytical problem solving with code
  - Technical Communication (can a solution be implemented just from an explanation)
  - Engineering best practices such as Debugging, Use of documentation
  - Empathic and thoughtful commmunication (non-technical)
  - Language and Computer science experience
  - The top 2 are the most important
    - The course is aimed at developing these 5 factors



                    Section 2 - Principles of JavaScript
1 - Global Execution Context
In the course there is a set of principles
  - This will allow for both problem solving and communicating any scenario in JS
  - Start at the essentials to get up to a shared level of understanding
  - This will help when more difficult times arise
Example Syntax
  // What happens when JavaScript runs the code
  // When is was just an interpreted language it processed line by line
  // JavaScript now uses Just In Time (JIT) compilation in Chrome runtime
  const num = 3;
  
  // This function is never called and thus cannot be initialised
  // Thread execution will ever enter a function if it is not called
  function multiplyBy2 (inputNumber){
    const result = inputNumber*2;
    return result;
  }
  
  const name = "Martin"
 
As soon as code starts running it creates a global execution context which has
  - Thread of execution is the parsing and running of code line after line
  - Live memory of variables with data know as the Global Variable Environment

The thread in JavaScript
  - Single threaded (one item at a time)
  - Synchronous Execution (for the moment)

2 - Local Execution Context
Running / calling / invoking a function
  - This is not the same as defining a function
When you execute a function you create a new execution context comprising
  - The thread of execution from the line by line execution of function code
  - A local memory location where anything defined in the function is stored
Example Syntax
  const num = 3;
  
  function multiplyBy2(inputNumber) {
    const result = inputNumber * 2;
    return result;
  }
  
  const output = multiplyBy2(4);
  const newOutput = multiplyBy2(10);
  
3 - Call Stack
We keep track of the functions being called in JavaScript with a Call stack
  - This is a special data structure
  - It uses LIFO (Last In First Out)
  - It tracks which execution context we are in
  - Tnere is one global execution context but multiple function contexts

4 - Q&A: Global Memory and Call Stack

5 - Principles Review



                    Section 3 - Functional Programming
1 - Pure Functions

2 - High Order Functions



                    Section 4 - Callbacks and Higher Order Functions
1 - Setting Up Pair Programming

2 - Introducing Pair Programming

3 - Callbacks and Higher-Order Functions Exercises

4 - Paramaterizing Functions

5 - Q&A: Const and Let

6 - Generalizing Functions

7 - Reviewing Generalizing Function

8 - Deconstructing Generalize Function

9 - Q&A: Passing Functions

10 - First-Class Objects

11 - Callback vs Higher-order Functions



                    Section 5 - Closure
1 - Introducing Closure

2 - Deconstructing Example

3 - Q&A and Pair Programming

4 - Closure Exercise, Part 1

5 - Closure Exercise, Part 2

6 - Closure Exercise, Part 3

7 - Q&A: Lexical Scope

8 - Q&A: Garbage Collection

9 - Closure Exercise, Part 4

10 - Q&A: Shared References

11 - Power of Closure



                    Section 6 - Asynchronous JavaScript
Part 2 of the course covers Asynchronous JavaScript
  - https://github.com/marb61a/Course-Notes/blob/master/Language Specific/Javascript/JavaScript: The New Hard Parts

1 - Introducing Asynchronous JavaScript

2 - Browser API

3 - Browser API Q&A

4 - Resetting Pair Programming

5 - Browser API Q&A, Part 2

6 - Callback Queue

7 - Callback Queue & Event Loop

8 - Asynchronous Q&A and Pair Programming
04:22:23 - 04:25:36
Asynchronous Q&A and Pair Programming
Will takes questions from students before setting them off on pair programming challenges.
Introducing More Browser APIs
04:25:37 - 04:32:42
Introducing More Browser APIs
After reviewing additional browser APIs that do not stop JavaScript from executing such as Ajax, user interactions, reading and writing to a file system or database, Will takes questions from students.
XMLHttpRequest
04:32:43 - 04:50:41
XMLHttpRequest
Will walks through an asynchronous code example featuring Web browser API XMLHttpRequest.
XMLHttpRequest Q&A
04:50:42 - 04:55:19
XMLHttpRequest Q&A
In taking questions from students, Will leads into a demonstration "callback hell" and how promises alleviate that problem.
XMLHttpRequest Correction



                    Section 7 - Object-Oriented JavaScript
1 - Introducing Object-Oriented JavaScript

2 - OOP Exercise, Part 1

3 - OOP Exercise, Part 2

4 - OOP Exercise, Part 3
05:14:11 - 05:24:45
OOP Exercise, Part 3
To modularize OOP code example using DRY methods, Will walks through a function to generate objects.
OOP Exercise Q&A and Pair Programming
05:24:46 - 05:30:32
OOP Exercise Q&A and Pair Programming
After working through generating OOP code example, Will works with students to determine potential problems. Then Will initiates another round of pair programming challenges. - csbin.io/oop
__proto__
05:30:33 - 05:34:33
__proto__
Will introduces the concept of __proto__, which allows for the creation of objects with shared functionality.
OOP Exercise, Part 4
05:34:34 - 05:53:36
OOP Exercise, Part 4
Will demonstrates the prototype chain bond between objects.
__proto__ Q&A and Pair Programming, Part 2
05:53:37 - 06:02:32
__proto__ Q&A and Pair Programming, Part 2
After taking questions from students about prototypical nature in objects, Will starts another round of pair programming challenges.
new operator
06:02:33 - 06:12:57
new operator
Will introduces the new operator, which creates an instance of a user-defined object type.
new operator Q&A
06:12:58 - 06:18:30
new operator Q&A
Will takes questions from students to clarify and explore more about new operator.
Object.prototype
06:18:31 - 06:22:31
Object.prototype
To automate and standardize OOP, Will introduces coding with the Object.prototype.
OOP Exercise, Part 5
06:22:32 - 06:44:16
OOP Exercise, Part 5
Will walks through streamlining OOP code example by implementing Object.prototype property, shared methods separately from the object constructor.
Object.prototype Q&A
06:44:17 - 06:46:57
Object.prototype Q&A
Will takes a question from a student about the difference between __proto and prototype.
Class Syntactic Sugar
06:46:58 - 06:51:36
Class Syntactic Sugar
Will shows writing OOP with JavaScript classes that were introduced in ECMAScript 2015. These new classes provide "Syntactic Sugar," providing a much more straightforward and more explicit syntax to create objects and deal with inheritance.
OOP Exercise, Part 6
06:51:37 - 06:57:31
OOP Exercise, Part 6
With help from the students, Will demonstrates OOP approach using syntactic sugar approach and discusses the benefits.
Class Syntactic Sugar Q&A
06:57:32 - 07:00:13
Class Syntactic Sugar Q&A
After taking questions from students, Will starts another round of pair programming.


                    Section 8 - Wrapping Up
1 - Wrapping Up "JavaScript: The Hard Parts"

