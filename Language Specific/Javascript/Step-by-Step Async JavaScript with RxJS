                    Step-by-Step Async JavaScript with RxJS
                    Course Notes
                    
                    
1 - Starting a Stream with SwitchMap
Example Syntax
  // Index.html
    <button id="start">
      Start
    </button>
  
  // app.ts
    import {Observable} from 'rxjs/Rx';
    const startButton = document.querySelector('#start');

    // Will generate mouse events
    Observable.fromEvent(startButton, 'click')
      .subscribe((event) => console.log(event));
    
    // Setting up a timer
    Observable.interval(1000)
      .subscribe((x) => console.log(x));
Although the temptation to cut the timer function and paste it into the click event handler in order to combine
the functionality do not do this, do not nest multiple subscription blocks inside each other
  - You will not be able to reuse the stream , what comes out of a subscribe is a subscription not an observable
  - In the example when the button is clicked there should be a switch over to an interval observable
Example Syntax
      // The correct way of combining the two above examples
      Observable.fromEvent(startButton, 'click')
        .switchMap(() => Observable.interval(1000))
        // Using this will allow where the start button is clicked to determine the speed of the interval
        // Far left on the button is fast and far right is slow
        // .switchMap(() => Observable.interval(1000))
        .subscribe((x) => console.log(x));

      // There other way of doing the above example which works in the same way 
      import {Observable} from 'rxjs/Rx';
      const startButton = document.querySelector('#start');
      
      const start$ = Observable.fromEvent(startButton, 'click');
      const interval$ = Observable.interval(1000));
      const startInterval$ = start$
                          // You can also use switchMapTo which uses the Observable rather than a function which returns
                          // an Observable
                                .switchMap((event) => interval$);
      
      startInterval$
        .subscribe((x) => console.log(x));
      
2 - Stopping a Stream with TakeUntil
Example Syntax
  // index.html file
    <button id="stop">
      Stop
    </button>
  
  // app.ts
    import {Observable} from 'rxjs/Rx';
    
    const startButton = document.querySelector('#start');
    const stopButton = document.querySelector('#stop');
    
    const start$ = Observable.fromEvent(startButton, 'click');
    const interval$ = Observable.interval(1000));
    
    const startInterval$ = start$
                                .switchMapTo(interval$)
                                .subscribe((x) => console.log(x));
   
    const subscription = interval$
          .subscribe((x) => console.log(x));
    
    Observable,fromEvent(stopButton, 'click')
          .subscribe(() => {
            // Stops the timer when the button is clicked
            subscription.unsubscribe();
          })

3 - Updating Data with Scan
To be able to have a stream that stops, starts and continues when needed
The proper way to gather data in Rxjs is to use the scan operator
  - This is instead of using something like a counter
Example Syntax
  import {Observable} from 'rxjs/Rx';
    
  const startButton = document.querySelector('#start');
  const stopButton = document.querySelector('#stop');

  const start$ = Observable.fromEvent(startButton, 'click');
  const interval$ = Observable.interval(1000));
  const stop$ = Observable.fromEvent(stopButton, 'click');
  
  const intervalThatStops$ = interval$
    .takeUntil(stop$);
  
  start$
    .switchMapTo(intervalThatStops$)
    // Scan workis similar to reduce and takes 2 parameters
    // If there was more than 1 property then you would probably use object.assign
    .scan((acc) => {
      return { count: acc.count + 1 }
    }, {count: 0})
    .subscribe((x) => console.log(x));

4 - Displaying Initial Data with StartWith
Using the example from the previous section, you will have to click start in oder to see anything in the console,
you may wish to see the 0, this can be done with the startWith operator
Example Syntax
  import {Observable} from 'rxjs/Rx';

  const startButton = document.querySelector('#start');
  const stopButton = document.querySelector('#stop');

  const start$ = Observable.fromEvent(startButton, 'click');
  const interval$ = Observable.interval(1000));
  const stop$ = Observable.fromEvent(stopButton, 'click');

  const intervalThatStops$ = interval$
    .takeUntil(stop$);
  
  const data = {count: 0};
  
  start$
    .switchMapTo(intervalThatStops$)
    .startWith(data)
    .scan((acc) => {
      return { count: acc.count + 1 }
    })
    .subscribe((x) => console.log(x));

5 - Changing Behavior with MapTo
Continuing again to use the previous example, the behaviour at this stage is to add 1 to the value each time
  - This can be changed to accomodate different behaviours
Example Syntax
  import {Observable} from 'rxjs/Rx';

  const startButton = document.querySelector('#start');
  const stopButton = document.querySelector('#stop');

  const start$ = Observable.fromEvent(startButton, 'click');
  const interval$ = Observable.interval(1000));
  const stop$ = Observable.fromEvent(stopButton, 'click');

  const intervalThatStops$ = interval$
    .takeUntil(stop$);
  
  const data = {count: 0};
  // One line functions in ES6 that return objects need to be wrapped in parentheses or the curly brackets 
  // will be treated as a block
  const inc = (acc) =>  ({ count: acc.count + 1 });
  const reset = (acc) => data;
  
  start$
    .switchMapTo(intervalThatStops$)
    // This will allow different behaviour as inc is a function so a function will need to be passed to scan
    .mapTo(inc)
    .startWith(data)
    .scan((acc, curr) => curr(acc))
    .subscribe((x) => console.log(x));

6 - Handling Multiple Streams with Merge
Handling reset behaviour
Example Syntax
  // index.html file
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8">
      <script src="jspm_packages/system.js"></script>
      <script src="jspm.browser.js"></script>
      <script src="jspm.config.js"></script>
      <title></title>
    </head>
    <body>
      <button id="start"> Start </button>
      <button id="stop"> Stop </button>
      <button id="reset"> Reset </button>
      
      <script>
        SystemJS.import('app.ts');
      </script>
    </body>
  </html>
  
  // App.ts file
  import {Observable} from 'rxjs/Rx';

  const startButton = document.querySelector('#start');
  const stopButton = document.querySelector('#stop');
  const resetButton = document.querySelector('#reset');

  const start$ = Observable.fromEvent(startButton, 'click');
  const interval$ = Observable.interval(1000));
  const stop$ = Observable.fromEvent(stopButton, 'click');
  const reset$ = Observable.fromEvent(resetButton, 'click');
  
  const intervalThatStops$ = interval$
    .takeUntil(stop$);
  
  const data = {count: 0};
  const inc = (acc) =>  ({ count: acc.count + 1 });
  const reset = (acc) => data;
  
  start$
    .switchMapTo(intervalThatStops$)
    .mapTo(inc)
    .startWith(data)
    .scan((acc, curr) => curr(acc))
    .subscribe((x) => console.log(x));

7 - Refactoring Composable Streams in RxJS
Example Syntax
  // Again a continuance from the previous example
  // App.ts file
  import {Observable} from 'rxjs/Rx';

  const startButton = document.querySelector('#start');
  const halfButton = document.querySelector('#half');
  const quarterButton = document.querySelector('#quarter');
  
  const stopButton = document.querySelector('#stop');
  const resetButton = document.querySelector('#reset');

  const start$ = Observable.fromEvent(startButton, 'click');
  const half$ = Observable.fromEvent(startButton, 'click');
  const quarter$ = Observable.fromEvent(quarterButton, 'click');
  
  const interval$ = Observable.interval(1000));
  const stop$ = Observable.fromEvent(stopButton, 'click');
  const reset$ = Observable.fromEvent(resetButton, 'click');
  
  const data = {count: 0};
  const inc = (acc) =>  ({ count: acc.count + 1 });
  const reset = (acc) => data;
  
  const intervalThatStops$ = interval$
    .takeUntil(stop$);
  
  const incOrReset$ = Observable.merge(
    intervalThatStops$.mapTo(inc),
    reset$,mapTo(reset)
  );
  
  // To be able to use either the half or quarter or start buttons
  // The values then map to milliseconds
  Observable.merge(start$.mapTo(1000), half$.mapTo(500), quarter$.mapTo(250))
    .switchMap((time) => incOrReset$)
    .mapTo(inc)
    .startWith(data)
    .scan((acc, curr) => curr(acc))
    .subscribe((x) => console.log(x));

  // index.html file
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8">
      <script src="jspm_packages/system.js"></script>
      <script src="jspm.browser.js"></script>
      <script src="jspm.config.js"></script>
      <title></title>
    </head>
    <body>
      <button id="start"> Start </button>
      <button id="Half"> Half </button>
      <button id="Quarter"> Quarter </button>
      
      <button id="stop"> Stop </button>
      <button id="reset"> Reset </button>
      
      <script>
        SystemJS.import('app.ts');
      </script>
    </body>
  </html>

8 - Getting Input Text with Map


9 - Combining Streams with CombineLatest


10 - Adding Conditional Logic with Filter


11 - Completing a Stream with TakeWhile


12 - Handling a Complete Stream with Reduce


13 - Logging a Stream with Do


14 - Timer and Input Recap


15 - Refactoring CombineLatest to WithLatestFrom


16 - Resubscribing to a Stream with Repeat


17 - Basic DOM Rendering with Subscribe


18 - Sharing Streams with Share

