                    Lambdas And Streams In Java 8
                    Course Notes


                    Chapter 1 : Introduction
1 - What You Should Expect From This Course
Java 8 has some big changes which will affect the ecosystem immensely
The course is good for people refreshing Java skills as well as people new to Java 8
The course is dedicated to Lambdas and Streams exclusively
There are some pre-requisites for the course
  - Knowledge of Java is needed as there will be no onboarding of students new to Java
  - The JDK v8 will need to be installed
  - The Eclipse IDE will also be used during the course
    - Netbeans or IntelliJ is also suitable

2 - About The Author
A brief introduction to the course author



                    Chapter 2 : Basics
1 - Why Java 8?
Looking at the need for Java 8
There are 3 main forces driving change in the Java landscape
  - Advances in processing power
    - Mulitcore CPU's, Big Data etc
  - Passing as data
    - Prior to Java 8 this was done by anonymous classes, callbacks etc 
  - Enhancing the language libraries
    - Some libraries in Java need a makeover
 The outcome of the above are Lambdas and Streams

2 - Brief Introduction To Java 8 New Features

3 - What Are Lambdas?
  - Java is an Obeject Oriented Programming language meaning everything in Java is an object
    - Variables etc can not exist on their own
  - Classes are the foundation for building objects
  - All methods are tied to a class which must be instantiated so they can be used appropriately
  - 

4 - Creating A Lambda

5 - Example Lambda Expressions
Example Syntax
  // Example lambdas 
  public class Runnables{
    public void methodAcceptingRunnable(){}
    public void methodAcceptingCallable(){} 
  
    public static void main(String[] args){
      Runnable runnable  = () -> System.out.println("Hello Lambda");
      
      new Runnables().methodAcceptingRunnable(runnable);
      
      new Runnables().methodAcceptingRunnable(() -> {
        System.out.println("Complex Lambda");
        persist();
        email();
      })
    }
  } 



                    Chapter 3 : Lambdas
1 - Lambda Syntax
The syntax may appear intimidating at first
  - Getting the fundamentals and practicing will make things much easier
Although Lambdas have their own special syntax it is similar to method syntax
  - They have input arguments, a body and a return
  - The left hand side is inputs
  - The right hand side is logic
  - An arrow token is the separator
Return values can be either implicit or explicit
Example Syntax
  // Some Lambda syntax examples
  i -> i*i;
  (String s1, String s2) -> s1+s2;
  (List<Trade> trades, PriceSkewer s) -> { //Logic goes here };
  (Booking b, Customer c) -> { //Logic goes here }

  // Some more practical examples
  // These are variations on a theme
  (String name) -> System.out.println("Hello, " + name);
  (name) -> System.out.println("Hello, " + name);
  name -> System.out.println("Hello, " + name);
  
  Runnable runnable = () -> autoPilot();
  (Trade t, PricingSkewAlgo algo){
    // logic goes here
    persistingTrade(t);
    return t;
  }

2 - Target Typing

3 - Capturing Lambda

4 - Lambda Scoping

5 - Method References

6 - Constructor References

7 - Type Inference



                    Chapter 4: Interfaces
1 - Interface Makeover

2 - Functional Interfaces

3 - @FunctionalInterface Annotation

4 - Default And Static Methods

5 - Inheriting Behaviour

6 - Multiple Inheritance

7 - Abstract Versus Interfaces



                    Chapter 5 : Functions
1 - What Are Functions?

2 - Predicate Function

3 - Composing Predicates

4 - Consumer Function

5 - Supplier Function

6 - Function Function



                    Chapter 6 : Additional Functions
1 - Composing Functions

2 - Primitive Functions - Part 1

3 - Primitive Functions - Part 2

4 - Two Argument BiPredicates

5 - Two Argument BiConsumers

6 - Two Argument BiFunctions



                    Chapter 7 : Streams
1 - Introducing Streams - Part 1

2 - Introducing Streams - Part 2

3 - Working With Streams

4 - Creating Streams

5 - Iteration Strategies

6 - Lazy And Eager Operations

7 - Streams Versus Collections

8 - Primitive Streams



                    Chapter 8 : Stream Common Operations
1 - Filtering

2 - Mapping

3 - Collecting

4 - Distinct, Limit And Skip

5 - Short Circuit Operations

6 - Reducing

7 - Optional - Part 1

8 - Optional - Part 2



                    Chapter 9 : Advanced Streams
1 - Grouping

2 - Partitioning

3 - Collectors

4 - Flat Map

5 - Range And Stats



                    Chapter 10 : Parallel Streams
1 - Serial Execution

2 - Parallel Execution

3 - Behind The Scenes

4 - Sequential Or Parallel



                    Chapter 11 : Conclusion
1 - Wrap Up
A brief run through of what the course has covered and a final word from the course author

