                    Async Techniques and Examples in Python
                    Course Notes


1 - Course introduction
Very quick introduction to the both the course and the instructor

2 - Async for taking full advantage of modern CPUs
CPU's tend to have mulyiple cores
  - This was due to heat and power problems
  - Single threaded performance has flatlined over the last decade
    - In places performance has fallen
    - This is because using the extra cores has not occured
    - Async programming will allow for taking advantage of modern hardware

3 - Topics covered
A brief run through of what the course will cover
  - There will be a very thorough examination of async coding

4 - Student prerequisites
There are some prerequisites
  - Students should know Python
  - This course is intermediate to advanced level

5 - Meet your instructor
A brief introduction to the course instructor

6 - Video player: A quick feature tour
A run through of the online video player used in the course
  - This is the player from the course site

7 - Do you have Python 3? 
The course will need the student to have Python 3.5+ installed on the computer

8 - Getting Python 3
Installing Python differs from platform to platform
Checking Python 3 version on Ubuntu can be done
      - Python3 -V
    - Updating existing Python 3 can be done with
      - sudo apt-get upgrade python3

9 - Recommended text editor 
The course uses the PyCharm editor
  - https://www.jetbrains.com/pycharm/
  - This is not compulsory and other editors can be used eg Visual Studio Code, Vim etc

10 - Hardware requirements
Unlike other courses this course needs to be on a multicore computer
  - The minimum suggested is 2
  - The more cores the better the illustration of benefits

11 - Get the source code
The code from the course is on GitHub
  - https://github.com/talkpython/async-techniques-python-course

12 - Async for computational speed 
A brief high level view of Async and the landscape to get started

13 - Demo: Why you need async for speed
A demonstration of poor use of a multi-core system
  - The course instructor is using a 12 core mac but the effect will be similar on other multi-core systems
    - 6 real and 6 hyperthreaded
  - In the example only 9.5% of the CPU capacity
    - This is because it is only single threaded
  - The course uses Glances which is used in Python
    - https://nicolargo.github.io/glances/
  - Process Explorer is also recommended
    - https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer
  
14 - An upper bound for async speed improvement
There are limits to speed improvement using Async techniques
  - 12 cores does not always means 12 times faster
  - https://en.wikipedia.org/wiki/Embarrassingly_parallel
  - It will depend on which parts of an app can be done concurrently
    - This needs to be worth the added complexity eg 20% improvement may not be worth the extra complexity

15 - Async for scalability
People often mistake scalability for performance
  - It refers to how many requests an app can handle for example rather than how fast a single request can be handled

16 - Concept: Visualizing a synchronous request 
Visualising scalability around Synchronous requests
  - Many web servers have threaded modes for Python
  - It does help to some degree but could help more
3 requests
  request1    ----- > response1
  // This is worse because we are not scaling
  request2    ---- > response2
  // Although much smaller this came in at nearly the same time as request because of not scaling
  request3    --- >
  
  request1 can be broken down into different operations
  framework // eg sockets etc that can not be changed
    ----- > db
    ---- > Our Code
    --------------------- > db    // This is where problems lie as other code could be doing stuff but instead just waits
    ---- > Our Code
  framework

17 - Concept: Visualizing an asynchronous request
Reusing the previous example
  - In this case thought they can be ran concurrently
  - Being able to make requests while not wait for completion of others will make things much quicker
  - There is no such thing as perfect concurrency
  - All operations have some sort of overhead

18 - Python's async landscape
There are some different techniques for Async in Python
  - Do more at once
    - Asyncio
      - https://docs.python.org/3/library/asyncio.html
    - Threads
      - Can be difficult to coordinate but are a great option
      - In some languages they will also be in th do things faster section
  - Doing things faster
    - Multiprocessing
      - Breaking things up in to bits and letting each core do it 
    - C/Cython
      - C can be tricky to write
      - https://cython.org
  - Do these easier
    - trio
    - unsync

19 - Why threads don't perform in Python
Threads do not perform that well in Python because
  - Python has a memory management feature called the GIL or Global Interpreter Lock
  - It is often referred to as the problem with Python being scalable or ultra quick
  - This means that only one step at a time no matter what thread
  - This helps single threaded Python be faster but affects parallel processing
  - It is primarily a thread safety feature

20 - Python async landscape: asyncio 
The journey into Python concurrent processing begins with an example
  - This will be with no threads or sub-processes
  - The asyncio way is highly favoured by the instructor and isgood for scalability
  - It can be thought of as co-operative concurrency

21 - I/O-driven concurrency
Working with asyncio versus other concurrency can be a bit of a mind shift
  - The concurrent programming model here is the easiest of all
    - Typically 
  - I/O driven concurrency 

22 - Demo: Understanding basic generators
Example Syntax
  // Generator functions
  // simple_gen.py
  // Generators do not have much to do with Async in general but the notion of restartable
  // functions is critical to the way that asyncio works
  from typing import List
  
  // Generating Fibonacci number sequence
  // Non generating function version
  def fib(n: int) -> List[int]:
    numbers = []
    current, end = 0, 1
    while len(numbers) < n:
      current, nxt = nxt, current + nxt
      numbers.append(current)
    
    return numbers
  
  print(fib(10))
   
  // The above version has problems not least that Fibonacci is infinite and will keep going
  // There maybe a need to interrupt the sequence hence using Generators
  // They are restartable functions, using them you could build a form of parallelism
  def fib():
    current, nxt = 0, 1
    while True:
      current, nxt = nxt, current + nxt
      yield
  
  result = fib()
  
  for n in result:
    print(n, end=', ')
    if n > 10000:
      break
  
  print("Done")

23 - Demo: The producer-consumer app
Example Syntax
  // Demonstrating the producer-consumer pattern
  // This uses the synchronous approach 
  // async_program.py example file
  import datetime
  import colorama
  import random
  import time
  
  def main():
    t0 = datetime.datetime.now():
    print(colorama.Fore.WHITE + "App Started.", flush=True)
    data =[]
    generate_data(20, data)
    process_data(20, data)
    
    dt = datetime.datetime.now() - t0
    print()
  
  def generate_data(num: int, data: list):
    for idx in range(1, num + 1):
      item = idx*idx
      data.append((item, datetime.datetime.now()))
      
      print(colorama.Fore.YELLOW + f"", flush=True)
      time.sleep(random.random() + .5)
  
  def process_data(num: int, data: list):
    processed = 0
    while processed < num:
      item = data.pop(0):
        if not item:
          time.sleep(.01)
          continue

24 - Demo: Make the producer-consumer async
This will convert the example from the previous demo to use an async approach
  - This will be relatively simple from a syntax view but is complex conceptually
Example Syntax
  import asyncio
  import datetime
  import colorama
  import random
  import time
  
  def main():
    loop = asyncio.get_event_loop()
  
    t0 = datetime.datetime.now():
    print(colorama.Fore.WHITE + "App Started.", flush=True)
    
    // This is similar to a standard queue
    data = asyncio.Queue()
    
    generate_data(20, data)
    process_data(20, data)
  

25 - Demo: Make the producer-consumer async (methods)
Adapting the methods generate_data and process_data from the previous example 
Example Syntax
  def generate_data(num: int, data: asyncio.Queue):
    for idx in range(1, num + 1):
      item = idx*idx
      data.append((item, datetime.datetime.now()))
      
      print(colorama.Fore.YELLOW + f"", flush=True)
      time.sleep(random.random() + .5)
  
  def process_data(num: int, data: asyncio.Queue):
    processed = 0
    while processed < num:
      item = data.get():
        processed += 1
        value = item[0]
        t = item[1]
        dt = datetime.datetime.now() - t
      
        if not item:
          time.sleep(.01)
          continue

26 - Concept: asyncio

27 - Performance improvements of producer consumer with asyncio 

28 - Faster asyncio loops with uvloop 

29 - Let's do some real work 

30 - Synchronous web scraping

31 - async web scraping

32 - Concept: async web scraping

33 - Other async-enabled libraries

34 - Python async landscape: Threads 

35 - Visual of thread execution 

36 - How to choose between asyncio and threads

37 - Demo: hello threads

38 - Demo: Waiting on more than one thread 

39 - Demo: Something productive with threads

40 - Concept: Thread API

41 - Concept: Tips for multiple threads

42 - Cancelling threads with user input

43 - Concept: Timeouts

44 - Demo: Attempting to leverage multiple cores with threads

45 - Python async landscape: Thread Safety landscape

46 - Threads are dangerous

47 - Visualizing the need for thread safety

48 - Demo: An unsafe bank

49 - Demo: Make the bank safe (global)

50 - Demo: A missed lock in our bank (global)

51 - Demo: Make the bank safe (fine-grained)

52 - Demo: Breaking a deadlock

53 - Concept: Basic thread safety

54 - Python async landscape: multiprocessing

55 - Introduction to scaling CPU-bound operations 

56 - Demo: Scaling CPU-bound operations with multiprocessing

57 - Concept: Scaling CPU-bound operations

58 - Multiprocessing return values

59 - Concept: Return values

60 - Python async landscape: Execution pools

61 - Demo: Executor app introduction 

62 - Demo: Executor app (threaded-edition)

63 - Demo: Executor app (process-edition)

64 - Concept: Execution pools

65 - Python async landscape: asyncio derivatives

66 - Why do we need more libraries?

67 - Introducing unsync

68 - Demo: unsync app introduction

69 - Demo: unsync app for mixed-mode parallelism

70 - Concept: Mixed-mode parallelism with unsync

71 - Introducing Trio

72 - Demo: Starter code for Trio app

73 - Demo: Converting from asyncio to Trio

74 - Demo: Cancellation with Trio

75 - Concept: Trio nurseries

76 - The trio-async package

77 - Python async landscape: Async web

78 - Review: Request latency again

79 - Demo: Introducing our Flask API

80 - There is no async support for Flask

81 - Demo: Introducing Quart for async Flask

82 - Demo: Converting from Flask to Quart

83 - Demo: Making our API async

84 - Demo: An async weather endpoint

85 - Concept: Flask to Quart 

86 - Load testing web apps with wrk

87 - A note about rate limiting with external services

88 - Performance results

89 - Remember to run on an ASGI server

90 - Python async landscape: Cython

91 - C and Python are friends

92 - Why Cython

93 - Cython syntax compared

94 - Demo: Hello Cython

95 - Concept: Getting started with Cython

96 - Demo: Fast threading with cython (app review)

97 - Demo: Fast threading with Cython (hotspot)

98 - Demo: Fast threading with Cython (conversion)

99 - Demo: Fast threading with Cython (GIL-less)

100 - Demo: Fast threading with Cython (int overflow issues)

101 - Concept: Cython's nogil

102 - The finish line

103 - Review: Why async?
A review of this specific section

104 - Review: asyncio
A review of this specific section

105 - Review: Threads 
A review of this specific section

106 - Review: Thread safety
A review of this specific section

107 - Review: multiprocessing
A review of this specific section

108 - Review: Execution pools
A review of this specific section

109 - Review: Mixed-mode parallelism
A review of this specific section

110 - Review: Coordination with Trio
A review of this specific section

111 - Review: Async Flask
A review of this specific section

112 - Review: Cython
A review of this specific section

113 - Thanks and goodbye
End of the course and a brief thanks from the instructor
