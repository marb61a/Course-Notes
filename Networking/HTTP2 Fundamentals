                    HTTP2 Fundamentals - Course Notes
                    
                    
                    Section 1 - Introduction
1 - Introduction
Introduction to the syllabus and to the author
Overview of the history of web pages
Nielsons law of bandwith
  - This states that there will be a 50% increase in bandwidth each year
  - This is somewhat similar to Moores Law which states that technology will double every 18 months
Approximately 3 billion people use the internet

2 - Why the need for HTTP2
Stuart Cheshire in 1996 in a paper said latency was going to be the biggest issue facing the internet users in the future
Page Size
  - Parges larger in size
  - Much of the material is not primary content
Latency is limited by the speed of light
  - It could be 80 - 200 ms
Latency is money
  - Increasing bandwidth means page load times drop proportionately but at a point the impact is greately reduced
Latency greatly affects user behaviour
Some rich media web pages can have 400 requests

3 - TCP The underlying Problem
Everything runs on the transport layer of the OSI model
  - Mostly using TCP
More Notes on TCP &  related is available at
  - https://github.com/marb61a/Course-Notes/tree/master/Networking
Headers were not introduced to HTTP1.0
In HTTP1.1 There was a connection field introduced to the header
  - This defaulted to keep-alive
The reliability of TCP instead of UDP because of its connection oriented approach has many good features but this
reliability also can cause problems
Head Of Line Blocking
  - This is where a line of packets is held up because the first packet has either been lost or dropped and is preventing 
  further processing of packets
  - This is a big issue when using HTTP piplining which will be covered later in the course
The waterfall pattern is from under performing websites where the page loading statistics look like a waterfall
Another issue of TCP is flow control which deals with congestion problems, basically it adjusts transfer rate based
on network reactions.
TCP SLow Start
  - This is where a connection is started with a small transfer rate called a window size and is increased until maximum 
  capacity is then found, if affects every TCP connection

4 - HTTP2
HTTP2 is a binary protocol which itself makes things easier as it is easier to pass binary instead of text
HTTP2 uses the same semantics as HTTP1.x
HTTP2 addresses the shortcomings of TCP
SPDY was a protocol developed by Google to address performance issues 
SPDY constitutes the foundation of HTTP2 and it has replaced SPDY
Development work on SPDY has been discontinued
Chrome has dropped support for SPDY
HTTPBis Working Group is the main group charged with working on HTTP2
HTTP2 RFC Number is 7540
`- There is a corresponding RFC 7541 (HPACK) which covers header compression
HTTP2 is supported by most browsers & server software

5 - Demo HTTP2 In Action
A quick demonstration of using HTTP2 using akamamai
  - https://http2.akamai.com
  - https://http2.akamai.com/demo
The deomstration is inspired by the golang gophertiles demonstration
  - http://http2.golang.org/gophertiles

6 - Summary
Quick summary of the material covered in the section


                    Section 2 - An HTTP2 Connection
1 - Establishing An HTTP2 Connection
In HTTP1.x the client makes a request to the server
  - It does this using plain text
  - This sends a verb, a resource url and some header information
The server in turn responds with the corresponding resource or error code
Each request and response is self contained
In HTTP2 things change a bit
  - The exchange is no longer in plain text but in binary
  - The binary messages contain the same information
HTTP2 is not compatible with HTTP1.x
  - It does however need to work on the existing infrastructure of the web
HTTP2 needs to work on top of HTTP1.x, there are 2 options for doing this
  - Plain Text
    - Client issues a request with the header upgrade h2c
    - If the server supports HTTP2 it sends back a 101(Switching Protocols) response
  - TLS
    - The predominant methodology as it is used with ssl
    - There had to be an extension called Application-Layer Protocol Negotiation (ALPN) added
      - ALPN allows protocol negotiationto take place during the handshake

2 - Frames And Messages
Frames constitute the basic protocol unit in HTTP2
They are used for communicating data whether its header or a response body
There are 10 different types of frames in the HTTP2 protocol, each having a different function
Each frame will contain a series of header fields which will be 72 bytes in size in total
The header will be followed by the payload which will vary depending of the frame type
Some important fields are
  - Type -- This indicates the type of frame being used
  - Flags -- These are associated with Type and indicate specific characteristics for that frame
  - ID -- This indicates the stream that the frame is associated with
  - Payload -- This is the actual content, which will vary depending on type

HTTP2 Messages
These are used because HTTP2 needs to keep the semantics of HTTP1.X
A message consists of a series of frames
A HTTP2 Request Message consists of a series of Header frames and Data frames
  - The response message is similar in structure
The data frame is by far the most important frame as it carries the payload of the request and response bodies
Padding in used in the data frame to mitigate against attacks

Headers Frame
The headers frame corresponds to headers sent in a request and response
There can be many headers and they can be distributed over multiple frames
A series of flags such as endheaders and endstream are used to indicate if the headers frame is the last
or followed by a series of continuation frames which contain additional header information
There is a single headers frame and one or more continuation frames
A few fields E, Stream Dependency and Weight are related to stream priorities

Every HTTP2 connection has a series of settings that apply through out the exchanges
These settings are defined with the settings frame and are sent when establishing a connection
The parameters include
  - SETTINGS_HEADER_TABLE_SIZE
  - SETTINGS_ENABLE_PUSH
  - SETTINGS_MAX_CONCURRENT_STREAMS
  - SETTINGS_INITIAL_WINDOW_SIZE
  - SETTINGS_MAX_FRAME_SIZE
  - SETTINGS_MAX_HEADER_LIST_SIZE

3 - Headers
Headers in HTTP2 are similar to headers in HTTP1.X
They are key-value pairs with a possibility of multiple values per key
Field names are still strings and are case insensitive
  - It is required to have all in lowercase before encoding  
HTTP2 has Pseudo-Header fields which are specific fields which provide information on 
  - Scheme -- :scheme is the scheme of the URI
  - URL
  - Method -- This indicates the verb use eg GET
  - Response Status -- :status is used in the response and is the status code
  - Authority -- :authority indicates authority information about the URI
  - Path -- :path indicates the actual path of the URI
These fiels are pre-fixed with a colon
The Pseudo Header fields must also appear prior to other header fields in a request and response
HTTP2 takes header treatment a step further than HTTP1.X
HTTP1.X is very wasteful as it retransmits information that had not changed
HTTP2 seeks to address this waste by using compression
  - This compression is known as HPack
    - This is used to compress headers
    - This compression uses Huffman encoding along with 2 tables
      - Static and Dynamic which maintain a list of headers
      - The Dynamic table is initially empty and its maximum size is set by the settings frame
      - The Static table has a list of known and frequently used headers
      - The combination of the tables form the Index Address Space
  - Initiallly Zlib was used for the compression
    - This was removed due to the CRIME attack 
      - More information is available at -- https://en.wikipedia.org/wiki/CRIME
Instead of sending either header names and values HPack uses indexes to look up the corresppnding name-values
This means the with a HTTP2 there is state being maintained for these headers

4 - Basic Tooling
Author recommends tools for using during the course
  - curl
    - This uses nghttp2 behind the scenes
  - Wireshark
    - Protocol Analyser
    - Industry standard
    - Wireshark supports SSL decryption
      - You need to export the sslkeylog file to a specific file and configure Wireshark to use this file
  - Chrome Browser
    - The network tab in the developers tools shows the protocol being used
    - Chrome also provides the ability to see the live HTTP2 session
      - In the url bar type chrome://net-internals/#http2
      - You can then select a session

5 - Demo An HTTP 2 Connection
Demonstration of the tools listed above
The nghhtp2.org site is the site being used in the example
  - curl -vs -o /dev/null --http2 http://nghttp2.org
  - Initial connection will be using HTTP1.x
  - At that point then the connection is upgraded to using HTTP2
The easiest way to ensure Wireshark uses the keylogfile and the browser exports to it is to set an environmental variable
  // This command may differ on each platform
  // You may need to create the file
  - export SSLKEYLOGFILE =#/tools/ssl/sslkeylog.log
To ensure that environment variable is applied in the righ context launch the browser and wireshark from the same terminal
To avoid going through all traffic apply the http2 filter in Wireshark

6 - Summary
Brief summary of the material covered in the chapter



                    Section 3 - Streams
1 - A Recap On HTTP 1.1 v HTTP2
A quick recap of the differences netween the two versions of the HTTP protocol

2 - Multiplexing And Streams

3 - Demo An HTTP2 Stream Exchange

4 - Stream Priorities

5 - Demo Priorities In Action

6 - Flow Control

7 - Summary
Brief summary of the material covered in the chapter


                    
                    Section 4 - Server Push
1 - Introduction

2 - Server Push

3 - Demo Server Push In Action

4 - Summary
Brief summary of the material covered in the chapter


                   
                    Section 5 - Security, Proxies And More
1 - TLS, SSL And HTTP2

2 - TLS Overhead

3 - Caches And Proxies

4 - Other Important HTTP2 Frames

5 - Summary
Brief summary of the material covered in the chapter


                    
                    Section 6 - Working with HTTP2 Libraries And Servers
1 - Browser Support

2 - Hosting HTTP2 Applications

3 - Working With Client-Side Libraries

4 - Demo High Level Client Requests

5 - Demo Low Level Client Requests

6 - Demo Low Level Server Handling

7 - Demo Programmatic Server Push

8 - Summary
Brief summary of the material covered in the chapter


                    
                    Section 7 - Adapting Existing Applications
1 - Years of Optimisations

2 - Multiple TCP Connections

3 - Concatenation Of Files

4 - Spiriting Of Images

5 - Minifying

6 - Resource Inlining

7 - Content Delivery Netwoks

8 - Supporting Both Protocols

9 - Impact on HTTP And REST API's

10 - Moving To HTTP2

11 - Summary
Brief summary of the material covered in the chapter
