                    The Complete Developers Guide to MongoDB
                    Course Notes


                    Section 1 - Let's Start
1 - How to Use This Course
A quick guide to get the best learning experience from the course

2 - Github Repo Link
A link to the GitHub repo used by the course



                    Section 2 – OSX Setup
1 - MongoDB Setup on OSX
Installing MongoDB on OSX

2 - More OSX Setup - Robomongo
Installing the Robomongo GUI tool (Now known as 3t)
  - https://robomongo.org



                    Section 3 – Windows Setup
1 - Windows Setup
Installing MongoDB on Windows

2 - RoboMongo Setup
Installing the Robomongo GUI tool (Now known as 3t)
  - https://robomongo.org
  


                    Section 4 – A Quick ES6 Refresher
There are a full set of notes on ES6 available at
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/ES6/ES6 The Complete Developer's Guide
1 - A Refresher on Promises
2 - Let's Play A Game
3 - Winning the Game
4 - Behind the Scenes with Promises



                    Section 5 – Core Fundamentals of MongoDB
1 - Where Do We Use Mongo?
Mongo is traditionally separated from the internet by a webserver
  - It is not dependent on Node.js
  - There are about a dozen languages that have clients for Mongo
Mongoose is an ORM/ODM for Mongo 
  - http://mongoosejs.com
  - ORM -- Object Relational Mapper, ODM -- Object Data Mapper
  - These just allow for better use with the DB
  - Mongoose is the industry standard for interacting with the MongoDB database

2 - Fundamentals of MongoDB
You normally have a web server between apps and the MongoDB
Mongo allows for multiple internal databases inside a single Mongo instance
  - This allows for working with multiple projects without dumping a database
  - There will rarely be more than 1 database within a project
  - A collection is the core unit of what stores data in a MongoDB database
  - There is normally a collection for each resource that will be available within an application

3 - A Last Touch of Setup
The core concepts of Mongo & Mongoose are
  - Create, Read, Update & Destroy (CRUD)
  - The first project of the course will be based around these
Example Syntax
  // This project will not have a frontend
  - mkdir users
  - cd users



                    Section 6 – A Test Driven Experience
1 - Project Overview
To setup npm in the project
  - npm init
  - This will create a package.json file to hold dependencies
  - This is normally one of the first steps taken when building a project from scratch
  - There are 3 packages being installed Mocha, Nodemon & Mongoose
    - npm install --save moncha nodemon mongoose
    - Ensure that the spelling is correct
The goal of the course is to ensure that the student becomes adept at the 4 core features of MongoDB
  - Create, Read, Update, Destroy (CRUD)
  - To ensure that the student learns properly there will be a small app built with no frontend
  - There will be a MongoDB created with a users colection, wire to the Mongoose library
  - Then the Mocha testing library will be used to ensure that users are being inserted into the database  
  - The Mocha and Mongoose priciples will be able to be applied to production projects
The project structure will be 
  - /src/user.js
  - /test/ -> create_test.js, read_test.js, update_test.js, destroy_test.js

2 - The Test Helper File
Mocha is by far the most popular testing framework around the node environment
  - Previous experience is not necessary
Example Syntax
  // test/test_help.js file
  // A helper file usually holds code needed to setup the testing environment
  const mongoose = require('mongoose');
  
  mogoose.connect('mongodb://localhost/users_test');
  mongoose.connection
    .once('open', () => console.log('Good to go!!'))
    .on('error', (error) => {
      console.warn('Warning', error);
    })

3 - Mongoose Connection Helper
A discussion of the code from the previous section
  - Requiring in the mongoose library to the const mongoose makes it available
    - Require is used because Node does not use ES6 modules and the require is part of the common js way of handling modules
  - The localhost url is because Mongo has to be told exactly where a db is located
    - An instance of Mongo can have multple databases
    - You do not have to create databases ahead of time

4 - Mongoose Models

5 - More on Models

6 - The Basics of Mocha

7 - Running Mocha Tests

8 - Creating Model Instances

9 - Saving Users to Mongo

10 - Dropping Collections

11 - Mocha's Done Callback

12 - Mongoose's isNew Property

13 - Default Promise Implementation

14 - Test Setup for Finding Users

15 - Making Mongo Queries

16 - The ID Property - A Big Gotcha

17 - Automating Tests with Nodemon

18 - Finding Particular Records

19 - The Many Ways to Remove Records

20 - Class Based Removes

21 - More Class Based Removals

22 - The Many Ways to Update Records

23 - Set and Save for Updating Records

24 - Model Instance Updates

25 - Class Based Updates



                    Section 7 – Mongo Operators
1 - Update Operators

2 - The Increment Update Operator

3 - Validation of Records

4 - Requiring Attributes on a Model

5 - Validation With a Validator Function

6 - Handling Failed Inserts



                    Section 8 – Handling Relational Data
1 - Embedding Resources in Models

2 - Nesting Posts on Users

3 - Testing Subdocuments

4 - Adding Subdocuments to Existing Records

5 - Removing Subdocuments

6 - Virtual Types

7 - Defining a Virtual Type

8 - ES6 Getters

9 - Fixing Update Tests



                    Section 9 – Thinking About Schema Design
1 - Challenges of Nested Resources

2 - Embedded Documents vs Separate Collections

3 - BlogPosts vs Posts

4 - Creating Associations with Refs

5 - Test Setup for Associations

6 - Wiring Up Has Many and Has One Relations

7 - Promise.All for Parallel Operations

8 - Populating Queries

9 - Loading Deeply Nested Associations



                    Section 10 – Mongoose Middleware
1 - Cleaning Up with Middleware

2 - Dealing with Cyclic Requires

3 - Pre-Remove Middleware

4 - Testing Pre-Remove Middleware



                    Section 11 - Handling Big Collections with Pagination
1 - Skip and Limit

2 - Writing Skip and Limit Queries

3 - Sorting Collections



                    Section 12 - Putting Your Skills to the Test
1 - Project Setup

2 - Project Overview

3 - First Step - Artist and Album Models

4 - The Album Schema

5 - The Artist Model

6 - Finding Particular Records

7 - FindOne vs FindById

8 - The CreateArtist Operation

9 - Solution to Creating Artists

10 - Deleting Singular Records

11 - Solution to Removing

12 - Editing Records

13 - How to Edit Single Artists



                    Section 13 - Hard Mode Engage
1 - Minimum and Maximum Values in a Collection

2 - Solution to Min and Max Queries

3 - Challenge Mode - Search Query

4 - Sorting, Limiting, and Skipping Together

5 - Danger! Big Challenge Ahead

6 - Filtering By Single Properties

7 - Filtering with Multiple Props

8 - Handling Text Search

9 - Indexes and Text Search

10 - Batch Updates

11 - The Hidden 'Multi' Setting

12 - Seeding Many Records

13 - Counting the Result Set



                    Section 14 - MongoDB with Node and Express
1 - App Overview
The app being built is an API
  - It is frontend agnostic so could be used with Angular, React etc, IOS etc
  - The backend will be built using Node & Express on top of a MongoDB database
  - It will be similar to the Uber app

2 - Designing API Routes

3 - Project Setup

4 - HTTP Request Methods

5 - The Basics of Express

6 - Express Boilerplate

7 - Handling Requests with Express

8 - Testing Express Apps with Mocha

9 - Running Mocha

10 - Project Structure

11 - Refactoring for Controllers and Models

12 - The Driver Model

13 - The Create Drivers Route

14 - The BodyParser Middleware

15 - Testing Driver Creation

16 - More on Testing Driver Creation

17 - Additional Mongoose Setup

18 - Driver Implementation

19 - Testing Endpoints with Postman

20 - Dev vs Test Environments

21 - Separate Test Databases

22 - Middlewares in Express

23 - Handling Editing of Drivers

24 - Testing Driver Updates

25 - Handling Deletion of Drivers

26 - Testing Driver Deletion

27 - Geography with MongoDB

28 - The GeoJSON Schema

29 - GeoNear Queries

30 - Testing a GeoNear Query

31 - One Big Gotcha

32 - Another Big Gotcha

33 - Testing GeoQueries

