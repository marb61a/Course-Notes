                    HTML5 Web Component Fundamentals
                    Course Notes
                    
                    
                    Section 1 - Five Problems One Solution
1 - Intro
Intro to the course and the instructor
Web Developers have problems, the section will cover those problems

2 - Problem 1 Undescriptive Markup
Most markup is not descriptive, it is unfortunately highly generic
  - Div-soup is a problem, multi-layer divs
  - Generic divs convey no meaning

3 - Problem 2 Style Conflicts
Styling conflict are hard to avoid
  - Avoiding conflicts may necessitate the use of highly specified CSS selectors
  - Sometimes it is necessary to use the !important directive to force using of styles
  - There is no guarantee of conflict avoidance and stylesheet bloat happens

4 - Problem 3 No Native Templates
Template solutions can be clunky
  - There is no native way to import inert HTML to use in templates
  - JS can be imported with a script tag, css with a style tag etc but what if we want to import HTML on the page
  - There have been a lot of workarounds/hacks to try resolving issues
  - One solution is to add a type of HTML to a script tag
    - This is not a great solution as it opens the site up to XSS attacks
  - Another solution is to store HTML in hidden DOM elements and manually extract
    - This can create issues like pollution of styles 
  - Sometimes IFrames are used to get separate scopes and styling

5 - Problem 4 No Bundling

6 - Problem 5 No Standard

7 - The Solution Web Components

8 - Browser Support

9 - Why Learn Web Components First
JQuery used to be learned before Javascript
  - This is bad as there will be a need to understand the foundation technology
  - JQuery is only an abstraction so should be learned after JS
Web Components too are a foundation technology
  - Polymer is a technology built on the Web Components specification

10 - Selecting A Level Of Abstraction
Any level of abstraction makes sense when creating a Web Component
  - Low Level right up to an entire app
  - A quick demo of how an exiting site could be decomposed into components

11 - The Dawn Of The Democratic Web
In the opinion of the course instructor web components will change the web
  - Moving control from members of standards bodies to developers
  - Web developers can get around the bottle neck of waiting for standards using components
  - Things like GitHub stars will drive the measure of interest
  - Popular components will drive future HTML elements

12 - Summary Why Web Components
A quick summary of the material covered in the chapter



                    Section 2 - Templates
1 - Intro
A brief introduction to what is ahead in the section

2 - Common Approaches
There are 2 non-standard approaches for templates that are used
Example Syntax
  // Html in script tags with a type of text
  // This is what is used by the handlebars templating library
  // This is also the approach used by the HTML5 widget library KendoUI
  <script type="text/custom-name-here">
    - This approach is popular for several reasons
      - Nothing inside the tags runs or renders and it is fairly simple
    - There are issues however
      - The content is not parsed as HTML
      - This means that it is not part of the browser DOM 
      - It is basically storing the template as a string
      - This leads to using innerHtml for copying the template
      - This can lead to Cross Site Scripting Vulnerabilities (XSS) which allows attackers to run their JS on your page
 
 // The second approach is to use Hidden DOM elements
 <div style="display:none;" id="my-template"></div>
  - The advantage this has over the first approach is that it is safe and easy to clone
  - This has a problem though as everything inside runs and can cause issues like 404 errors

The solution to the issues with the above is the HTML5 template tag
  - You can safe declare markup that is not to be manipulated or rendered

3 - Template Characteristics
There are 3 important things that need to be understood about the template tag
  - All markup in the tag is inert, no script runs etc, it does nothing. It stays inert until cloned and used on the page
  - The content of the tag is hidden from selectors, you can't use JS to select child nodes in a template 
    - The content is not traversed like other DOM elements
  - The template tag can be placed just about anywhere on the page, be consistent in the project though

4 - Defining And Cloning
Template activation is a simple 3 step process similar to cloning any other HTML element
Example Syntax
  // Steps for activating template tags
  // The first step in the process is getting a reference to the template, querySelector is used but 
  // getElementByTag or getElementByID could be used
  var template = document.querySelector('#mytemplate');
  
  // The next step is to creata a clone of the templates content using importNode
  // The true is present to determine whether to do a deep copy, setting to true ensures all contents are copied
  var clone = document.importNode(template.content, true);
  
  // The third and final step is to add the content to the page
  document.body.apendChild(clone);
  
  // The instructor is using Plunker for code demonstrations, 
  // index.html in the instructor Plunker
  <!DOCTYPE html>
  <html>
    <head>
    
    </head>
    <body>
      <template>
        <p>I am coming from a template</p>
      </template>
    </body>
    
    <script>
      var template = document.querySelector('template');
      var clone = document.importNode(template.content, true);
      document.body.apendChild(clone);
    </script>
    
  </html>

5 - Injecting Dynamic Data

6 - Nested Templates

7 - Summary
A brief run through of what the section covered



                    Section 3 - Custom Elements
1 - Intro
A brief introduction to what is ahead in the section

2 - Core Functionality
Custom Elements provide 2 new core functionalities
  - Define your own HTML elements, the name must have a dash
    - <billing-app> <my-form> etc
  - They can extend existing HTML elements using the is keyword
    - <input type="text"> becomes <input type="text" is="search">

3 - Registering Custom Elements
Registering and utilising a Custom Element is a simple 3 step process
  - Firstly you must create a prototype for the custom element
    - EG var slickTabs = Object.create(HTMLElement.prototype);
    - The above needs to be modified for existing HTML elements eg HTMLButtonElement
    - Most IDE will have a list of HTML elements so there is no need to try and remember
  - The 2nd step is to register the element
    - document.registerElement('slick-tabs');
  - The 3rd and final step is to use it for example add it to the DOM
    - document.body.appendChild(new SlickTabs());
Custom Elements can also be extended too
Example Syntax
  var XFooProto = Oject.create(HTMLElement.prototype);
  
  var XFooExtended = document.RegisterElement('x-foo-extended', {
    prototype: XFooProto,
    extends: 'x-foo'
  })

4 - Instantiating Custom Components 

5 - Instantiating Extended Custom Components

6 - Lifecycle Callback Methods

7 - Naming Approaches

8 - Summary
A brief run through of what the section covered



                    Section 4 - ShadowDOM Fundamentals
1 - Intro
A brief introduction to what is ahead in the section

2 - Light DOM vs ShadowDOM
DOM - Document Object Model
LightDOM - The DOM that you already know
ShadowDOM - The DOM that hides away complexity
LogicalDOM - This is an umberella combining the two DOM types

3 - You Already Use ShadowDOM
The ShadowDOM is not a new concept, it has been around for quite a while
Example Syntax
  // The elements already use the ShadowDOM to hide complexity and markup away
  <input type="range">
  <video controls width="250"></video>
  <input type="date" />

  // Some native HTML elements that use the ShadowDOM
  // Using the gear icon in chrome dev tools will allow you to see the ShadowDom
  // It will have #shadow-root, there maybe be trees of nested ShadowDOM
  <!DOCTYPE>
  <html>
    <head>
    
    </head>
    <body>
      <video controls ></video>
      <input type="date" />
    </body>
  </html>

4 - ShadowDOM Alternatives
The ShadowDOM encapsulates DOM Subtrees and styles
Iframes can be used to get ShadowDOM like behaviour without having support for the ShadowDOM

5 - Demo: Creating ShadowDOM
Creating a ShadowDOM is a simple 3 step process
  - The first is to select a shadow host
    - A shadow host is an element in the lightDOM that will wrap the shadow root
    - The video tag previously show is an example of a shadow host
  - The 2nd step is to create a shadow root
  - The 3rd and final step is to add elements to the ShadowDOM 
Example Syntax
  // Creating a ShadowDOM
  <!DOCTYPE html>
  <html>
    <head></head>
    <body> 
    
    </body>
  </html>

6 - Shadow Host And Shadow Boundary

7 - Demo: ShadowDOM Terminology 

8 - Demo: Shadow RootDOM Methods 

9 - Javascript Is Not Encapsulated

10 - Demo: Javascript Is Not Encapsulated

11 - Summary
A  brief summary of the material that the chapter has covered




                    Section 5 - ShadowDOM Insertion Points & Events
1 - Intro
A brief introduction to what is ahead in the section

2 - Content Insertion Points

3 - Insertion Points vs Distributed Nodes

4 - Content Selectors

5 - Shadow Insertion Points

6 - Listing Distributed Nodes And Destination Insertion Points

7 - Event Retargeting

8 - Events That Stop

9 - Summary
A  brief summary of the material that the chapter has covered



                    Section 6 - ShadowDOM Styling
1 - Intro
A brief introduction to what is ahead in the section

2 - Host Pseudo Selector

3 - Host Theming

4 - Host Specificity

5 - Host States

6 - Host-Context Pseudo Selector

7 - Styling Distributed Node With The Content Pseudo Elements

8 - Shadow Pseudo Element

9 - Deep Combinator

10 - Unresolved Pseudo Selector

11 - Dynamic Styling

12 - Summary
A  brief summary of the material that the chapter has covered




                    Section 7 - Imports
1 - The Bundling Problem

2 - Import Overview

3 - Demo: Imports

4 - Other Uses For Imports

5 - Referencing The Owner Document

6 - Demo: Referencing The Owner Document

7 - When Does Content In Imports Apply

8 - Demo: When Does Content In Imports Apply

9 - Handling Load And Error Events

10 - Demo: Handling Load And Error Events

11 - Handling Duplicate Requests And Resource Conflicts

12 - Sub Imports

13 - Demo: Sub Imports

14 - Summary
A  brief summary of the material that the chapter has covered



                    Section 8 - Native Alternatives
1 - Want Cross Browser Components Today 

2 - Browser Requirements

3 - Feature Matrix For Non-Standard Framework

4 - Problem Solved By Non-Standard Framework



                    Section 9 - Resources
1 - Resources
Some resources recommeneded by the course author
  - https://www.webcomponents.org
  - Many of the resource in the course have now changed or gone
