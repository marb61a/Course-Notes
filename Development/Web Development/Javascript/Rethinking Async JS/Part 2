                    Rethinking Asynchronous Javascript
                    Course Notes Part 2


3 - Exercise 1 Solution
There are many solutions possible but this is the official solution
Ordering callbacks will require sequential requesting
Paralell requesting will cause concurrency co-ordination complexity
The main point point of the exercise was to show how 3 callbacks would shared a closured state to co-ordinate
Solution Syntax
  function getFile(file){
    fakeAjax(file, function(text){
      fileReceived(file, text);
    });
  }

  function fileReceived(file,text) {
  // haven't received this text yet?
  if (!responses[file]) {
    responses[file] = text;
  }
  var files = ["file1","file2","file3"];
  // loop through responses in order for rendering
  for (var i=0; i<files.length; i++) {
    // response received?
    if (files[i] in responses) {
      // response needs to be rendered?
      if (responses[files[i]] !== true) {
        output(responses[files[i]]);
        responses[files[i]] = true;
      }
    }
    // can't render yet
    else {
      // not complete!
      return false;
    }
  }
  output("Complete!");
  }	

// hold responses in whatever order they come back
var responses = {};

4 - Callback Problems Inversion of Control
Inversion of Control
  - Loads of different definitions available
  - Here it means that there are portions of the code I am incharge of executing and parts I am not
  - This takes the code that executes now and the code executed in a callback and gives someone else control which is the 
  inversion
  - This is said to be one of two major problems with callbacks
  - Example Syntax
  trackCheckout(
    purchaseInfo,
    function finish(){
      chargeCreditCard(purchaseInfo);
      showThankYouPage();
    }
  )
  The example above trusts that it will not be called too many times or too few, below is a fix based on a boolean
  - Example Syntax
  var hasBeenCalled = false;
  trackCheckout(
    purchaseInfo,
    function finish(){
      if(!hasBeenCalled){
        hasBeenCalled = true;
        chargeCreditCard(purchaseInfo);
        showThankYouPage();
      }
    }
  )
  - Trust
   - Not too early
   - Not too late
   - Not too many times
   - Not too few times
   - No lost context
   - No swallowed errors
  What happens if the trust falls apart?
  If your program does not have fixes for all of the above issues then the program has a bug even if is not apparent

5 - Callback Problems Not Reasonable
Callbacks in the instructors view cannot be reasoned about.
The instructor reckons that bugs happen when the programmers natural inclination for sequential steps diverges from the
JS Engine
  Pseudo Task Syntax
  - start task1:
    do some stuff
    pause
  - start task2:
    do some other stuff
    pause
  - resume task1:
    do more stuff
    pause
  - resume task2:
    finish stuff
  - resume task1:
    finish stuff
  Refactored Pseudocode which has begun to resemble callbacks Syntax
  - start task1:
    do some stuff
    pause
      resume task1:
        do more stuff
        pause
          resume task1:
            finish stuff
  - start task2:
    do some other stuff
    pause
      resume task2:
        finish stuff
Temporal dependency is where an item depends on another item finishing before this item can proceed, this nesting is the
only way callbacks can handle temporal dependencies
No single developer will understand all flow paths of async code
