                    Rethinking Asynchronous Javascript
                    Course Notes Part 4


2 - Exercise 2
The same as exercise 1 but this time it involves thunks instead

3 - Exercise 2 Solution
Solution Syntax
	var th1 = getFile("file1");
  var th3 = getFile("file2");
  var th3 = getFile("file3");
  
  th1(function ready(text1){
    output (text1);
    th2(function ready(text2){
      output (text2);
      th3(function ready(text3){
        output (text3);
        output ("Complete"):
      });
    });
  });
If the thunk above was lazy it would not make the AJAX request until th1 was finished
This is much better than exercise 1
  Get File Syntax
  function getFile(file){
    var resp;
    
    fakeAjax(file, function(text){
      if(!resp){
        resp = text;
      } else{
        resp(text);
      } 
    })
    
    return function th(cb){
      if(resp){
        cb(resp);
      } else {
        resp = cb;
      }
    }
  }
Promises are not a replacement for thunks
You do not always need a framework, using the tools you have better can be a better solution

4 - Thunks and Closure
Thunks are not really all that special
Thunks use closure to maintain state
Thunks do not solve all the issues of callbacks
Thunks do however solve a problem
  - By using the closure to maintain state you eliminate time as a complicating factor



                    Section 4 - Promises
1 - Native Promises
Promises have a multitude of ways that they are explained
It's important to understand the concepts first before understanding the API
  - Many courses take the opposite approach
Promises are not perfect and have gotchas which you will need to understand in order to fix problems
There is such thing as promises hell
A future value is a programming concept for a value that will be fulfilled sometime in the future
Promises are concepts that have come from the language E where they are called futures
This is related to functional programming
  - Promise mechanisms are very similar to monads

2 - Promise API
Example Syntax for Completion Event
  // This avoids inversion of control
  function finish(){
    chargeCreditCard(purchaseInfo);
    showThankYouPage();
  }
  
  function error(err){
    logStatsError(err);
    finish();
  }  
  var listener = trackCheckout(purchaseInfo);
  
  listener.on("completion", finish);
  listener.on("error", error);

Promises uninvert the inversion of control problem
Promises are like event listeners but the completion event in promises is called the "Then" event
Example Syntax
  function trackCheckout(info){
    return new Promise(
      function(resolve, reject){
        // Attempt to track the checkout
        // If successful call resolve otherwise call reject(error)
      }
    )
  }
  
  // Refactored version of completion event example
  function finish(){
    chargeCreditCard(purchaseInfo);
    showThankYouPage();
  }
  
  function error(err){
    logStatsError(err);
    finish();
  }
  var promise = trackCheckout(purchaseInfo);
  
  promise.then(finish, error);

Frameworks use inversion of control intentionally where things are called for you, this also separates 
a library from a framework.
The instructor does not recommend inversion of control in Async coding
Promises still use call backs but there has been trust installed into the design
Promise Trust
  - They are only resolved once
  - They are either success or error
  - Messages passed or kept
  - Exceptions become errors
  - Immutable once resolved
