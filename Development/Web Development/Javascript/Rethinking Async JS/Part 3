                    Rethinking Asynchronous Javascript
                    Course Notes Part 3


6 - Non-Fixes
Some attempts at fixes have made issues worse
Split callbacks are an example of attempts to fix callbacks
  - This was is a situation where we have an error that we do not want to get swallowed just in case there is a problem with 
    the main function, this then passes a seperate callback for errors
  - This doesn't work as it makes trust issues worse, what happens if neither function or both is called?
Split callback Syntax
  function trySomething(ok, err){
    setTimeout(function(){
      var num = Math.random();
      if(num > 0.5) ok(num);
      else err(num);
    }, 1000);
  }
  trySomething(
    function(num){
      console.log('Success : ' + num);
    },
    function(num){
      console.log('Sorry : ' + num);
    }
  );

Error first Callbacks
  - used in Node.js
  - Dont fix the trust issues from split callbacks
  - Syntax
  function trySomething(cb){
    setTimeout(function(){
      var num = Math.random();
      if(num > 0.5) cb(null, num);
      else cb('Too Low');
    }, 1000);
  }
  trySomething(
    function(err, num){
      if(err){
        console.log(err);		
      }
      else {
        console.log('Number : ' + num);
      }
    }
  );

  Nested Callback Syntax
  function getData(d, cb){
    setTimeout(function(){
      cb(d);
    }, 1000);	
  }
  getData(10, function(num1){
    var x = 1 + num1;
    getData(30, function(num2){
      var y = 1 + num2;
      getData(
        "Meaning of Life : " + (x + y),
        function(answer){
          console.log(answer);
        }
      );
    });
  });

                    Section 3 - Thunks
1 - Synchronous and Asynchronous Thunks
From a synchronous perspective a thunk is a function that has everything already that it needs to give you something back
you do not need to pass in anything, simply call it and it gives you back a value
Synchronous Thunk Example Syntax
  function add(x, y){
    return x + y;
  }

  var thunk = function(){
    return add(10,15);
  }
	
  thunk();
thunk has become a wrapper around that state as it is the same number and can be passed around the program like a token
This is the conceptual underpinning for what a promise is in JS
An asynchrounous thunk has many definitions, there are many different right answers, is can be defined as a function that
does not need any arguments passed to it tot do its job except you need to pass it a callback to get the value out
Asynchronous Thunk Example Syntax
  function addAsync(x, y, cb){
    setTimeout(function(){
      cb(x + y);
    }, 1000);
  };

  var thunk = function(cb){
    addAsync(10, 15, cb);
  };

  thunk(function(sum){
    sum();
  });
What makes this so powerful is that we do not know or care how long it will take to get that value
By wrapping the function around the state and allowing it to be asynchronous we have esentially normalised time out of the
equation
Time is the most complex factor of state in a program
Thunks do not offer any solutions to Inversion of Control, promises will offer solutions to IOC's
Nested Thunk Syntax
// This is a re-writing of the previous section example
// The first line does not perform an AJAX request, it merely creates a wrapper that will make the request when called
  var get10 = makeThunk(getData, 10);
  var get30 = makeThunk(getData, 30);
  
  get10(function(num1){
    var x = 1 + num1;
    get30(function(num2){
      var y = 1 + num2;
      // This thunk cannot be created earlier as it is temporally dependent on the other thunks
      var getAnswer = makeThunk(getData, 
        "Meaning of life is " + (x + Y)
      );
      getAnswer(function(answer){
        console.log(answer);
      });
    });
  })
