                    Debugging and Fixing Common JavaScript Errors
                    Course Notes Part 2


3 - Challenge 1: Solution
The solution to exercise 1
  - The problem is that property destroy of undefined 
  - The error listed points to an onDelete() function
  - The first step taken by the instructor to understand the problem is to turn on async in the call stack window
    - This will give a much better understanding of what asynchronous operations are going on 
    - This is because it captures stack traces across Async boundaries eg network requests, setTimeout's etc
    - There is addtional overhead from the feature but is worth it in these cases
  - JQuery and tracker.js should be blackboxed
    - You will end up stepping through minified code unnecessarily otherwise
    - JQuery etc are unlikely to be the source of errors
  - Using the sources panel can be great when stepping into code
    - This will allow you to see items in scope
  - The error occurs because of a misuse of the word this in the onDelete() function
    - The value of this was lost when going into the function
    - The setTimeout inside the onDelete function executes in a different context
    - If not specified it will use the default global window()
  - This kind of error is the most common type of error in Javascript
    - It occurs because of a misunderstanding of context in Javascript
  - There are a few different solutions available
    - Use the outer closure to save the value this into a variable eg var this = that; that.model.destroy();
    - Another way is to force what we want the value to be by binding using function(){}.bind
      - Bind can be only used once and it wont be changed after being used the first time
  


                    Section 4 - Second Bug
1 - Challenge 2: Persisting Text
The bug to be repaired in this example is that text is remembered even though it has been deleted
  - User reported bugs can be the most expensive type of issue to fix
  - This will use some of the same examples from the previous example

2 - Challenge 2: Solution
The instructor likes to tackle bugs by starting from the user viewpoint
  - In this case it is the text box that holds rants as they are being typed
  - Looking at the JS that interacts with this is a great place to begin
  - In this case there are keyups which are eventListeners to the textarea
    - There are 2 separate ones in this case
    - There is an event handler called onChange
      - This has a boolean shortcut where if the event does not have a target it will create an empty object
      - This can be used to held handle a manipulated event being sent in
  - If there is a value it is saved in localStorage
    - localStorage is one of a few ways that the browser has to persist information in the browser itself
    - Using the application tab on Chrome-Devtools will show what is in localStorage
    - These are essentially key-value pairs
    - Learning keyboard shortcuts is a time saver when debugging a lot
    - Empty string is evaluated as false in boolean
  - Change from if(text){} to if(typeof text === "string")
    - This will remove the text from localStorage
    - Again this is a logic bug where empty string was being assessed as falsy
    - It should have been looking at whether an empty string was a valid value



                    Section 5 - Third Bug
1 - Challenge 3: Server Reporting 400 Bad Request Errors

2 - Questions 1

3 - Challenge 3: Solution



                    Section 6 - Fourth Bug
1 - Challenge 4: One User, Many Errors

Challenge 4: Solution

