                    The Coding Interview Bootcamp: Algorithms + Data Structures
                    Course Notes Part 2


4 - String Reversal, Solution #3
Example Syntax
  // Another solution this time using array helper methods
  function reverse(str){
    // Reduce was added in ES5.1
    // It takes all the values in an array and condenses them down to a singular value
    // It takes 2 values, the first is a function and the second is a initialising value
    return str.split('').reduce((reversed, character) => {
      return character + reversed;
    }, '');
  }
  
  module.exports = reverse;

5 - Debugger Statements
Debugging can be tough and tests may not be appropriate for helping with debugging
Using the debugger statement will pause execution
  - To use a debugger you will have to manually call the function
  - To run the file so it can be debugged at the cli
    - node inspect index.js
  - This will run and pause the file at the debugger statement
  - You will also have a special debug prompt available
  - To tell the debugger to continue execution there are a couple of different options available
    - At the debug prompt type either cont or c
  - You must enter repl mode to inspect a variable
    - At the debug prompt enter repl
    - This gives a new JS console where variables etc can be inspected
  - repl and debug can be used to audit and develop codebases
  - Using repl and debug is highly recommended
  - Using the debugger in a for loop etc will call it multiple times
  - Ensure that when finished that both the debugger statement and manual function call are removed



                    Section 4 – Paldinromes
1 - Palindromes
Palindromes are words that are the same backwards and forwards
  - ABBA for example is a palindrome

2 - Palindromes, Solution #1
Example Syntax
  // The first solution to whether a given word is a palindrome
  function palindrome(str){
    const reversed = str.split('').reverse().join('');
    
    // This will produce a boolean value on whether the 2 strings are equal
    return str === reversed;
  }
  
  module.exports = palindrome;

3 - Palindromes, Alternate Solution
Example Syntax
  // An alternative solution to whether a given word is a palindrome
  function palindrome(str){
    
  }
  
  module.exports = palindrome;


                    Section 5 – Integer Reversal
1 - Reversing an Int
The challenge in this section is to take an integer and return an integer that is the reverse
  - For example 15 would be 51, 987 would be 789 etc 
  - This has a lot in common with the previous reversing example
  - This problem as a lot of tricks and is good for practice at an interview
    - When reversing 0 will disappear at the end eg 500 will become 5
    - Using negative numbers is similar eg -25 becomes -52 and -90 becomes -9
  - The end result has to be a number not a string

2 - Reversing an Int Solution
Example Syntax
  // The solution to the Int reversing
  function reverseInt(n){
    // The code is much more legible using the two statements
    const reversed  = n.toString().split('').reverse().join('');
    
    // This will return an integer value from the string, Math.sign will multiply the value by
    // 1 if a positive value and -1 if it is a negative value
    return parseInt(reversed) * Math.sign(n);
    
  }
  
  module.exports = reverseInt;


                    Section 6 – MaxChars
1 - Max Chars Problem
The solutions to this particular problem can be applied to many different string problems
The problem to be solved in this section is
  - Given a string, what is the character that is most commonly used in the string
    - For Example aaaabbbbbcccccccccc -> this would return c as the most commonly used character
    - The method for solving is to convert a string to an object and count the keys of the object to find the most common

2 - Max Chars Character Map
Example Syntax
  // An example solution to help guide the solution to the MaxChars problem
  const string = "Hello There";
  const chars = {};
  
  for(let char of string){
    // If you were just to add 1 to the values you would be left with null values
    // By using the or the value of 1 is then assigned
    chars[char] = chars[char] + 1 || 1;
  }
  
  // Another more verbose solution is 
  for(let char of string){
    if(!chars[char]){
      chars[char] = 1;
    } else {
      chars[char]++;
    }
  }
  
  chars;

3 - Max Chars Solution

4 - Max Chars Solution Continued



                   Section 7 – The Classic FizzBuzz!
1 - FizzBuzz Problem Statement
This is a hugely popular question for interviews
  - It has been used millions of times
The challenge is as follows
  - Write a program that console.log numbers from 1 - N
  - For multiples of 3 print fizz instead of the number
  - For multiples of 5 print buzz instead of the number
  - For numbers which are multiples of both print fizzbuzz

2 - Solving FizzBuzz with Style
Example Solution
  function fizzBuzz(n) {
    // If asked the fizzbuzz question then use the more well known and less fancy solution
    for(let i = 0; i <= n; i++){
      // This will use modulus where a number is divide and if there is no remainder its true
      // The double ampersands mean that if the first part is not true then the second part does not need to be
      // checked, this short circuits checks and can save wasting time checking things which don't need to be checked
      if(i % 3 === 0 && i % 5 === 0){
        console.log('fizzbuzz');
      } else if (i % 3 === 0) {
        console.log('fizz');
      } else if (i % 5 === 0){
        console.log('buzz');
      } else {
        console.log(i);
      }
    }
  }
  
  module.exports = fizzBuzz;



                    Section 8 – Array Chunking
1 - Array Chunk Problem Statement
The challenge for this section is to take an array and a chunk size, the array is then divided into
subarrays which are the same length as the chunk size
  - One example is -- chunk([1, 2, 3, 4], 2) which becomes [[1, 3], [3, 4]]

2 - Chunk Solution #1
A diagram of the solution to the chunk problem, the process is as follows
  - Create an empty array to hold chunks called chunked
  - For each element in the unchunked array 
  - Retrieve the last element in chunked
  - If the last element does not exist or if it length is equal to chunk size then push
    a new chunk into chunked with the current element
  - Else add the current element into the chunk

3 - More on Chunk
Example Syntax
  // The first solution to the chunk solution problem
  function chunk(array, size){
    // This will follow the process from aboe
    const chunked = [];
    
    for(let element of array){
      const last = chunked[chunked.length - 1];
      
      if(!last || last.length === size){
        chunked.push([element]);
      } else {
        last.push(element);
      }
    }
    
    return chunked;
  }
  
  module.exports = chunk;

4 - Chunk Solution #2

5 - Even More on Chunk!



                    Section 9 – Anagrams
1 - What Are Anagrams?
The challenge in this section is to see if 2 provided strings are anagrams of each other
  - A string in an anagram of another if it uses the same characters in the same quantity
  - Casing is not important as upper or lower case is considered the same character in this case
  - Special characters and spaces are disregarded
Example Syntax
  // Using regex to remove special characters and change to lower case
  const word = "HI THERE!!!!!!!";
  
  // This will return hithere
  word.replace(/[^\w]/g, "").toLowerCase();

There are many different ways to solve the same problem but generating character maps for each string is recommended

2 - Solving Anagrams
Example Syntax
  // The first solution to anagrams
  // Anagrams are a favourite of interviewers
  function anagrams (stringA, stringB){
    const aCharMap = buildCharMap(stringA);
    const bCharMap = buildCharMap(stringB);
    
    // Object.keys can be used to find the keys associated with an object and the length property will 
    // give the quantity of keys on each object
    if(Object.keys(aCharMap).length !== Object.keys(bCharMap).length){
      return false'
    }
    
    for(let char in charMap){
      if(aCharMap[char] !== bCharMap[char]){
        return false;
      }
    }
    
    return true;
  }
  
  // Rather than using 2 separate loops it is better practice to make helper functions
  // this logic only has to be written one time and can be used on both strings
  function buildCharMap(str){
    const charMap = {};
    
    // The clean up logic is more compact being added to the loop
    // The regex replaces anything not a character with nothing
    for(let char of str.replace(/[^\w]/g, '').toLowerCase()){
      charMap[char] = charMap[char] + 1 || 1;
    }
    
    // Make sure to put in a return statement
    return charMap;
  }
  
  module.exports = anagrams;

3 - Another Way to Tackle Anagrams



                    Section 10 – Sentence Capitalization
1 - Understanding Capitalization
The challenge to be solved in this section is as follows
  - Write a function that accepts a string
  - It should capitalise the first letter of each word and then return the capitalised string
    - For example hello how are you today -> Hello How Are You Today

2 - Capitalization Solution #1
Example Syntax
  // This is the more direct solution
  function capitalize(str){
    // Create an empty array words
    const words = [];
    
    // Split str into words using split at the space between words
    for(let word of str.split(' ')){
      // Take the first character of each word and uppercase it
      // Join it to the rest of the word using the slice() function beginning at the second element
      // Push the results into the words array
      words.push(word[0].toUpperCase() + word.slice(1));
    }
    
    // Rejoin the words using the space character
    return words.join(' ');
    
  }
  
  module.exports = capitalize

3 - How Else Can We Capitalize?



                    Section 11 - Printing Steps
1 - The Steps Question
This is similar to the next section
  - These are both used often in interviews
The directions in this challenge are to write a function
  - It should accept a postive number N
  - It should console.log a step shape with N levels using the # character
  - Also there should be the necessary spaces on the right side

2 - Steps Solution #1
The process for solving the challenge in the first method uses recursion
  - From 0 - N iterate through rows using a for loop
  - Create an empty string called stair
  - From 0 - N iterate through columns using a for loop
  - If the current column is equal to or less than the current row then add a # to stair
  - Else add a space to stair
  - Console.log stair

3 - Steps Solution #1 Continued
Highly recommended to write out a solution using pseudocode before coding
  - This is even more so in an interview setting
Example Syntax
  // The first solution to the Steps question
  function steps(){
  
  }
  
  module.exports = setting;

4 - Step Up Your Steps Game

5 - More on Steps



                    Section 12 - Two Sided Steps - Pyramids
1 - Pyramids Vs Steps

2 - Pyramid Solution #1

3 - Pyramid Solution #2



                    Section 13 - Find The Vowels
1 - Get Your Vowels
The challenge in this section is to
  - Write a function that returns the number of vowels in a string
    - Vowels in English are the characters a, e, i, o, u
  - For Example  Hi There -> 3, Why -> 0 

2 - Finding Vowels
Example Syntax
  // First Solution to finding the vowels in a string
  function vowels(str){
    let count = 0;
    const checker = ["a", "e", "i", "o", "u"];
    
    foreach(let char of str.toLowerCase()){
      if(checker.includes(char)){
        count++;
      }
    }
    
    return count;
  }
  
  module.exports = vowels;

3 - Another Way to Find Vowels



                    Section 14 - Enter the Matrix Spiral
1 - General Matrix Spirals

2 - Spiral Solution

3 - More on Spiral



                    Section 15 - Runtime Complexity
1 - What is Runtime Complexity?
There are ways of comparing solutions to problems that is independent of personal opinion
  - Runtime Complexity describes the performance of an app
  - For example if the inputs to an algorithm were doubled how much more processing power would be required

2 - Determining Complexity

3 - More on Runtime Complexity



                    Section 16 - Runtime Complexity in Practice - Fibonacci
1 - The Fibonacci Series

2 - Fibonacci Series Iterative Solution

3 - Fibonacci Series Recursive Solution

4 - Memoi-....Mem-...Memoization!

5 - I Believe Its Memoization!



                    Section 17 - The Queue
1 - What's a Data Structure?

2 - The Queue Data Structure

3 - Implementing a Queue



                    Section 18 - Underwater Queue Weaving
1 - What's a Weave?

2 - How to Weave



                    Section 19 - Stack 'Em Up With Stacks
1 - Stack Data Structure

2 - Implementing a Stack



                    Section 20 - Two Become One
1 - Queue From Stack Question

2 - Creating a Queue From Stacks

3 - More on Queue From Stack



                    Section 21 - Linked Lists
1 - What's a Linked List?

2 - Exercise Setup

3 - Node Implementation

4 - Linked List's Constructor

5 - Linked Lists's InsertFirst

6 - Solving Insert First

7 - Sizing a List

8 - Solve for Size

9 - Get Over Here, GetFirst!

10 - Building GetFirst

11 - Find Your Tail with GetLast

12 - GetLast Implementation

13 - Clear that List

14 - Clear Solution

15 - Where's My Head, RemoveFirst?

16 - Building RemoveFirst

17 - Bye-Bye Tail with RemoveLast

18 - RemoveLast Implementation

19 - A New Tail to Tell with InsertLast

20 - Adding InsertLast

21 - Pick Em Out with GetAt

22 - GetAt Solution

23 - Remove Anything with RemoveAt

24 - RemoveAt Solution

25 - Insert Anywhere with InsertAt

26 - InsertAt Solution

27 - Code Reuse in Linked Lists

28 - List Traversal Through ForEach

29 - Note on Generators

30 - Brushup on Generators

31 - Linked Lists with Iterators



                    Section 22 - Find the Midpoint
1 - Midpoint of a Linked List

2 - Midpoint Solution



                    Section 23 - - Circular Lists
1 - Detecting Linked Lists Loops

2 - Loop Solution



                    Section 24 - Step Back From the Tail
1 - From Last Question

2 - From Last Solution



                    Section 25 - Building a Tree
1 - Trees Overview

2 - Node Implementation

3 - More on Nodes

4 - Tree Implementation

5 - Traverse By Breadth

6 - Solving for Breadth-First Traversal

7 - Depth First Traversal

8 - Solving for Depth-First Traversal



                    Section 26 - Tree Width with Level Width
1 - Level Width Declaration

2 - Measuring Level Width



                    Section 27 - My Best Friend, Binary Search Trees
1 - What's a Binary Search Tree?

2 - Binary Search Tree Implementation

3 - BST Insertion

4 - Do You Contain This?

5 - Solving Contains



                    Section 28 - Validating a Binary Search Tree
1 - How to Validate a Binary Search Tree

2 - More on Validation

3 - Solution to Validation



                    Section 29 - Back to Javascript - Events
1 - What's an Eventing System?

2 - A Tip on Events

3 - Events Solution



                    30 - Sorting With BubbleSort
1 - Sorting Algorithm Overview

2 - BubbleSort Solution



                    31 - Sort By Selection
1 - How SelectionSort Works

2 - Selection Sort Solution



                    32 - Ack, MergeSort!
1 - MergeSort Overview

2 - The Merge Function

3 - More on MergeSort

4 - I Don't Like Recursion, But Let's Do This Anyways


