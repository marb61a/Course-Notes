


                   Section 3 - Recursion
1 - Why Recursion?
Most people remember a syntax
Recursion is a method which calls itself 
It is just a way of taking a proceedure which operates again and again, in some cases it could be replaced by a loop
They provided elegant solutions to Don't Repeat Yourself (DRY)

2 - Tracing Recursive Execution
Example Syntax
  // This will cause an infinite loop
  var callMe = function(){
    callMe();
    callMe();
    callMe('Anytime'):
  }
  
  callMe();
  
  // One way to avoid infinite loops
  var callMe = function(){
    return 'No more infinite loops';
    
    callMe('Anytime'):
  }
  
  callMe();
  
  // Using an if statement to avoid infinite looping
  var tracker = 0;
  var callMe = function(){
    tracker++;
    if(tracker === 3){
      return 'loops';
    }
    callMe('Anytime'):
  }
  
  callMe();

3 - Template for a Recursive Function

4 - Looping

5 - Factorial with Loop

6 - Factorial with Recursion

7 - Exercise: Recursion Interview Questions
  - https://github.com/kuychaco/algoClass/blob/master/recursion/recursionIntro.js

8 - Recursive Reverse Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/recursion/recursionIntro.js

9 - Recursive Multiplier Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/recursion/recursionIntro.js

10 - MinStack Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/stack.js

11 - Implementing a Queue with Two Stacks Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/queue.js



                    Section 4 - Time Complexity
1 - Space vs. Time Complexity
Introduction to Time Complexity
  - What is it that makes an algoritm fast
There are a couple of different complexities that will be discussed
  - Time Complexity and Space Complexity

2 - Calculating Time Complexity

3 - Understanding Big-O

4 - Calculating Big-O of JS Operations

5 - Calculating Big-O of Loops

6 - Exercise: Calculating Time Complexity
  - http://slides.com/bgando/sorting#/0/20

7 - Calculating Time Complexity Solution



                    Section 5 - Elementary Sorting
1 - Bubble Sort
  - https://www.youtube.com/watch?v=lyZQPjUT5B4

2 - Stability and Adaptability

3 - Selection & Insertion Sort

4 - Exercise: Bubble, Insertion, and Selection Sort
  - https://github.com/kuychaco/algoClass/tree/master/sorting-algorithms

5 - Bubble, Insertion, and Selection Sort Solution
Example Syntax
  var bubbleSort = function(array) {
    // While wall is greater than 0
    var wall = array.length
    // iterate though the array up to wall
    while(wall >= 0){
      for(var i = 0; i < wall; i++){
        if(array[i] > array[i+1]){
          // Here, if the next value is less than the current, then swap them
          array = swap(array, i, i+1)
        }
      }
      
      wall--;
    }
    
    return array;
  }


                    Section 6 - Sorting Algorithms
1 - Merge Sort
This is the first sorting algorithm which is subquadratic time
  - This means that it can take a substatial amount of data and sort it
Divide & Conquer
  - Step 1 - Recognise the base case
  - Step 2 - Divide -- Break down problem during each call
  - Step 3 - Conquer -- Do work on each subset
  - Step 4 - Combine Solutions
Merging Lists - The merge step takes 2 sorted lists and mergers them into 1
  - The time complexity involved is linear
  - It would be quadratic if it was not sorted

2 - Pseudocoding the Merge Routine

3 - Pseudocoding Merge Sort

4 - Time Complexity for Merge Sort

5 - Quick Sort Overview

6 - Understanding the Quick Sort Partition

7 - Pseudocoding Quick Sort Part 1

8 - Pseudocoding Quick Sort Part 2

9 - Reviewing the Pseudocode

10 - Debugging the Quick Sort Algorithm

11 - Quick Sort Review Part 1

12 - Quick Sort Review Part 2



                    Section 7 - Trees & Searching
1 - Trees

2 - Linked Lists

3 - Pseudocoding a Linked List

4 - Exercise: Implement a Linked List
  - https://github.com/kuychaco/algoClass/blob/master/data-structures/linkedList.js

5 - Implement a Linked List Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/linkedList.js

6 - Implementing a Tree



                    Section 8 - Reviewing Core Concepts
1 - Review: Time Complexity

2 - Review: Elementary Sorting

3 - Review: Recursion

4 - Review: Merge Sort

5 - Review: Quick Sort Part 1

6 - Review: Quick Sort Part 2

7 - Review: Stacks & Queues

8 - Review: Linked Lists

9 - Review: Trees Part 1

10 - Review: Trees Part 2



                    Section 9 - Binary Trees
1 - Binary Search Tree Overview

2 - Exercise: Binary Search Trees
  - https://github.com/kuychaco/algoClass/blob/master/data-structures/binarySearchTree.js

3 - Pseudocoding a Binary Search Tree

4 - BST Search Procedure

5 - BST Review & Scoping Discussion

6 - Pseudocoding the BST contains() Method

7 - Binary Search Tree Exercise Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/binarySearchTree.js

8 - In-Order Traversal

9 - Pseudocoding In-Order Traversal Part 1

10 - Pseudocoding In-Order Traversal Part 2

11 - Pre-Order Traversal

12 - Post-Order Traversal

13 - Initial Time Complexity for a BST

14 - Deleting Min/Max Nodes

15 - BST Review

16 - Pseudocoding Min/Max Deletion

17 - Reviewing the Min/Max Pseudocode Part 1

18 - Reviewing the Min/Max Pseudocode Part 2

19 - Exercise: Deleting Single-Child Nodes
  - https://github.com/kuychaco/algoClass/blob/master/data-structures/binarySearchTree.js

20 - Deleting BST Nodes Solution Part 1

21 - Deleting BST Nodes Solution Part 2

22 - Exercise: Deleting Two Children

23 - Deleting Two Children Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/binarySearchTree.js

24 - Analysis of Time Complexity



                    Section 10 - Graphs & Paths
1 - Graph Vocabulary & Representations

2 - Pseudocoding the Matrix Constructor

3 - Pseudocoding the addNode() Method

4 - Pseudocoding the addEdges() Method

5 - Exercise: Adding Nodes and Edges

6 - Adding Nodes and Edges Solution

7 - Adjacency List

8 - Pseudocoding an Adjacency List

9 - Exercise: Implement a Graph
  - https://github.com/kuychaco/algoClass/blob/master/data-structures/graph.js

10 - Implement a Graph Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/graph.js


                    Secion 11 - Depth & Breadth-First Search
1 - Graph Traversing & Depth-First Search

2 - Pseudocoding DFS Part 1

3 - Pseudocoding DFS Part 2

4 - Breadth-FIrst Search

5 - Pseudocoding BFS

6 - Breadth-First Search with a Graph Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/graph.js

7 - BFS Graph Stack Trace Part 1

8 - BFS Graph Stack Trace Part 2

9 - Depth-First Search with a Tree Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/tree.js

10 - Breadth-First Search Solution
  - https://github.com/kuychaco/algoClass/blob/solutions/data-structures/graph.js

11 - Breadth-First Search Stack Trace



                    Section 12 - Hash Tables
1 - Hash Tables

2 - Pseudocoding a Hashing Function

3 - Key Components Of A Hash table

4 - Pseudcoding set(), get() & remove()

5 - Handling Collisions

6 - Exercise Implementing A Hash Table

7 - Implementing A Hash Table Solution


                    Section 13 - Next Steps
1 - Next Steps
                                    
