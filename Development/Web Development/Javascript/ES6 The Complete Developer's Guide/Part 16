                    ES6 Javascript: The Complete Developer's Guide
                    Course Notes Part 16
                    
                    
6 - A Practical Use of ES6 Generators
Example Syntax
  const engineeringTeam = {
    size: 3,
    department: 'Engineering',
    lead: 'Jill',
    manager: 'Alex',
    engineer: 'Dave'
  }
  
  function* TeamIterator(team){
    yield team.lead;
    yield team.manager;
    yield team.engineer;
  }
  
  const names = [];
  for(let name of TeamIterator(engineeringTeam)){
    names.push(name);
  }
  
  names;

7 - Delegation of Generators
You will neeed to give it time to understand properly
Example Syntax
  const testingTeam = {
    lead: 'Amanda',
    tester: 'Bill'
  }

  const engineeringTeam = {
    testingTeam,
    size: 3,
    department: 'Engineering',
    lead: 'Jill',
    manager: 'Alex',
    engineer: 'Dave',
  }
  
  function* TeamIterator(team){
    yield team.lead;
    yield team.manager;
    yield team.engineer;
  }
  
  function* TestingTeamIterator(team){
    yield team.lead;
    yield team.tester;
  }
  
  const names = [];
  for(let name of TeamIterator(engineeringTeam)){
    names.push(name);
  }
  
  names;

8 - Delegation of Generators Continued
A continuation of the previous chapter
Example Syntax
  const testingTeam = {
    lead: 'Amanda',
    tester: 'Bill'
  }

  const engineeringTeam = {
    testingTeam,
    size: 3,
    department: 'Engineering',
    lead: 'Jill',
    manager: 'Alex',
    engineer: 'Dave',
  }
  
  function* TeamIterator(team){
    yield team.lead;
    yield team.manager;
    yield team.engineer;
    // Delegators are used when there are multiple generators that belong together
    const testingTeamGenerator = TestingTeamIterator(team.testingTeam);
    // Ensures that the testing team iterator is seen by the for-of loop
    yield* testingTeamGenerator;
  }
  
  function* TestingTeamIterator(team){
    yield team.lead;
    yield team.tester;
  }
  
  const names = [];
  for(let name of TeamIterator(engineeringTeam)){
    names.push(name);
  }
  
  names;

9 - Symbol.Iterator with Generators
Symbol Iterator is a tool the teaches objects how to respond to the for-of loop
This section will refactor the code from the previous couple of chapters
Example Syntax
  const testingTeam = {
    lead: 'Amanda',
    tester: 'Bill',
    // ES6 allows for dynamic key interpolation
    [Symbol.iterator]: function*(){
      yield this.lead;
      yield this.tester;
    }
  }

  const engineeringTeam = {
    testingTeam,
    size: 3,
    department: 'Engineering',
    lead: 'Jill',
    manager: 'Alex',
    engineer: 'Dave',
  }
  
  function* TeamIterator(team){
    yield team.lead;
    yield team.manager;
    yield team.engineer;
    yield* team.testingTeam;
  }
  
  const names = [];
  for(let name of TeamIterator(engineeringTeam)){
    names.push(name);
  }
  
  names;

10 - Complexities of Symbol.Iterator
Example Syntax
  // Refactoring the engineering team from the previous example
    const testingTeam = {
      lead: 'Amanda',
      tester: 'Bill',
      [Symbol.iterator]: function*(){
        yield this.lead;
        yield this.tester;
      }
    }

    const engineeringTeam = {
      testingTeam,
      size: 3,
      department: 'Engineering',
      lead: 'Jill',
      manager: 'Alex',
      engineer: 'Dave',
      [Symbol.iterator]: function*(){
        yield this.lead;
        yield this.manager;
        yield this.engineer;
        yield* this.testingTeam;
      }
    }

    const names = [];
    for(let name of engineeringTeam){
      names.push(name);
    }

    names;

11 - Generators with Recursion
Example Syntax
  // Example will make use of a tree data structure
  // Tree structures are used a lot in web development 
  class Comment{
    constructor(content, children){
      this.content = content;
      this.children = children;
    }
  }
  
  const children = [
    new Comment('good comment', []),
    new Comment('bad comment', []),
    new Comment('meh', [])
  ];
  
  const tree = new Comment ('Great Post', children);
  tree;

12 - More on Generators and Recursion
Example Syntax
  // Continuing the previous example
  class Comment{
    constructor(content, children){
      this.content = content;
      this.children = children;
    }
    
    *[Symbol.iterator](){
      yield this.content;
      // Array helpers do not work with generators
      for(let child of this.children){
        yield* child;
      }
    }
  }
  
  const children = [
    new Comment('good comment', []),
    new Comment('bad comment', []),
    new Comment('meh', [])
  ];
  
  const tree = new Comment ('Great Post', children);
  const values = [];
  for(let value of tree){
    values.push(value);
  }
  values;


                    Section: 17 - Promises and Fetch
1 - Code Execution in Javascript
ES6 has a native implementation of Promises
  - In JS there is no pausing of execution of code
  - Use of setInteral and similar will defer execution
  - You may need for things to complete before continuing execution hence Promises

2 - Terminology of Promises
Promises have 3 different states
  - Unresolved which is when still waiting for something to finish
  - Resolved which is where something has finished and is ok
  - Rejected is where something has finished and it went bad

3 - Creating Promises
Example Syntax
  // The vast majority of Promise use will be with Ajax but are not mutually dependent
  promise = new Promise((resolve, reject) =>{
    //resolve();
    // Will put the promie in the rejected state
    reject();
  });
  

4 - Then and Catch
Example Syntax
  promise = new Promise((resolve, reject) =>{
    resolve();
  });
  
  // Only called if the promise is resolved
  promise
    .then(() => console.log("finally finished") )
    .then(() => console.log('I was also ran') )
    // Will run when promise is rejected
    .catch(() => console.log('uh oh') )
  
5 - Async Code with Promises
Example Syntax
  promise = new Promise((resolve, reject) =>{
    setTimeout(() => {
      resolve();
      // Time is in milliseconds
    }, 3000);
  });
  
  promise
    .then(() => console.log("finally finished") )
    .then(() => console.log('I was also ran') )
    .catch(() => console.log('uh oh') );

6 - Ajax Requests with Fetch
Promises works well with the fetch helper
  - fetch is built into the browser
Example Syntax
  // Specifically using HTTPS
  url = "https://jsonplaceholder.typicode.com/posts/";
  
  //When making a request with fetch the response does not immediately include the data
  fetch(url)
    // Pulls some json data from the response
    .then(response => response.json())
    .then(data => console.log(data))

7 - Shortcomings of Fetch
Example Syntax
  url = "https://jsonplaceholder.typicode.com/posts/";
  
  fetch(url)
    .then(response => console.log(response))
    // If using fetch, an error above 300 does not enter the catch case
    // This is at odds with all other libraries
    // Fetch will only return the catch case when the network request fails completely
    .catch(error => console.log('Bad', error)); 
                                        
