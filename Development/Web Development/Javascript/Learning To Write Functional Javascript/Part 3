                    Learning To Write Functional Javascript
                    Course Notes Part 3


                    Section 2 - ABSTRACTING LANGUAGE CONSTRUCTS WITH HIGHER-ORDER FUNCTIONS
1 - Promoting Reusability with Higher-Order Functions
This section will deal with Higher-Order functions which are very useful
  - There is a high likelihood that variants of these would have been seen by many developers
  - Higher-Order functions are functions that either take or return functions
Javascript supports functions as first class objects, this is what allows for higher-order function
Example Syntax
  const kiss = (a) => {
    return a !== 'frog' ? a: 'prince';
  }
  
  function transform(thing, changeFn){
    return changeFn(thing);
  }
  
  transform('frog', kiss);          // prince
  transform('the sky', kiss)        // the sky

  // Another example of higher-order functions
  function getter(prop){
    return obj => isObject(obj) ? obj[prop] : undefined;
  }
  
  const name = getter('name');
  cosnt score = getter('score');
  const age = getter('age');
  
  const p1 = {
    id: 3,
    name: 'Sandra',
    score: 1024
  };
  
  name(p1);                         // Sandra
  score(p1);                        // 1024
  age(p1);                          // undefined
  age(100);                         // undefined

Closures
Every time a function is called a new scope is created
  - lambda functions do not have their own this keyword, they inherit it from the scope that they are defined in
  - In functional programming the keyword this is not that important
Every single Javascript program has a single wrapping scope context creted when the script first runs
Example Syntax
  class RemoteLogger{
    constructor(){}
    
    sendMessage(message, value){
      console.log(
        '\nLogging Remote Message -->> ',
        [new Date().getTime(), message, value]
      );
    }
  }
  
  // const rl = new RemoteLogger();
  // rl.sendMessage('Anything at all', {id: 4324});
  
  // Array of colours with the css values and their Bash equivalents
  const styles = {
    red: ['color: red', '\x1b[31m'],
    blue: ['color: blue', '\x1b[34m'],
    magenta: ['color: magenta', '\x1b[35m'],
    green: ['color: green', '\x1b[32m'],
    yellow: ['color: yellow', '\x1b[33m'],
    blue: ['color: blue', '\x1b[34m'],
    magenta: ['color: magenta', '\x1b[35m'],
    cyan: ['color: cyan', '\x1b[36m']
    white: ['color: white', '\x1b[97m'],
    reset: ['color: reset', '\x1b[0m']
  }
 
      // Logging function
      // This will be replaced by a more function example below
      function logger(useCss, logger, logMethod, color, message = '', value = null){
        let entry;
        console.log = logger[logMethod],
                style = styles[color];

        // Create an entry message (true = browser / false = server)
        if(useCss)
          entry = [`%c${message}`, entry[0]];
        else
          entry = [`${style[1]}${message}${styles['reset'][1]}`];

        // Log Message
        log.apply(logger, [...entry, value]);
        return value;
      }
      // Will return a blue message in the console
      // This can get difficult due to the number of arguments needed
      logger(false, console, 'log', 'blue', 'Anything', {id: 322})

