                    Webpack 2: The Complete Developer's Guide
                    Course Notes Part 8


9 - Chunk Hashing for Cache Busting
There is another change needed to the example
  - Vendor files don't update that often so caching can be used
  - Browsers often used cached versions of files
  - Chrome dev-tools has a section under settings which allows for caching to be disabled while dev-tools is open
    - While developing it may be better to not get a cached version of a file
Example Syntax
  // Webpack config file
  var webpack = require('webpack');
  var path = require('path');
  var HtmlWebpackPlugin = require('html-webpack-plugin');
  
  const VENDOR_LIBS = [
    'react', 'loadsh', 'redux', 'react-redux', 'react-dom', 'faker', 'react-input-range', 'redux-form', 'redux-thunk'
  ]
  
  module.exports = {
    entry: {
      bundle: './src/index.js',
      vendor: VENDOR_LIBS
    },
    output: {
      path: path.join(__dirname, 'dist'),
      // Using the chunk hash which is a hash of the file contents
      // Everytime the file changes the hash will too
      filename: '[name].[chunkhash].js'
    },
    module: {
      rules: [
        {
          use: 'babel-loader',
          test: /\.js$/,
          exclude: /node_modules/
        },
        {
          use: ['style-loader', 'css-loader],
          test: /\.css$/
        },
      ]
    },
    plugins: [
      new webpack.optimize.CommonsChunkPlugin({
        // Webpack has some issues when changes are made to bundle and puts them in vendor
        // changing to using an array of names fixes that gotcha
        names: ['vendor', 'manifest']
      }),
      new HtmlWebpackPlugin({
        template: 'src/index.html',
      })
    ]
  }

10 - Cache Busting Wrapup
Hashes depend on the contents of the file, any changes will change the hassh
  - This is what busts the cache 
Example Syntax
  - Just adding a console.log('hi');
  - This is just an example so as to force a bundle.js rebuild which will change hash
  - Script tags from the HTMLWebpackPlugin are automatically updated, including the hash

11 - Cleaning Project Files
By default you will get multiple bundle and manifest files as they are not overwritten when rebuilt
Installing a module to help take care of this issue
  - npm install --save-dev rimraf
  - Rimraf takes care of command inconsistencies between OSX and Windows
    - The rm command which removes files is not available on Windows
Example Syntax
  // Editing the package.json file
  {
  "name": "upstar_music",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    // If we run npm clean it will run rimraf on the directory dist
    "clean": "rimraf dist",
    // This ensure that files are removed and then rebuilt so no duplicates
    "build": "npm run clean && webpack"
  },
  "repository": "https://github.com/StephenGrider/WebpackProject",
  "author": "",
  "license": "ISC",
  "dependencies": {
    "faker": "^3.1.0",
    "lodash": "^4.17.2",
    "react": "15.4.1",
    "react-dom": "15.4.1",
    "react-input-range": "^0.9.2",
    "react-redux": "^4.4.6",
    "react-router": "^3.0.0",
    "redux": "^3.6.0",
    "redux-form": "^6.3.2",
    "redux-thunk": "^2.1.0"
  },
  "devDependencies": {
    "babel-core": "^6.17.0",
    "babel-loader": "^6.2.0",
    "babel-preset-env": "^1.1.4",
    "babel-preset-react": "^6.16.0",
    "css-loader": "^0.26.1",
    "style-loader": "^0.13.1",
    "webpack": "2.2.0-rc.0"
  }
}
  


                    Section 6 – Webpack Dev Server
1 - Introduction to Webpack Dev Server
There are some React specific optimisations available
This section will understand how webpack fits into app architecture
  - It is impractical to manually start webpack each time so the sction will cover webpack in a server based world
At the moment running webpack will genreate
  - bundle.js
  - vendor.js
  - index.html
The main idea behind the section is to use another library called webpack-dev-server
  - It is an intermediary between webpack and the browser
  - webpack-dev-server will take the 3 generated files and automatically open the index.html instead of manually doing it
  - webpack-dev-server will only need to be started once
    - It automatically rebuilds and only changes the files that have been changed
  - webpack-dev-server is about clientside application
    - There is no real opportunity to add logic to webpack server
    - This is unlike a traditional server setup on for example NodeJS
      - There is not DB\Auth tasks that can be added
      - Later in the course there will be more information on integrating a more traditional tooling setup 

2 - Gotchas with Webpack Dev Server
Install webpack-dev-server as an npm dependency
  // Use the @ symbol for specific versions of packages
  - npm install --save-dev wepack-dev-server@2.2.0-rc.0
Example Syntax
  // Package.json 
  "scripts": {
    "clean": "rimraf dist",
    "build": "npm run clean && webpack",
    // Adding a new script to run webpack-dev-server
    "serve": "webpack-dev-server"
  }
  // npm run serve should now be the command used to start the project
  // runs on localhost:8080 by default
  // webpack-dev-server does not watch for changes to webpack config file
  // ctrl+c to close 
  // When running webpack-dev-server it will internally run webpack
    - It stops webpack from saving any files to the project directory
    - This means that nothing is saved to the hard drive
      - To get a portable version of the project you have to run webpack by itself
    - webpack-dev-server keeps files in memory
    - webpack-dev-server has tools that are highly recommended by the instructor
    


                    Section 7 – React-Specific Topics
1 - React Router with Codesplitting
2 - Plain Routes with React Router Codesplitting



                    Section 8 – Webpack-Based Deployment for Static Sites
1 - Deployment Options
This is the section where the focus switches from using webpack in development to using it to deploy projects
By default Webpack pumps out static assets only
  - Static normally is anything not served by a dynamic webserver
Some sites that can be used for static sites are
  - GitHub pages, Amazon S3, Digital Ocean, MS Azure, Surge
Sites that are used for dyanmic pages
  - Amazon EC2, ELB, Digital Ocean, Heroku, Azure

2 - Getting Production Ready
The remainder of the section will be focused on deploying to several different targets
  - There are a couple of minor changes need

3 - Deployment with Surge (Easiest!)
The Surge site is located at tbeh following url
  - https://surge.sh

4 - Deployment with Github Pages
Github Pages is located at - https://pages.github.com
  - It is a fantastic deployment option because its free
  - It is a very stable platform due to being backed by a company like GitHub
  - It is also one of the easier options for deployment

5 - Deployment with AWS S3



                      Secion 9 – Webpack-Based Deployment for Dynamic Sites
1 - Deployment of Servers
This is the beginning of the section on deploying the app where there is a a server involved
Servers include
  - rails, django, .net and node
There are 2 main ways for structuring deployment
  - The first method is to put together 2 separate addresses
    - Eg www.app.com for the built application, www.api.app.com for the api requests
    - This is similar to the static deployment but with api calls added
    - This is how many large applications work
      - This is because of the performance gain in separating static and dynamic assets
  - The second method is to have a single resource that will both serve static assets but will also have API logic
    - One example is the node server which will be used on the users side as well as having business logic
    - This is significantly more propular for smaller applications
      - This is because deployment is much easier
      - This is the architecture that the course examples will follow
      - We want in this case for Node to be 100% in charge of everything
      - This can be an issue with Webpack
        - This will make the use of a compatability layer necessary

2 - Node and Webpack Integration
Making Webpack and Node work together can be challenging, this is what this section will be about
  - This will be different depending whether its on the local macine or a remote host

3 - Webpack Middleware in Development
Wiring up the server.js file to ensure that it works correctly in development
Example Syntax
  const express = require('express');
  const webpackMiddleware = require('webpack-dev-middleware');
  const webpack = require('webpack');
  const webpackConfig = require('./webpack.config.js');
  
  app.use(webpackMiddleware(webpack(webpackConfig)));
  
  const app = express();
  app.listen(3050, () => console.log('listening'));

4 - Webpack Middleware in Production
The existing server.js file from above will be used in this example
  - It is good for development environments but needs work for production suitability
Example Syntax

5 - Deployment to Heroku
The Heroku platform is used by a lot of developers and is very popular
  - https://www.heroku.com
  - It has a free tier available
  - It is also one of the easiest sites to deploy an application to
  

6 - Deployment to AWS

7 - More on AWS Deployment

