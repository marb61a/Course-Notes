                    Node JS: Advanced Concepts
                    Course Notes

There is a complete set of notes for less advanced Node users at
  - https://github.com/marb61a/Course-Notes/blob/master/Web Development/NodeJS/Learn and Understand NodeJS


                    Section 1 - The Internals of Node
1 - How to Get Help
There are a few different ways of getting help from the instructor from the course
  - The recommended method is to use the discussion section on the course board

2 - Starting With Node Internals
The initials structure (which will be expanded as the course develops) of Node is
  - JavaScript code the we write 
    ↳ Node
      ↳ V8 or libuv   -- These are 2 of the most important internal parts of Node
      - Libuv is C++ based and gives access to the filesystem, networking etc
      - V8 is a browser engine for running code
The purpose of NodeJS is to save JS developers writing C++
  - It also provides wrappers and consistent API's which have libuv code

3 - Module Implementations

4 - Node Backed by C++!

5 - The Basics of Threads
When running a program on a computer a process is started

6 - The Node Event Loop
The Event loop is used by Node to handle Aync code
  - When NodeJS starts up it creates a single thread
  - Within this thread lies the Event Loop
  - It is a control structure which decides what Node processes at any given time
  - It is the core of every Node program that is ran
  - Every single Node program ran has one Event Loop
  - A good understanding of how the Event Loop works is needed
    - This is a very difficult subjact to understand
  - Many performance issues can be traced back to Event Loop behaviour
 Example Syntax
  // Creating some pseudocode to illustrate Node's Event Loop
  // loop.js, the code is entirely fake
  
  // node myFile.js
    myFile.runContents();
    
    // Helper function to see if while loop should be executed again
    function shouldContinue(){
    
    }
    
    // In the Event Loop each execution of the while loop is called a tick
    while(shouldContinue()){
    
    }
    
  // exit back to terminal  

7 - The Event Loop Implementation
Continuing with the pseudo example from above
Example Syntax


8 - Event Loop Ticks

9 - Is Node Single Threaded?

10 - Testing for Single Threads

11 - The Libuv Thread Pool

12 - Threadpools with Multithreading

13 - Changing Threadpool Size

14 - Common Threadpool Questions
There are a few common threadpool questions which need to be answered
  Q - Can the threadpool be used for our JS code or can only Node functions use it
  A - Custom JS that has been written can use the threadpool
  
  Q - What functions that are in the Node standard library use the threadpool
  A - This will depend in parts on the OS being used but in general all Filesystem (fs) functions & some crytpography functions
  
  Q - How does the threadpool fit in with the event loop
  A - Using the example code the threadpool tasks running are the pendingOperations 
  
15 - Explaining OS Operations

16 - Libuv OS Delegation

17 - OS/Async Common Questions

18 - Review
A quick breather and review of the material covered

19 - Crazy Node Behavior

20 - Unexpected Event Loop Events



                    Section 2 – Enhancing Node Performance
1 - Enhancing Performance
There are some large performance hits when doing a lot of work inside the Event Loop
  - There are some strategies available to mitigate these and improve performance
    - Run Node inside cluster mode
      - This will start up multiple copies of Node
      - By running multiple copies of Node there are multipl copies of the Event Loop
      - This is the recommended approach
    - Use worker threads
      - These will use the threadpool set up by libuv 
      - This is an experimental approach

2 - Express Setup
Example Syntax
  // Setting up a simple Express server

3 - Blocking the Event Loop

4 - Clustering in Theory

5 - Forking Children

6 - Clustering in Action

7 - Benchmarking Server Performance

8 - Benchmark Refactor

9 - Need More Children!

10 - PM2 Installation

11 - PM2 Configuration

12 - Webworker Threads

13 - Worker Threads in Action

14 - Benchmarking Workers



                    Section 3 – Project Setup
1 - The Next Phase

2 - Project Walkthrough

3 - Key Customization

4 - MongoDB Creation

5 - Routes Walkthrough



                    Section 4 – Data Caching with Redis
1 - MongoDB Query Performance

2 - Query Caching Layer

3 - Redis Introduction

4 - Installing Redis on MacOS

5 - Redis on Windows

6 - Getting and Setting Basic Values

7 - Redis Hashes

8 - One Redis Gotcha

9 - Cache Keys

10 - Promisifying a Function

11 - Caching in Action

12 - Caching Issues

13 - The Ultimate Caching Solution

14 - Patching Mongoose's Exec

15 - Restoring Blog Routes Handler

16 - Unique Keys

17 - Key Creation

18 - Restoring Redis Config

19 - Cache Implementation

20 - Resolving Values

21 - Hydrating Models

22 - Hydrating Arrays

23 - Toggleable Cache

24 - Cache Expiration

25 - Forced Cache Expiration

26 - Nested Hashes

27 - Clearing Nested hashes

28 - Automated Cache Clearing with Middlware



                    Section 5 – Automated Headless Browser Testing
1 - Testing Flow

2 - Testing Challenges

3 - Commands Around Testing

4 - First Jest Test

5 - Launching Chromium Instances

6 - Chromium Navigation

7 - Extracting Page Content

8 - Puppeteer - Behind the Scenes

9 - DRY Tests

10 - Browser Termination

11 - Asserting OAuth Flow

12 - Asserting URL Domain

13 - Issues with OAuth

14 - Solving Authentication Issues with Automation Testing

15 - The Google OAuth Flow

16 - Inner Workings of Sessions

17 - Sessions From Another Angle

18 - Session Signatures

19 - Generating Sessions and Signatures

20 - Assembling the Pieces

21 - WaitFor Statements

22 - Factory Functions

23 - The Session Factory

24 - Assembling the Session Factory

25 - Code Separation

26 - Global Jest Setup

27 - Testing Factory Tests!

28 - Adding a Login Method

29 - Extending Page

30 - Introduction to Proxies

31 - Proxies in Action

32 - Combining Object Property Access

33 - Combining the Page and Browser

34 - Custom Page Implementation

35 - Function Lookup Priority

36 - Gee, I Hope This Works!

37 - Reusable Functions on Page

38 - Testing Blog Creation

39 - Default Navigation

40 - Asserting Form Display

41 - Test Timeout

42 - Common Test Setup

43 - Nested Describes for Structure

44 - Asserting Validation Errors

45 - Asserting Form Confirmation

46 - Asserting Blog Creation

47 - Options for Testing Prohibited Actions

48 - Direct API Requests

49 - Executed Arbitrary JS in Chromium

50 - Asserting Page Response

51 - Get Restrictions

52 - A Final 'GET' Test

53 - Super Advanced Test Helpers



                    Section 6 – Wiring Up Continuous Integration
1 - Introduction to CI

2 - CI Providers

3 - The Basics of YAML Files

4 - Travis YAML Setup

5 - More Travis YAML

6 - Client Builds

7 - Script Config

8 - Using Travis Documentation

9 - More Server Configuration

10 - Note - Travis Update

11 - A Touch More Configuration

12 - Git Repo Setup

13 - Travis CI Setup

14 - Triggering CI Builds

15 - Build Success



                    Section 7 – Scalable Image/File Upload
1 - Image Upload

2 - Big Issues Around Image Upload

3 - Alternate Image Upload

4 - Chosen Storage Solution

5 - Upload Constraints

6 - Image File Transport

7 - Upload Flow with AWS S3

8 - Details of the Presigned URL

9 - Security Issues Solved with Presigned URL's

10 - Adding an Image Picker

11 - Handling File Changes

12 - Recording Image Files

13 - The SubmitBlog Function

14 - AWS Credentials with IAM

15 - Creating S3 Buckets

16 - Allowing Actions with IAM Policies

17 - Creating IAM Users

18 - Upload Routes Files

19 - Configuring the AWS SDK

20 -GetSignedURL Arguments

21 - Calling GetSignedURL

22 - Viewing the Signed URL

23 - Attempting Image Upload

24 - Handling CORS Errors
05:20
Outstanding Issues
01:39
S3 Bucket Policies
05:01
Tying Uploads to Blogs
04:18
Ensuring Images get Tied
02:01
Displaying Images
04:06
Bonus!
00:44
