                    Node JS: Advanced Concepts
                    Course Notes

There is a complete set of notes for less advanced Node users at
  - https://github.com/marb61a/Course-Notes/blob/master/Web Development/NodeJS/Learn and Understand NodeJS


                    Section 1 - The Internals of Node
1 - How to Get Help
There are a few different ways of getting help from the instructor from the course
  - The recommended method is to use the discussion section on the course board

2 - Starting With Node Internals
The initials structure (which will be expanded as the course develops) of Node is
  - JavaScript code the we write 
    ↳ Node
      ↳ V8 or libuv   -- These are 2 of the most important internal parts of Node
      - Libuv is C++ based and gives access to the filesystem, networking etc
      - V8 is a browser engine for running code
The purpose of NodeJS is to save JS developers writing C++
  - It also provides wrappers and consistent API's which have libuv code

3 - Module Implementations

4 - Node Backed by C++!

5 - The Basics of Threads
When running a program on a computer a process is started

6 - The Node Event Loop
The Event loop is used by Node to handle Aync code
  - When NodeJS starts up it creates a single thread
  - Within this thread lies the Event Loop
  - It is a control structure which decides what Node processes at any given time
  - It is the core of every Node program that is ran
  - Every single Node program ran has one Event Loop
  - A good understanding of how the Event Loop works is needed
    - This is a very difficult subjact to understand
  - Many performance issues can be traced back to Event Loop behaviour
 Example Syntax
  // Creating some pseudocode to illustrate Node's Event Loop
  // loop.js, the code is entirely fake
  
  // node myFile.js
    myFile.runContents();
    
    // Helper function to see if while loop should be executed again
    function shouldContinue(){
    
    }
    
    // In the Event Loop each execution of the while loop is called a tick
    while(shouldContinue()){
    
    }
    
  // exit back to terminal  

7 - The Event Loop Implementation
Continuing with the pseudo example from above
Example Syntax


8 - Event Loop Ticks

9 - Is Node Single Threaded?

10 - Testing for Single Threads

11 - The Libuv Thread Pool

12 - Threadpools with Multithreading

13 - Changing Threadpool Size

14 - Common Threadpool Questions
There are a few common threadpool questions which need to be answered
  Q - Can the threadpool be used for our JS code or can only Node functions use it
  A - Custom JS that has been written can use the threadpool
  
  Q - What functions that are in the Node standard library use the threadpool
  A - This will depend in parts on the OS being used but in general all Filesystem (fs) functions & some crytpography functions
  
  Q - How does the threadpool fit in with the event loop
  A - Using the example code the threadpool tasks running are the pendingOperations 
  
15 - Explaining OS Operations

16 - Libuv OS Delegation

17 - OS/Async Common Questions

18 - Review
A quick breather and review of the material covered

19 - Crazy Node Behavior

20 - Unexpected Event Loop Events



                    Section 2 – Enhancing Node Performance
1 - Enhancing Performance
There are some large performance hits when doing a lot of work inside the Event Loop
  - There are some strategies available to mitigate these and improve performance
    - Run Node inside cluster mode
      - This will start up multiple copies of Node
      - By running multiple copies of Node there are multipl copies of the Event Loop
      - This is the recommended approach
    - Use worker threads
      - These will use the threadpool set up by libuv 
      - This is an experimental approach

2 - Express Setup
Example Syntax
  // Setting up a simple Express server

3 - Blocking the Event Loop

4 - Clustering in Theory

5 - Forking Children

6 - Clustering in Action

7 - Benchmarking Server Performance

8 - Benchmark Refactor

9 - Need More Children!

10 - PM2 Installation

11 - PM2 Configuration

12 - Webworker Threads

13 - Worker Threads in Action

14 - Benchmarking Workers



                    Section 3 – Project Setup
1 - The Next Phase

2 - Project Walkthrough

3 - Key Customization

4 - MongoDB Creation

5 - Routes Walkthrough



                    Section 4 – Data Caching with Redis
1 - MongoDB Query Performance

2 - Query Caching Layer

3 - Redis Introduction

4 - Installing Redis on MacOS

5 - Redis on Windows

6 - Getting and Setting Basic Values

7 - Redis Hashes

8 - One Redis Gotcha

9 - Cache Keys

10 - Promisifying a Function

11 - Caching in Action

12 - Caching Issues

13 - The Ultimate Caching Solution

14 - Patching Mongoose's Exec

15 - Restoring Blog Routes Handler

16 - Unique Keys

17 - Key Creation

18 - Restoring Redis Config

19 - Cache Implementation

20 - Resolving Values

21 - Hydrating Models

22 - Hydrating Arrays

23 - Toggleable Cache

24 - Cache Expiration

25 - Forced Cache Expiration

26 - Nested Hashes

27 - Clearing Nested hashes

28 - Automated Cache Clearing with Middlware



                    Section 5 – Automated Headless Browser Testing
1 - Testing Flow

2 - Testing Challenges

3 - Commands Around Testing

4 - First Jest Test

5 - Launching Chromium Instances

6 - Chromium Navigation

7 - Extracting Page Content

8 - Puppeteer - Behind the Scenes

9 - DRY Tests

10 - Browser Termination

11 - Asserting OAuth Flow

12 - Asserting URL Domain

13 - Issues with OAuth

14 - Solving Authentication Issues with Automation Testing

15 - The Google OAuth Flow

16 - Inner Workings of Sessions

17 - Sessions From Another Angle

18 - Session Signatures

19 - Generating Sessions and Signatures

20 - Assembling the Pieces

21 - WaitFor Statements

22 - Factory Functions

23 - The Session Factory

24 - Assembling the Session Factory
03:03
Code Separation
06:22
Global Jest Setup
07:00
Testing Factory Tests!
03:41
Adding a Login Method
05:01
Extending Page
07:58
Introduction to Proxies
07:46
Proxies in Action
12:10
Combining Object Property Access
08:17
Combining the Page and Browser
08:37
Custom Page Implementation
04:16
Function Lookup Priority
04:26
Gee, I Hope This Works!
05:32
Reusable Functions on Page
05:38
Testing Blog Creation
04:53
Default Navigation
05:30
Asserting Form Display
05:59
Test Timeout
05:23
Common Test Setup
05:07
Nested Describes for Structure
07:00
Asserting Validation Errors
07:39
Asserting Form Confirmation
06:25
Asserting Blog Creation
05:57
Options for Testing Prohibited Actions
03:32
Direct API Requests
11:44
Executed Arbitrary JS in Chromium
03:54
Asserting Page Response
07:24
Get Restrictions
02:44
A Final 'GET' Test
02:56
Super Advanced Test Helpers



                    Section 6 – Wiring Up Continuous Integration
1 - Introduction to CI

2 - CI Providers

3 - The Basics of YAML Files

4 - Travis YAML Setup

5 - More Travis YAML

6 - Client Builds

7 - Script Config

8 - Using Travis Documentation

9 - More Server Configuration

10 - Note - Travis Update

11 - A Touch More Configuration

12 - Git Repo Setup
04:18
Travis CI Setup
02:15
Triggering CI Builds
02:48
Build Success
01:18
–
Scalable Image/File Upload
02:20:33
Image Upload
02:15
Big Issues Around Image Upload
04:40
Alternate Image Upload
03:33
Chosen Storage Solution
04:17
Upload Constraints
04:26
Image File Transport
06:04
Upload Flow with AWS S3
05:22
Details of the Presigned URL
06:47
Security Issues Solved with Presigned URL's
04:15
Adding an Image Picker
03:30
Handling File Changes
04:39
Recording Image Files
04:38
The SubmitBlog Function
03:07
AWS Credentials with IAM
05:08
Creating S3 Buckets
03:16
Allowing Actions with IAM Policies
08:17
Creating IAM Users
04:41
Upload Routes Files
05:14
Configuring the AWS SDK
03:18
GetSignedURL Arguments
10:06
Calling GetSignedURL
09:35
Viewing the Signed URL
02:17
Attempting Image Upload
07:59
Handling CORS Errors
05:20
Outstanding Issues
01:39
S3 Bucket Policies
05:01
Tying Uploads to Blogs
04:18
Ensuring Images get Tied
02:01
Displaying Images
04:06
Bonus!
00:44
