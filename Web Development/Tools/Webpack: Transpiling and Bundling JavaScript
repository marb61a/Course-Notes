                    Webpack: Transpiling and Bundling JavaScript
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A brief introduction to both the course and the instructor



                    Section 2 - What Is Webpack?
1 - Welcome
Webpack can be considered as both a compiled and a bundler
A quick introduction to the section 

2 - Interactive Coding with Hot Module Replacement
Webpack has many benefits, one of these is Hot Module Reload (HMR)
  - This is a much more interactive way of cding instead of code, compile, wait and reload
This example will be making use of the Vue.js framework
  - Sudents can follow along by using the vue-cli tool and following the instructions on the home page

3 - Seamless Compilation
There is a seamless ability to integrate other build tools
  - This means there is a seamless compilation of anything, code, images, styles etc
  - Tools that can be included are Babel, Typescript, CSS tools etc

4 - Consistent Tooling

5 - Modularity

6 - Benefit - Bundling for Performance

7 - Sophisticated Bundling

8 - npm Install, Import, Go!

9 - Help with Caching

10 - Source Maps Through Any Number of Transformations

11 - A Compiler Platform

12 - Course Series and Updates
This course is set to be part of a series, info is available on the GitHub repo
  - https://github.com/g0t4/optimizing-web-apps-webpack
  - The next parts of the series will deal with advanced toopics including optimising bundles



                    Section 3 - Bundling Code
1 - Cloning and Starting the Solitaire App

2 - The Legacy Solitaire App Structure

3 - Performance Problems in the Solitaire App

4 - Bundling app.js

5 - Inspecting and Using the App Bundle

6 - IIFEs Are No Longer Necessary

7 - Migrating a Second Module to the Bundle

8 - Webpack Polyfills Module Loading

9 - Webpack Polyfills Use Strict for Harmony Modules

10 - Learning from Webpack Source Code

11 - Generating an Interactive Graph of Modules

12 - Challenge



                    Section 4 - Accelerating Development
1 - Benefits of Watch and WDS

2 - Watch Mode

3 - Installing webpack-dev-server

4 - npm run-scripts for Documenting Webpack Commands

5 - Composing npm Scripts
There are extensive notes on composing and using npm scripts at
  - https://github.com/marb61a/Course-Notes/blob/master/Web Development/NodeJS/How To Use NPM Scripts As Your Build Tool

6 - Adding a webpack.config.js File

7 - devServer.contentBase - Set Location of Static Content on Disk

8 - devServer.publicPath - Set Base URL to Serve Webpack Output

9 - devServer.watchContentBase - Reload on Static File Changes

10 - Webpack Configuration Documentation

11 - Looking Under the Hood of the DevServer

12 - Hot Module Replacement Overview

13 - devServer.hot and the HotModuleReplacementPlugin

14 - Reload Fallback

15 - Automatic Restart After Changing webpack.config.js

16 - Disable Reload Fallback

17 - output.publicPath

18 - Identifying Modules by Name with the NamedModulesPlugin

19 - Hot Swapping Methods in a Live Application

20 - Hot Swapping Can Maintain State

21 - Inspecting Hot Updates

22 - Recap
A brief recap on what the section covered



                    Section 5 - Dev Isn't Prod
1 - Intro
Introduction to what will be covered in the forthcoming section

2 - HMR Plugin Bloats Production Builds

3 - Conditionally Adding Plugins with NODE_ENV Environment Variable

4 - cross-env and dotenv Help with Cross-platform Env Vars

5 - Using a CLI Argument to Set the Environment

6 - Environment Option Uses yargs

7 - Multiple and Named Configurations

8 - Modularizing Config Files

9 - webpack-merge to Merge Configuration Objects

10 - Inspecting the Merged Configuration and Config Defaults

11 - Conditional Code with the DefinePlugin

12 - Careful to Quote String Constants

13 - Passing Env Options or Variables Through to Code Constants

14 - Touch-ups and Recap
A brief recap on what the section covered



                    Section 6 - Transpiling: Using the Future Now
1 - Intro
Introduction to what will be covered in the forthcoming section

2 - Installing Relevant Babel Packages

3 - Why @babel/preset-env

4 - Using ES6 Class Syntax

5 - Adding a babel-loader Rule

6 - webpack-dev-server Adds Modules to the Bundle

7 - Excluding node_modules from babel-loader

8 - Adding @babel/preset-env to Transform Classes

9 - Do Not Transform Harmony Imports and Exports

10 - devServer.overlay - Showing Compilation Errors in the Browser

11 - Understanding Browserslist Queries

12 - Extracting .babelrc.js

13 - babel-loader Works with .babelrc.js Too

14 - Disabling babel-loader in Development Builds

15 - How to Tell babel-loader to Ignore .babelrc

16 - Polyfills

17 - Webpack Runtime Uses Promises That Might Need to Be Polyfilled

18 - devServer.host - Configuring External Access to WDS

19 - Enable Transpilation in Development as Needed

20 - Fix Polyfill Issues by Reproducing the Problem

21 - Webpack Makes Using npm Packages Facile

22 - Studying the Impact of @babel/polyfill

23 - Testing the Promise Polyfill

24 - Reducing Polyfills with core-js

25 - Reducing Polyfills to Just Promise

26 - You Don't Need to Manually Triangulate Polyfills

27 - useBuiltIns: 'entry' - Polyfill Based on Target Browsers

28 - Changing Browser Query Changes Polyfills

29 - useBuiltIns: 'usage' - Polyfill Based on Target Browsers and Usage

30 - Using the Promise Built-in Adds Another Polyfill for

31 - Someday: @babel/plugintransform-runtime + @babel/preset-env

32 -Takeaways
Quick review of the section and some lessons that students should takeaway from the section



                    Section 7 - Understanding Loaders
1 - What Is a Loader?

2 - Designing a tee-loader

3 - Creating a tee-loader

4 - resolveLoader.alias to Resolve a Custom Loader

5 - Logging Request and Source per Module

6 - Collapsing Grouped Webpack Console Output with Chrome DevTools

7 - Debugging Webpack with Chrome DevTools

8 - Adding the Same Loader Twice

9 - Passing and Parsing Options in the tee-loader

10 - Legacy Option Passing via a Query String

11 - Inline Loaders Are Occasionally Useful

12 - Learn More by Building Loaders - Try a Pitching Cache Loader



                    Section 8 - Running Build Tasks
1 - What About Build Tasks?

2 - Cleaning the Output Folder Before Bundling

3 - Not Just Build Tasks: npm-install-webpack-plugin

4 - Finding Plugins for Common Build Tasks



                    Section 9 -Troubleshooting with Source Maps
1 - Bundling and Transpiling Make Troubleshooting Difficult

2 - Runtime Errors Aren't as Transparent as Compilation Errors

3 - Enabling Source Maps with devtool: "source-map"

4 - How devtool: "source-map" Works

5 - Fast, Inline, Partial Source Maps - devtool: "eval"

High Quality Maps with Fast Incremental Rebuild - devtool: "eval-source-map"5m 21s
devtool: "hidden-source-map"3m 45s
Only Map Location and Filename, Not Source Code - devtool: "nosources-source-map"1m 34s
Resources3m 45s
devtool Is Just an Idiosyncratic, String Based Serialization of Plugin Options6m 53s
Add the SourceMapDevToolPlugin Directly for Flexibility Instead of Using devtool3m 12s



                    Section 10 - Generating Code
1 - Challenge: Building a codegen-loader to Capture Build Information

Explanation of the Starting Point to My Solution4m 9s
My Solution8m 9s
The End0m 59s

