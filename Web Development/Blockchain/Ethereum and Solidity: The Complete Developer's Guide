                    Ethereum and Solidity: The Complete Developer's Guide
                    Course Notes 


                    Section 1 - What is Ethereum?
1 - Introduction
A brief introduction to the course, what it will cover etc
There is also a brief into to the instructor

2 - Link to Github Repo
A link to the GitHub repo with code from the course

3 - A Short History Lesson
A brief history of the evolution of the Ethereum\Blockchain technology
  - The first paper came in 2008, Oct31st and was associated with Bitcoin
  - Unlike other tech fields an understanding of the evolution is worthwhile
  - The white paper described a peer to peer payment system without a bank
  - In Dec 2013 there was another white paper which was the basis of Ethereum

4 - Link to Original Bitcoin White Paper
A link to the original academic white paper for Bitcoin

5 - What is Ethereum?
This is the first discussion of many about Ethereum
  - This will develop during the course
  - Ethereum networks are used to both transfer money and store data
  - There are many different Ethereum networks 
  - Networks are formed by one or more nodes
  - Each node is a machine running an Ethereum client
  - Anybody can run a node
  - Each node can contain a full copy of the blockchain
  - The blockchain is a database that stores a record of all the transaction that has taken place

6 - Interfacing with Ethereum Networks
There are a few different ways to connect to the networks
There are a couple of main groups of technologies
  - For developers, the course will use Web3.js for developing apps
  - For consumers, there are 2 solutions which will be used in the course
    - Metamask which is a Chrome plugin
    - Mist Browser which is a full featured browser which will be able to browse different Ethereum applications

7 - Metamask Setup
Installing and configuring the Chrome metamask extension
  - This will be used to both interface with the Ethereum network and also the course apps
  - This is installed using the Web Store on the Chrome browser
  - Clicking on the Fox icon on the address bar will open the extension
  - There are some notices etc to be gone through and the accepted
  - After this the user will be prompted for a passwrod which will create and account on the Ethereum network
  - This will allow a user to send and receive money as well as deploy smart contract that they create
  - The course will create many different accounts
  - This will give some random words which will need to be saved as they are the only way an account can be restored
  - These 12 words are a mnemonic that are generated when the vault is created
  - After this is the main screen, the Main Network is the default network 
  - The main network is the real network which is used by the public when purchasing
  - There are several test networks listed
  - The course will use the Rinkeby-Test network
  - Doing stuff on the main network will cost real money
  - The localhost 8545 is used usually when hosting an ethereum node or a local test network
  - A lot of development is done on localhost
  - The custom RPC allow for connection to a custom remote network

8 - Ethereum Accounts
When Metamask created an account it created 3 distinct pieces of information
  - An account address
    - This is an account identifier and is similar to an email address, telling people who you are
  - A public key
  - A private key
    - These 2 pieces for something akin to a password
    - They are used to authorise transferring funds from your account to another account
  - All three values are in Hexidecimal format
    - Using the Dev-Tools entering a hex number into the JS console will be converted to base 10 and returned
    - Guessing a private key is almost impossible due to the size of the value
  - Unlike email addresses on different providers, 1 account is used across all networks

9 - Receiving Ether
Using the Rinkeby-Faucet example site
  - http://www.rinkeby-faucet.com
  - This is a test network to demonstrate the process of receiving and sending ether
To view address
  - On the Metamask window click ...
  - Select copy address to clipboard
  - Paste into the submit box and submit
  - Coin transfer is not immediate

10 - What's a Transaction?
Going to other networks will show a balance of 0
  - Other networks live in their own universe
The process that was gone through is as follows
  - Click submit on form 
  - Address sent to backend server
  - The backend server created a transaction object 
    - A transaction is record of one account trying to send money to another
      - The transaction object has several properties
        - Nonce -- How many times the sender has sent a transaction
          - Nonce is short for nonsense in this case
        - To -- The address of the account the money is going to
        - Value -- The amount of ether to send to the target address
        - GasPrice -- The amount the sender is willing to pay per unit gas to get this transactin processed
        - StartGas/GasLimit -- Units of gas that this transaction can consume
        - v/r/s -- Cryptographic pieces of data that can be used to generate the senders accoun address

11 - Why'd We Wait?
Finishing off the flow from the previous video
  - The backend server then sent the transaction to the Rinkeby test network
  - The backend server then waited for the transaction to be confirmed
    - The blockchain can be very complicated, this is an aside to why there was a wait for transaction confirmation
    - The systems are not complicated for the sake of it but it is needed for the transfer of large amounts of money
    - The transaction does not go straigh to the network, it goes to a node which communicates with the node
    - The Node has a copy of the entire blockchain
    - A list of transaction assembled by a node is called a block
    - The validation logic ran against the block is responsible for the delay
      - This validation logic is more properly called mining in crypto currency circles
  - The backend server then sent a success message back to the browser

12 - A Quick Note

13 - Basic Blockchains
A video demonstrating Blockchains from Anders
  - https://anders.com/blockchain/
There is a quick demo of SHA 256 hash
  - No matter the amount of information the hash length stays the same
A blockchain is basically a chain of blocks as defined previous
  - Each block points to the previous one
  - The longer the chain the harder to make changes which need to be remined
  - Looking at the hash value can tell when there has been remining

14 - Block Time
The definition used in the previous video example was a very generic blockchain
  - For example having a leading 4 zeros is not strictly true
  - What we are really looking for is a hash less than some target value
  - Hashes are 64 bit long which means values can be from 0 - 1.15 x 10^77
  - The time it takes to hash everything from 0 to the nonce value is called block time
  - Solutions when found will take extra time while the solutions are sent to other nodes
  - The Ethereum network has a target blocktime of 15 seconds
  - Raising a target value can help it be found quicker
  - There is a demo time chart recommended by the course instructor
    - https://etherscan.io/chart/blocktime
    - This shows block times over a couple of years

15 - Smart Contracts
This will be the main topic of the course
  - A Smart Contract can be thought of as an account controlled by code
  - This code will tell the Smart Contract how to behave
There are several different properties contained within a Smart Contract account
  - These are different from the account properties previously discussed
    - Balance -- The amount of Ether that this account owns
    - Storage -- Data storage for this contract
    - Code -- Raw machine code for this contract
Accounts that we create are referred to as External Accounts
  - Contract Accounts are specific to a network and cannot be accessed across networks
The process for Contract Accounts
  - Contract Source is created on our computer
  - It is deployed on to the network
  - When deployed it creates a Contract Instance or Contract Account
  - One contract source can be deployed to multiple networks
  - It can also be deploed multiple time to the same network
  
16 - The Solidity Programming Language
Solidity was invented specifically for writing Smart Contracts
It is written in .sol files
  - Nearly all editors work with Solidity
The language itself is strongly typed
It is similar to JavaScript from a syntax point of view
There are several very large gotchas
Contracts tend to be quite small
  - Being an expert is not necessary it is usually the app code around the contract that takes more time
The way that Solidity contracts are executed on the network is
  - The Contract Definition will be fed into a Solidity compiler
  - The compiler generates 2 separate files
    - Byte code ready for deployment
    - ABI -- The application binary interface which will be an interface for working with the Bytecode

17 - Our First Contract
This will use an online code editor called Remix
  - https://remix.ethereum.org/
  - This is an IDE specifically for Solidity & Testing Contracts
  - There will be an example file with code, delete the code so that there is no code left
Example Syntax
  // This is the first contract 
  pragma solidity ^0.4.17;

  contract Inbox {
    // This is an instance variable of type string
    // public is the visibility level which means that it can be seen inside and outside the file
    string public message;
    
    function Inbox(string initialMessage) public {
      message = initialMessage;
    }
    
    function setMessage(string newMessage) public {
      message = newMessage;
    }
    
    function getMessage() public view returns (string){
      return message;
    }
  }

18 - Contract Structure
Understanding the code from the previous video
  - pragma solidity ^0.4.17; 
    - This is the version of Solidity that the contract is written in
    - This is to stop version mixmatch issues
  - contract Inbox {}
    - This defines a contract and is similar to classes in other languages
    - This will have variables and functions
  - string public message;
    - Declare all storage (instance) variables that will exist in the contract
      - The course will mostly use storage variables but occasionally local variables
    - The variable type will also be declared
    - The public field shows the visibility of the variable and who has access
  - function Inbox(string initialMessage) public {}
    - This shows the different functions that will be members of the contract
    - This particular function is a constructor function, the name of the function is the same as the contract
    - Constructor functions are called automatically 1 time at contract creation

19 - Function Declarations
This is a continuation of the previous example
  - This use the getMessage function from the example
  - getMessage is the function name
  - getMessage did not take arguments, setMessage however took a string as an argument
  - public view is the function type and these will change from function to function
    - There are a variety of words that can be used here
    - These words are called the function type declaration
    - The most common ones are as follows
      - public -- Anyone can call this function
        - By anyone it is anyone with an Ethereum account
      - private -- Only this contract can call this function
      - view -- This function returns data and does not modify the contract's data
      - constant -- This function returns data and does not modify the contract's data
        - This can be used interchangibly with view which is a more modern replacement
      - pure -- This function will not modify or even read the contract's data
        - This is not likely to be used that often
      - payable -- When someone calls this function they may send Ether
  - returns (string) is the return type of the function
    - These are only ever used on function marked view or constant

20 - Testing with Remix
Using the remix tool to test our code
  - Remix is not just an IDE it also hosts a minature fake Ethereum network
  - This is where our example code will be deployed to after compilation to bytecode
  - We can simultate not only deploying but also interacting with our code
  - The remix tool itself has several windows
    - At the bottom-left is the console window that describes what is happening on the in browser network
    - On the right is a window with several tabs
      - On the environment tag check the environment setting
        - It should not be Injected Web3, if needed change to JavaScriptVM
        - This tells Remix that we want to use the in-browser Ethereum network for deployment
      - When the setting on environment has been changed there will be several dummy accounts created
        - Each of these will have 100 ether added to them
        - These account only exist within the browser
      - The value setting is used to send some Ether with the transaction
      - There will be a dropdown box beneath these settings, 
        - At this stage inbox is selected as this is the contract to be deployed
      - The input will match the constructor function 
        - In the example this is a string, type something into the create box and use double quotations
      - Clicking create will generate contract pending in the console window, 
        - Below the create box there will also be another dropdown box added
        - This represents a contract that has been deployed to the network
        - It is an instance of the contract and the buttons represent the functions in the contract
      - Blue buttons represent view\constant functions and will immediately returns data
      - Red buttons represent functions that will modify the contract
      - Values dont automatically update
      - When you create storage variables, if it is marked with a Public keyword
        - The contract will automatically create a new function for you which will have the same name as the variable
        - This makes some get functions superfluous

21 - Redeploying Contracts
Using the existing example from the previous couple of sections
  - The getMessage() function can be deleted due to the behaviour of the storage variables
  - This will mean that the contract will need to be redeployed
  - Modifying the code does not automatically modify test contract instances
  - Clicking on the x will delete the contract instance from memory
  - Deleting old contract instances when redeploying is recommended
  - Adding a new value to the create box will create an updated contract which reflects the current code base

22 - Behind the Scenes of Deployment
What happens during the process of deployment
  - Creating a new contract is very similar to the process of transferring money
  - There are only small differences from the transaction account discussed previously
  - The main difference between a money sending contract and contract creation transaction is that the to field is blank
  - When you write a contract and deploy it to a network the compiled bytecode is available for everyone to see
    - This means that there is no security so no sensitive material is present

23 - More on Running Functions Than You Want to Know
There is a rule which should be followed when changing any data on the blockchain
  - You should do this by submitting a transaction
  - This should apply everytime
  - When the transaction had been submitted you should wait for approval before continuing
  - There are 2 ways that functions are invoked that belong to contracts
    - These 2 different ways will result in very different behaviour
    - Calling a function -- Cannot modify contract data, can return data, runs instantly, free to do
    - Sending a transaction to a function -- Can modify contract data, takes time to execute, Returns the transaction hash, costs money
  - Most tutorials only use test networks which is not realistic
    - There will be time needed to process transactions whereas on local test networks they are instantaneous

24 - Wei vs Ether
Sending a transaction to a function costs some amount of Ether
The value dropdown on the run tab in Remix has 4 different values
  - Wei, Gwei, Finney, Ether
  - These are units of measurement
  - Think of $1 versus 100 cent -> they are the same just a different measurement
  - 1 Ether == 1,000,000,000,000,000,000 Wei
  - There is no fractional unit of Wei
  - There are many different tools for converting Wei values to Ether
    - https://etherconverter.online
  - There are multiple names available for the sub-ether units

25 - Gas and Transactions
The Gas system is meant to measure how much work is done by code
  - Anytime a contract is sent to the Ethereum network there is a Gas price attached
Example Syntax
  // Reusing the previous example but updating to demonstrate Gas
  // Each operation in the function will cost some Gas to run
  // There is a publicly available spreadsheet which will show Gas cost per operation
  //   - https://docs.google.com/spreadsheets/d/1n6mRqkBz3iWcOlRem_mO09GtSKEKrAsfO7Frgx18pNU/edit#gid=0
  pragma solidity ^0.4.17;

  contract Inbox {
      string public message;

      function Inbox(string initialMessage) public {
        message = initialMessage;
      }

      function setMessage(string newMessage) public {
        message = newMessage;
      }

      function doMath(int a, int b){
          a + b;
          b - a;
          a * b;
          a == 0;
      }
  }

26 - Mnemonic Phrases
At the present moment in the course we only have one account with Metamask
  - This is ok for the present but may present issues further down the line
  - You may have separate account for different items eg Business, Savings etc
  - This is where the 12 word mnemonic comes in
    - This allows us to generate a series of accounts
    - Each of these has a different public key, private key and address
    - This was what we were given when first registering for a Metamask account 
    - This uses the BIP mnemonic algorithm
    - To create an account just click create account
    - This adds another of a series of pregenerated accounts
    - To generate a new mnemonic it is needed to reinstall Metamask
    - There is no ability to reset Metamask to generate a new mnemonic
    - Save the new mnemonic securely
There is a tool which demonstrates the series of accounts being generated
  - https://iancoleman.io/bip39/
  - This is a mnemonic code converter
  - This shows a table which shows all accounts generated from the single 12 word mnemonic
  - Creating an account in Metamask will correspond to the values in this table

27 - Getting More Ether



                    Section 2 – Smart Contracts with Solidity
The project Github Repo for this section is                    
  - https://github.com/marb61a/Ethereum-inbox
  
1 - Don't Skip! Node JS Versioning

2 - Contract Deployment

3 - Boilerplate Requirements
To set up the boilerplate project
  - Ensure that NodeJS is installed
  - It is better to have a directory for projects so create one
  - Make a directory especially for this project and change into it
  - Use the npm init command to add the NPM package manager to the project
  - Accept all defaults that are asked and the project should have a package.json file
  - There is not definitive IDE recommended but Atom is used in the example
    - https://atom.io

4 - Project File Walkthrough

5 - Syntax Highlighters

6 - Compiling Solidity

7 - The Compile Script

8 - Testing Architecture

9 - Running Windows?

10 - Installing Modules

11 - Web3 Versioning

12 - Web3 Providers

13 - Testing with Mocha

14 - Mocha Structure

15 - Fetching Accounts from Ganache

16 - Refactor to Async/Await

17 - Deployment with Web3

18 - Deployed Inbox Overview

19 - Asserting Deployment

20 - Web3 Version Fix

21 - Verifying the Initial Message

22 - Testing Message Updates

23 - Deployment with Infura

24 - Infura Signup

25 - Wallet Provider Setup

26 - Deployment to Rinkeby

27 - Observing Deployment on Etherscan

28 - Deployed Contracts in Remix

29 - Project Review



                    Section 3 – Advanced Smart Contracts
1 - The Lottery Contract

2 - Lottery Design

3 - Basic Solidity Types

4 - Starting the Lottery Contract

5 - The Message Global Variable

6 - Overview of Arrays

7 - Overview of Mappings and Structs

8 - Big Solidity Gotcha

9 - Entering the Lottery

10 - Validation with Require Statements

11 - The Remix Debugger

12 - Psuedo Random Number Generator

13 - Selecting a Winner

14 - Sending Ether from Contracts

15 - Resetting Contract State

16 - Requiring Managers

17 - Function Modifiers

18 - Returning Players Array

19 - Contract Review

20 - New Test Setup

21 - Test Project Updates

22 - Test Helper Review

23 - Asserting Deployment

24 - Entering the Lottery

25 - Asserting Multiple Players

26 - Try-Catch Assertions

27 - Testing Function Modifiers

28 - End to End Test



                    Section 4 – Building Interactive Front-Ends
1 - Ethereum App Architecture

2 - Application Overview

3 - Getting Started with Create-React-App

4 - Multiple Web3 Instances

5 - Web3 Setup

6 - Deploying the Lottery Contract

7 - Local Contract Instances

8 - Rendering Contract Data

9 - Instance Properties

10 - Accessing More Properties

11 - The 'Enter' Form

12 - Form Setup

13 - Entering the Lottery

14 - Picking a Winner

15 - Project Review



                    Section 5 – Real Projects with Ethereum
1 - Solving Real Problems with Contracts

2 - Fixing Kickstarter's Issues

3 - Campaign Contract Design

4 - Campaign Constructor

5 - Contributing to the Campaign

6 - A Quick Test

7 - The Request Struct

8 - More on Function Modifiers

9 - Creating Struct Instances

10 - Instance Creation Syntax

11 - Storage and Memory

12 - More on Storage vs Memory

13 - Voting System Requirements

14 - The Wrong Voting System

15 - Issues with Arrays

16 - Mappings vs Arrays

17 - Basics of Mappings

18 - Refactoring to Mappings

19 - Refactoring Request Stucts

20 - More on Struct Initialization

21 - Approving a Request

22 - Testing Request Approvals

23 - Finalizing a Request

24 - Last Remix Test

25 - Thinking about Deployment

26 - Solution to Deployment

27 - Adding a Campaign Factory

28 - Testing the Factory



                    Section 6 – Ethereum Project Infrastructure
1 - Project Setup

2 - Directory Structure

3 - A Better Compile Script

4 - Single Run Compilation

5 - More on Compile

6 - Test File Setup

7 - Creating Campaign Instances

8 - Testing Warmup

9 - Accessing Mappings

10 - Requiring Minimum Contributinos

11 - Array Getters

12 - One End to End Test

13 - Deployment

14 - Refactoring Deployment



                    Section 7 – Advanced Multi-Page Front-Ends
1 - App Mockups

2 - CRA vs Next

3 - Next's Pages Architecture

4 - Basics of Next Routing

5 - Root Routes

6 - CampaignFactory Instance

7 - Getting a Test Campaign

8 - Fetching Deployed Campaigns

9 - Why Next.js, Anyways?

10 - Server vs Client Web3 Instances

11 - GetInitialProps Function

12 - Semantic UI React

13 - Card Group Setup

14 - Rendering Card Groups

15 - Adding CSS

16 - Adding a Button

17 - The Need for a Layout

18 - The Layout Component

19 - Assembling a Header

20 - Constraining Content Width

21 - Two Column Layout

22 - Nested Routing

23 - Final CSS Fix

24 - Form Creation

25 - Input Change Handlers

26 - Form Submittal

27 - Testing Submittal

28 - Form Error Handling

29 - Button Spinners

30 - Routing Issues

31 - Next Routes Setup

32 - Automatic Navigation

33 - Header Navigation

34 - Routing to Campaigns

35 - Restarting the Server

36 - Route Mappings

37 - Planning CampaignShow

38 - Redeploying CampaignFactory

39 - CampaignShow's GetInitialProps

40 - Accessing a Campaign

41 - Summary Translation Layer

42 - Custom Card Groups

43 - One Card Per Property

44 - The Contribute Form

45 - Grid Layouts

46 - Form State

47 - Communicating the Campaign Address

48 - Making a Contribution

49 - Refreshing Contract Data

50 - Spinners and Error Handlers

51 - Listing Requests

52 - Grids vs Columns

53 - More Routing!

54 - Request Creation Form

55 - Creating a Request

56 - Form Polish

57 - Creating a Request

58 - Requests One by One

59 - Fancy Javascript

60 - Small Typo!

61 - Rendering a Table

62 - Request Row Component

63 - Request Row Content

64 - Approvers Count Cell

65 - Approving a Request

66 - Finalizing Requests

67 - Testing Finalization

68 - Row Status Styling

69 - Finishing Requests Index

70 - Wrapup
A brief wrapup of the section

