                    Unit Testing Vuex
                    Course Notes
                    
 
1 - Introduction 
The course will cover Unit Testing several components in Vuex
  - Getters, Mutations and Actions
  - Mocking function calls inside of actions too will be looked at
  - Mocking API calls to avoid hitting the database will also be covered
The goal of the course is to have a fully tested app by the end of the course
  - There will be a focus of decoupling as much as possible from view components
  - This will leave them to call actions and handle UI updates
  - The concepts covered will help when testing apps of any size

2 - Development setup
The setup of the project for the course
  - The initial project is available to be downloaded
To setup a Vue project with the webpack template
  - vue init webpack projectname
  - Some errors may mean using vue-init rather than vue init
  - Set the basic options and answer Y to the setting up testing
  - Set no to e2e tests
  - cd into the project and npm install
  - Run npm run test to set up the tests
  - Json Server will be used for providing a fake API
    - https://github.com/typicode/json-server
    - npm install -g json-server
  - You will need to create a db.json file
  - To create a server
    - json-server --watch db.json
    - This will run on localhost:3000
Example Syntax
  // db.json
  {
    // This will create a tasks endpoint 
    "tasks": []
  }
It is safer to unit test Vuex than touch the database

3 - Basic getter and mutation tests 
First focus will be on the getter and mutator
  - This allows for keeping track of what is type into the input box in the sample app
  - It works the same as when you would use v-model
  - It directly writes as the user updates to state
  - This decouples what is input from the component
  - It also makes testing easier

Example Syntax
  // Setting up the store for the rest of the course
  // store/state.js
  export default {
    // This will differ in larger applications, the instructor suggests
    // you have a different store for each module you are working with
    // then though it might seem like overkill it will keep everything separate
    // and make testing easier
    
    // This is because there is only a single task, if there were more you could
    // create a form object with each field or section
    task: {
      body: null
    }
    
  }
  
  // store/mutations.js
  export const setTaskBody = (state, body) => {
    state.task.body = body
  }

4 - More on getters and mutations

5 - Store task action

6 - Testing actions

7 - Mocking API calls and Axios

8 - Flash message TDD

9 - Testing dispatching actions

10 - Task getter tests

11 - Finishing up with deleting tasks
