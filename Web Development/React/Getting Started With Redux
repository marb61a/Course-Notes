                    Getting Started With Redux
                    Course Notes
                    

1 - Redux: The Single Immutable State Tree
The main principle of Redux is that no matter the complexity of your applications you will
represent the state of your application in a single Javascript Object
The example uses a counter which may be added to or subtracted from
  - There is also an option for adding additional counters
Example Syntax
  // This represents the state object and each item added to the todos is added as an object in the empty array
  [object Object] {
    todos: [],
    visibilityFilter: 'SHOW_ALL'
  }
In Redux the state is also referred to as the state tree

2 - Describing State Changes with Actions
The second principle of Redux is that the state tree is read-only
  - Any time that you wish to change this tree you need to dispatch an action
  - An action is a plain JS object describing the change
  - The structure of the app is up to each developer
    - The only requirement is that you have a type property which is not undefined
    - The use of strings is recommended as they are serializable

3 - Pure And Impure Functions
It is important to understand the difference between pure and impure functions
  - Some functions is Redux have to be pure
Example Syntax
  // Pure functions
  // Functions are pure when their return values depend solely on their arguments
  function square(x){
    return x * x;
  }
  function squareAll(items){
    return items.map(square);
  }
  
  // Impure functions
  function square(x){
    updateXInDatabase(x);
    return x * x;
  }
  function squareAll(items){
    for(let i = 0; i < items.length; i++){
      items[i] = square(items[i]);
    }
  }

4 - The Reducer Function
The UI is most predicatable when described as a pure function of the application state
  - This approach originated with React but has spred to other frameworks
  - Redux adds on to this idea with the notion that state mutations in an app need to be described as a pure function
    - This takes the previous state and the action being disatched are returns the next state of your application
  - Inside any redux application there is one function that takes the whole application state and action being dispatched
  and returns the whole next state of the application
  - It is important that it does not modify the state given to it
  - It has to be pure so it has to return a new object
  - This is the third and final priciple of redux
  - This function is called the reducer function

5 - Writing a Counter Reducer with Tests
Example Syntax
  // This will be the reducer function for the counter example
  function counter(state, action){
    // The convention in Redux is that if the reducer receives undefined as the state argument
    // it must return what it considers to be the initial state of the application
    if(typeof state === 'undefined'){
      return 0;
    }
    
    if(action.type === 'INCREMENT'){
      return state + 1;
    } else if(action.type === 'DECREMENT'){
      return state - 1;
    } else {
      // To handle unknown clauses
      return state;
    }
  }
  
  // The same function as above with a switch case and default arguments replacing a condition
  const counter = (state = 0, action) => {
    switch(action.type){
      case 'INCREMENT'
        return state + 1;
      case 'DECREMENT'
        return state - 1;
      default
        return state;
    }
  }
  
  // Using the expect library for assertions
  expect(counter(0, { type: 'INCREMENT'})).toEqual(1);
  expect(counter(1, { type: 'INCREMENT'})).toEqual(2);
  expect(counter(2, { type: 'DECREMENT'})).toEqual(1);
  expect(counter(1, { type: 'DECREMENT'})).toEqual(0);
  
  // This will cause an error in the tests unless there is a return
  // that will handle unknown clauses
  expect(counter(1, { type: 'Something Else'})).toEqual(1);
  
  // The app needs to have an initial state, if it does not then the test will fail
  expect(counter(undefined, { })).toEqual(0);
  
  console.log('Tests Passed');

6 - Store Methods: getState(), dispatch(), and subscribe()
The example used has React imported from a cdn
  - It is the UMD build which exports a single global variable called Redux
  - It is not recommended by the instructor in real apps who recommends using npm, webpack, browserify etc
Example Syntax
  const counter = (state = 0, action) => {
    switch(action.type){
      case 'INCREMENT'
        return state + 1;
      case 'DECREMENT'
        return state - 1;
      default
        return state;
    }
  }
  
  // Built in Redux function
    const { createStore } = Redux;
  // The store holds together the 3 principles of redux
   const store = createStore(counter);
  // Will be 0 at the beginning as the state is set to 0 at the method definition
    console.log(store.getState());
  // This is the most commonly used store method
  // It allows for actions to be disatched which will change the state of the application
    store.dispatch({type: 'INCREMENT'});
  // As the the increment has been dispatched the state will have changed
    console.log(store.getState());
  
  // This allows for a callback to be registered that the reduc store will call anytime an action has been dispatched
  // this allows for UI update to reflect application state, render in the example has to be passed into subscribe
  // in this example as the initial state will not fire so it is passed in and called immediately
  const render = () => {
    document.body.innerText = store.getState();
  }
  
  store.subscribe(render);
  render();
  
  document.addEventListener('click', () => {
    store.dispatch({type: 'INCREMENT'})
  })

7 - Implementing Store from Scratch
Example Syntax
  // Example will implement a store function from scratch
  const counter = (state = 0, action) => {
    switch(action.type){
      case 'INCREMENT'
        return state + 1;
      case 'DECREMENT'
        return state - 1;
      default
        return state;
    }
  }
  
  const createStore = (reducer){
    // Hold state is an variable
    let state;
    // Because the subscribe function can be called many time it will need to be tracked
    let listeners = [];
    
    const getState = () => state;
    const dispatch = (action) => {
      state = reducer(state, action);
      listeners.forEach(listener => listener());
    };
    const subscribe = (listener) => {
      listeners.push(listener);
      // Instead of a dedicated unsubscribe method
      // This removes the listener from the listeners array
      return () => {
        listeners = listeners.filter(l => l !== listener)
      }
    }
    
    // create a dummy dispatch to fire initial state
    // this is very similar to the createStore that ships with Redux
    dispatch({});
    
    return {getState, dispatch, subscribe};
  }
  const store = createStore(counter);
  
  const render = () => {
    document.body.innerText = store.getState();
  }
  
  store.subscribe(render);
  render();
  
  document.addEventListener('click', () => {
    store.dispatch({type: 'INCREMENT'})
  })

8 - React Counter Example
Example Syntax
  // The existing approach from previous examples does not scale well to applications
  // Instead of manually updating the DOM the example will use React instead
  // The necessary scripts and div's are added to the html file
  const counter = (state = 0, action) => {
    switch(action.type){
      case 'INCREMENT'
        return state + 1;
      case 'DECREMENT'
        return state - 1;
      default
        return state;
    }
  }
  
  const { createStore } = Redux;
  const store = createStore(counter);
  
  // Dumb component as it contains no logic
  const Counter = ({ value, onIncrement, onDecrement }) => (
    <div>
      <h1>{value}</h1>
      <button onCLick={onIncrement}>+</button>
      <button onCLick={onDecrement}>-</button>
    </div>
  )
  
  const render = () => {
    ReactDOM.render(
      <Counter value={store.getState()}
        onIncrement={
          store.dispatch({
            type: 'INCREMENT'
          })
        }
        onDecrement={
          store.dispatch({
            type: 'DECREMENT'
          })
        }
      />,
      document.getElementById('root');
    )
  }
  
  store.subscribe(render);
  render();

9 - Avoiding Array Mutations with concat(), slice(), and ...spread

10 - Avoiding Object Mutations with Object.assign() and ...spread

11 - Writing a Todo List Reducer (Adding a Todo)

12 - Writing a Todo List Reducer (Toggling a Todo)

13 - Reducer Composition with Arrays

14 - Reducer Composition with Objects

15 - Reducer Composition with combineReducers()

16 - Implementing combineReducers() from Scratch

17 - React Todo List Example (Adding a Todo)

18 - React Todo List Example (Toggling a Todo)

19 - React Todo List Example (Filtering Todos)

20 - Extracting Presentational Components (Todo, TodoList)

21 - Extracting Presentational Components (AddTodo, Footer, FilterLink)

22 - Extracting Container Components (FilterLink)

23 - Extracting Container Components (VisibleTodoList, AddTodo)

24 - Passing the Store Down Explicitly via Props

25 - Passing the Store Down Implicitly via Context

26 - Passing the Store Down with <Provider> from React Redux

27 - Generating Containers with connect() from React Redux (VisibleTodoList)

28 - Generating Containers with connect() from React Redux (AddTodo)

29 - Generating Containers with connect() from React Redux (FooterLink)

30 - Extracting Action Creators
