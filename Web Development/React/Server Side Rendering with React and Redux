                    Server Side Rendering with React and Redux
                    Course Notes


                    Section 1 - Getting Started
1 - A Few Notes
A quick welcome to the course
Some administration work prior to getting started on the technical part of the course

2 - Link to Github Repo
A link is provided to the course repo which contains
  - All the source code from the course
  - Slides and diagrams that are used in the course

3 - Why Server Side Rendering?
A quick discussion of what Server Side Rendering solves
Tradional React Apps are rendered on the client-side in the browser
There is a vanilla React app generated in order to demonstrate client-side rendering in React
The procedure for a client side rendered app is
  - Brower requests a page
  - Then the browser requests a js file
  - Finally there is some content visible on the page
  - Each step will  have a time period between them
  - These time periods can be hugely problematic
  - Longer periods have been proven to cost websites traffic and businesses money 

4 - SSR Overview
The previous example had a fairly sparse html file
  - Now the html has a fair amount of code in the file
  - The example also uses a free code formatterto make the html more legible
    - https://www.freeformatter.com/html-validator.html
  - Traditional react apps fetch a file with basically a script tag inside
  - SSR will however have a lot of content inside the html format
  - Sending a fully rendered html page can have effects
    - One major effect is the simplification of the process of rendering a page
    - Page load times are also much quicker
  - SSR is fundamentally about getting content on page quicker
  - The instructor uses a diagram to demonstrate SSR flow
    - In the browser
      - The user navigates.app.com
    - On the server
      - The request is received
      - The React app is loaded in memory
      - Any required data is fetched
      - Render the React app
      - Send the generated HTML to the user



                    Section 2 – Let's Get Coding!
1 - App Overview
Writing code will better teach concepts than just discussing concepts
The app is very simple but is 100% focused on SSR
  - The styling etc is not exciting but is not meant to be
  - It will however teach you about the important challenges in SSR
  - Loading data techniques are important in this course not app functionality

2 - Server Architecture Approach
The app architecture involves
  - 2 separate running backends
    - This is an approach highly recommended by the instructor for SSR apps
    - There is an API server which is already built
    - There is a rendering server which will be built during the course
  - The reason for running 2 separate backends is that there are 2 distinct and different requirement
    - The API server will take the business logic and application layer
      - This covers DB access, Validation, Logging, Authentication and Authorisation
      - This only needs to produce JSON
    - The rendering server will cover the view layer
      - This covers producing HTML from the data taken in
      - This can in the future be replaced by Angular, Ember etc if needed
  - By splitting the backend there is a much easier path when scaling in the future
React running on a server is slow, focus on performance will take a lot of resources
  - The rendering server is likely to be a bottleneck so may need additional and faster instances

3 - Starter Package.Json File
A text file with dependencies needed added
  - This can just be copied to the package.json file when npm is set up and installed

4 - Boilerplate Setup
The package.json file from the previous section will be reused ot start the project
  - This is used to avoid any versioning conflicts which may take place
  - Use npm install to install the dependencies (there are a large number of them!!)

5 - Express Setup
Create a new express server and listen on port 3000
Example Syntax
  // src/index.js
  const express = require('express');
  const app = express();
  
  app.get('/', (req, res) => {})
  
  app.listen(3000, () => {
    console.log('Listening on port 3000');
  })
  
  // src/client/components/Home.js
  import React from 'react';
  
  const Home = () => {
    return <div>I'm the home component</div>
  }
  
  export default Home;

6 - The RenderToString Function
To turn the home component into HTML that can be sent down to the browser
  - The react-dom library will be used
  - This library has the renderToString function
  

7 - JSX on the Server

8 - Server Side Webpack

9 - Breather and Review
A quick review of the material covered thus far



                    Section 3 - Server Configuration
1 - Rebuilding and Restarting

2 - Server Side Rendering, Isomorphic Javascript, Universal Javascript
Server-side Rendering refers to our ability to generate HTML on the server side and then ship it down to the browser
  - This can be done without React
  - HTML templates like Handlebars can be used on the server
  - This is also sometimes called Server-Side templating
Universal JavaScript and Isomorphic JavaScript are essentially the same thing
  - It means that the same code is ran on the server and the browser
  - The instructor of the course is against some of the nomenclature involved

3 - Client Side JS

4 - Client Bundles

5 - The Public Directory
A this stage there are 2 separate bundles being created 
  - 1 each for server and client
  - However the client bundle is still not getting downloaded by the browser
  - To rectify this the public directory must be made available

6 - Why Client.js?

7 - Client Bootup



                    Section 4 – Refactoring for Cleaner Code
1 - Merging Webpack Config

2 - Single Script Startup

3 - Ignoring Files with Webpack

4 - Renderer Helper



                    Section 5 – Adding Navigation
1 - Implementing React Router Support

2 - BrowserRouter vs StaticRouter

3 - Route Configuration

4 - HTML Mismatch

5 - More on Route Configuration

6 - Routing Tiers



                    Section 6 – Integrating Support for Redux
1 - The Users API

2 - Four Big Challenges

3 - Browser Store Creation

4 - Server Store Creation

5 - FetchUsers Action Creator

6 - The Users Reducer

7 - Reducer Imports

8 - UsersList Component

9 - Babel Polyfill



                    Section 7 – Server Side Data Loading
1 - Detecting Data Load Completion

2 - Solution #1 for Data Loading

3 - Solution #2 for Data Loading

4 - The React Router Config Library

5 - Updating Route Uses

6 - The MatchRoutes Function

7 - LoadData Functions

8 - Store Dispatch

9 - Waiting for Data Load Completion

10 - Breather and Review



                    Section 8 – Organization with Page Components
1 - The Page Approach

2 - Refactoring to Pages

3 - Refactoring Page Exports

4 - Client State Rehydration

5 - More on Client State Rehydration

6 - Dumping State to Templates

7 - Mitigating XSS Attacks



                    Section 9 – Authentication in a Server Side Rendering World
1 - Authentication Issues

2 - Authentication via Proxy

3 - Why Not JWT's?

4 - Proxy Setup

5 - Renderer to API Communication

6 - Axios Instances with Redux Thunk

7 - Client Axios Instance

8 - Server Axios Instance

9 - The Header Component

10 - Adding an App Component

11 - Building the Header

12 - Fetching Auth Status

13 - Calling FetchCurrentUser

14 - Connecting the Header

15 - Header Customization

16 - Header Styling



                    Section 10 – Error Handling
1 - 404 Not Found Pages

2 - Implementing the NotFound Page

3 - StaticRouter Context

4 - The Admin Feature

5 - Admins Action Creator and Reducer

6 - Admins Route Component

7 - Testing Admins Route

8 - Promise.all Failures

9 - Error Handling Solution #1

10 - Error Handling Solution #2

11 - Error Handling Solution #3

12 - The Require Auth Component

13 - Implementing Require Auth

14 - Require Auth in Use

15 - Handling Redirects



                    Section 11 - Adding Better SEO Support
1 - Meta Tags
Using Twitter feed to demonstrate meta-tags

2 - Setting Tags with Helmet

3 - React Helmet in Practice

4 - Dynamic Title Tags

5 - RenderToString vs RenderToNodeStream



                    Section 12 - Wrapup
1 - Next Steps and Wrapup
A brief run through and wrap up of what the course covered
  - Also some next steps for the student are suggested
  
