                    Webpack 2: The Complete Developer's Guide
                    Course Notes


                    Section 1 – How to Use This Course
1 - Start Here!
Quick intro to the course

2 - Links to Github Repos
There are a couple of different repos to link to 
  - Sample Project Code At -- https://github.com/StephenGrider/WebpackProject
  - Complete Code -- https://github.com/StephenGrider/WebpackCasts
Do not get the two confused


                    Section 2 – What Does Webpack Do?
1 - Why Do We Use Build Tools?
Why is Webpack becoming so popular?
Rich Web Applications - Web apps that have a lot of dynamic features
To understand Webpack popularity and why it is used it's necessary to understand the ecosystem
  - Server Side Templating
    - More of a legacy technology for creating web apps and showing HTML documents to users
    - In this world a backend server creates a HTML document and sends it to a user
    - The process is
      - User Visits Page -> HTTP Request To Server -> New HTML Doc -> User Clicks A Link -> HTTP Request To Server -> New HTML Doc
  - Single Page Application
    - This contrasts with the Server Side Templating world
    - The server in this case sends a bare boned HTML document to the user
    - Javasript runs on the users machine to assemble a webpage
    - The process here is
      - User Visits Page -> HTTP Req To Server -> New HTML Doc -> React\Angular Shows Page ->
                              User Clicks A Link -> React\Angular shows new content
 Over the last couple of years Single Page Applications have become very popular
 The reason for Webpack is that in an SPA world there is a huge amount of JS being assembled in the users browser

2 - Javascript Modules
When you have a lot of Javascript there can be issues
Working on large code bases split between only a couple of large files can be challenging
To address this issue of JS the notion of modules
Instead of having a small number of large JS files there will be many small files in the modular world
There is a middle line between these approaches
There can be issue with a modular approach

3 - The Purpose of Webpack
When using modules you need to understand fully the necessary loading order for modules
Incorrect load order can cause a lot of different problems
Having many JS files to load can be bad for performance especially on mobile devices
The purpose of Webpack is to take the big collection of tiny JS modules and merge into a big JS file while ensuring
that the correct loading order is maintained
As a side benefit Webpack can handle css files and turning ES6 in ES5 

4 - Webpack in Action
To demonstrate Webpack there will be 2 small modules built and linked with Webpack
  Syntax
    - mkdir js_modules      // makes a new directory for the project
    - cd js_modules         // Change into the project directory
    - npm init              // Initialises the npm package manager in the project
    - ls                    // This will show the package.json file generated from the npm init, it will show dependencies
    - Create a new folder src to hold the 2 modules that will be created
    - Create index.js and sum.js inside the src folder

5 - Javascript Module Syntax
Sum.js - Its purpose is to provide utility function for working with mathematical calculations
Index.js - It calls functions from sum.js then prints the result
The index file will depend on the sum file
Syntax sum.js
  // The course willl be using ES6\2015 syntax 
  const sum = (a, b) => a + b;
  
The JS world has several differ rulesets for governing how modules behave
Some of the common module systems in place are
  - Common JS
    - Common syntax -- module.exports require
    - Implemented by node.js
  - AMD
    - Common syntax -- define, require
    - Ancronym for Asynchronous Module Definition
    - More commonly used in front end applications
  - ES2015
    - Common Syntax -- import, export
    - Modern web development is headed towards this

Syntax index.js

6 - Linking Files with CommonJS
Sum.js Syntax
  // Using CommonJS Syntax
  const sum = (a, b) => a + b;
  
  module.exports = sum;

Index.js Syntax
  const sum = require('./sum');
  
  const total = sum(10, 5);
  console.log(total);

7 - Webpack Installation and Configuration
There is a very specific version of Webpack used to install
  - npm install --save-dev webpack@2.2.0-rc.0
Webpack will need to be told which files to be used so a configuration file is put together to guide this process
  - The default name for the Webpack configuration file is webpack.config.js
  - When Webpack is run it will automatically look for a file of this name inside the project

Example webpack.config.js Syntax
  const config = {
    // Webpack cannot run the config file without an entry property
    // Traditionally in Webpack the entry point to an app is called index.js
    // The entry file forms the start of the module building process
    entry: './src/index.js'
  };
  
  module.exports = config;

8 - More on Webpack Configuration
Continuing with the example from the previous chapter
This time there will be the second of two compulsory properties
  - The output property

Example Syntax
  // Node helper for getting file path part of the node runtime
  const path = require('path');
  
  const config = {
    entry: './src/index.js',
    
    // The output property gives file name and path
    output: {
      // Output path must be full absolute path
      // Using path.resolve will allow it to generate path on any OS
      path: path.resolve(__dirname. 'build'),
      // By convention the output filename is usually bundle.js
      filename: 'bundle.js'
    }
  }
  
  module.exports = config;

9 - Running Webpack

10 - The Bundle.js File

11 - Running the App



                    Section 3 – Handling Project Assets
1 - Introduction to Loaders

2 - Babel Setup for ES2015

3 - Babel Configuration

4 - Refactor to ES2015 Modules

5 - Handling CSS with Webpack

6 - The Style and CSS Loaders

7 - Loaders are Tricky!

8 - The Extract Text Plugin

9 - Handling Images with Webpack

10 - Automatic Image Compression

11 - Public Paths



                    Section 4 – Building for Performance with Webpack
1 - Introduction to Code Splitting

2 - Codesplitting in Practice

3 - On Demand Code Loading

4 - System Import Calls



                    Section 5 – Applying Webpack to a Real Project
1 - A Real World Project

2 - Setting Up Babel

3 - Minimum Webpack Config

4 - Vendor Asset Caching

5 - More on Vendor Caching

6 - Refactoring for Vendor Splitting

7 - Effect of Code Splitting

8 - Troubleshooting Vendor Bundles

9 - Chunk Hashing for Cache Busting

10 - Cache Busting Wrapup

11 - Cleaning Project Files



                    Section 6 – Webpack Dev Server
1 - Introduction to Webpack Dev Server

2 - Gotchas with Webpack Dev Server



                    Section 7 – React-Specific Topics
React Router with Codesplitting
07:44
Plain Routes with React Router Codesplitting
10:44
–
Webpack-Based Deployment for Static Sites
35:20
Deployment Options
04:22
Getting Production Ready
07:44
Deployment with Surge (Easiest!)
03:55
Deployment with Github Pages
09:02
Deployment with AWS S3
10:17
–
Webpack-Based Deployment for Dynamic Sites
49:57
Deployment of Servers
05:02
Node and Webpack Integration
05:45
Webpack Middleware in Development
07:28
Webpack Middleware in Production
10:29
Deployment to Heroku
08:03
Deployment to AWS
07:16
More on AWS Deployment
05:54
