                    Docker and Kubernetes: The Complete Guide
                    Course Notes


                    Section 1 - Dive Into Docker!
1 - Why Use Docker?
A run through of the traditional software install process
  - This can be problematic and can need troubleshooting
    - The example used Redis which can be very difficult to install
    - The course will use Redis a lot
  - Docker eliminates or aims to eliminate this problem

2 - What is Docker?

3 - Docker for Mac/Windows

4 - Installing Docker on MacOS
Installation tutorial for installing Docker

5 - Docker Setup on Windows
Installation tutorial for installing Docker

6 - More Windows Setup

7 - One Last Piece of Windows Setup

8 - Using the Docker Client
 
9 - But Really...What's a Container?

10 - How's Docker Running on Your Computer?



                    Section 2 – Manipulating Containers with the Docker Client
1 - Docker Run in Detail

2 - Overriding Default Commands

3 - Listing Running Containers

4 - Container Lifecycle

5 - Restarting Stopped Containers

6 - Removing Stopped Containers

7 - Retrieving Log Outputs

8 - Stopping Containers

9 - Multi-Command Containers

10 - Executing Commands in Running Containers

11 - The Purpose of the IT Flag

12 - Getting a Command Prompt in a Container

13 - Starting with a Shell

14 - Container Isolation



                    Section 3 – Building Custom Images Through Docker Server
1 - Creating Docker Images

2 - Building a Dockerfile

3 - Dockerfile Teardown

4 - What's a Base Image?

5 - The Build Process in Detail

6 - A Brief Recap

7 - Rebuilds with Cache

8 - Tagging an Image

9 - Manual Image Generation with Docker Commit



                    Section 4 – Making Real Projects with Docker
1 - Project Outline

2 - Node Server Setup

3 - Server Code

4 - A Few Planned Errors

5 - Base Image Issues

6 - A Few Missing Files

7 - Copying Build Files

8 - Container Port Mapping

9 - Specifying a Working Directory

10 - Unnecessary Rebuilds

11 - Minimizing Cache Busting and Rebuilds



                    Section 5 – Docker Compose with Multiple Local Containers
1 - App Overview

2 - App Server Code

3 - Assembling a Dockerfile

4 - Introducing Docker Compose

5 - Docker Compose Files

6 - Networking with Docker Compose

7 - Docker Compose Commands

8 - Stopping Docker Compose Containers

9 - Container Maintenance with Compose

10 - Automatic Container Restarts

11 - Container Status with Docker Compose



                    Section 6 – Creating a Production-Grade Workflow
1 - Development Workflow

2 - Flow Specifics

3 - Docker's Purpose

4 - Project Generation

5 - More on Project Generation

6 - Necessary Commands

7 - Creating the Dev Dockerfile

8 - Duplicating Dependencies

9 - Starting the Container

10 - Quick Note for Windows Users

11 - Docker Volumes

12 - Bookmarking Volumes

13 - Shorthand with Docker Compose

14 - Overriding Dockerfile Selection

15 - Do We Need Copy?

16 - Executing Tests

17 - Live Updating Tests

18 - Docker Compose for Running Tests

19 - Shortcomings on Testing

20 - Need for Nginx

21 - Multi-Step Docker Builds

22 - Implementing Multi-Step Builds

23 - Running Nginx


                    Section 8 – Continuous Integration and Deployment with AWS
1 - Services Overview

2 - Github Setup

3 - Travis CI Setup

4 - Travis YML File Configuration

5 - A Touch More Travis Setup

6 - Automatic Build Creation

7 - AWS Elastic Beanstalk

8 - More on Elastic Beanstalk

9 - Travis Config for Deployment

10 - Automated Deployments

11 - Exposing Ports Through the Dockerfile

12 - Build Still Failing?

13 - Workflow With Github

14 - Redeploy on Pull Request Merge

15 - Deployment Wrapup

16 - Environment Cleanup



                    Section 9 – Building a Multi-Container Application
1 - Single Container Deployment Issues

2 - Application Overview

3 - A Quick Note

4 - Application Architecture

5 - Worker Process Setup

6 - Express API Setup

7 - Connecting to Postgres

8 - More Express API Setup

9 - Generating the React App

10 - Fetching Data in the React App

11 - Rendering Logic in the App

12 - Exporting the Fib Class

13 - Routing in the React App



                    Section 10 – "Dockerizing" Multiple Services
1 - Checkpoint Files

2 - Checkpoint Catchup

3 - Dockerizing a React App - Again!

4 - Dockerizing Generic Node Apps

5 - Adding Postgres as a Service

6 - Docker-compose Config

7 - Environment Variables with Docker Compose

8 - The Worker and Client Services

9 - Nginx Path Routing

10 - Routing with Nginx

11 - Building a Custom Nginx Image

12 - Starting Up Docker Compose

13 - Troubleshooting

14 - Troubleshooting Startup Bugs

15 - Opening Websocket Connections



                    Section 11 – A Continuous Integration Workflow for Multiple Images
1 - Production Multi-Container Deployments

2 - Production Dockerfiles

3 - Multiple Nginx Instances

4 - Altering Nginx's Listen Port

5 - A Quick Fix

6 - Cleaning Up Tests

7 - Github and Travis CI Setup

8 - Travis Configuration Setup

9 - Pushing Images to Docker Hub

10 - Successful Image Building



                    Section 12 - Multi-Container Deployments to AWS
1 - Multi-Container Definition Files

2 - Finding Docs on Container Definitions

3 - Adding Container Definitions to DockerRun

4 - More Container Definitions

5 - Forming Container Links

6 - Creating the EB Environment

7 - Managed Data Service Providers

8 - Overview of AWS VPC's and Security Groups

9 - RDS Database Creation

10 - ElastiCache Redis Creation

11 - Creating a Custom Security Group

12 - Applying Security Groups to Resources

13 - Setting Environment Variables

14 - IAM Keys for Deployment

15 - Travis Deploy Script

16 - Container Memory Allocations

17 - Verifying Deployment

18 - A Quick App Change

19 - Making Changes

20 - Cleaning Up AWS Resources



                    Section 13 - Onwards to Kubernetes!
1 - The Why's and What's of Kubernetes

2 - Kubernetes in Development and Production

3 - Setup on MacOS

4 - Mapping Existing Knowledge

5 - Adding Configuration Files

6 - Object Types and API Versions

7 - Running Containers in Pods

8 - Service Config Files in Depth

9 - Connecting to Running Containers

10 - The Entire Deployment Flow

11 - Imperative vs Declarative Deployments



                    Section 14 - Maintaining Sets of Containers with Deployments
1 - Updating Existing Objects

2 - Declarative Updates in Action

3 - Limitations in Config Updates

4 - Running Containers with Deployments

5 - Deployment Configuration Files

6 - Walking Through the Deployment Config

7 - Applying a Deployment

8 - Why Use Services?

9 - Scaling and Changing Deployments

10 - Updating Deployment Images

11 - Rebuilding the Client Image

12 - Triggering Deployment Updates

13 - Imperatively Updating a Deployment's Image

14 - Multiple Docker Installations

15 - Reconfiguring Docker CLI

16 - Why Mess with Docker in the Node?



                    Section 15 - A Multi-Container App with Kubernetes
1 - The Path to Production

2 - Checkpoint Files

3 - A Quick Checkpoint

4 - Recreating the Deployment

5 - NodePort vs ClusterIP Services

6 - The ClusterIP Config

7 - Applying Multiple Files with Kubectl

8 - Express API Deployment Config

9 - Cluster IP for the Express API

10 - Combining Config Into Single Files

11 - The Worker Deployment

12 - Reapplying a Batch of Config Files

13 - Creating and Applying Redis Config

14 - Last Set of Boring Config!

15 - The Need for Volumes with Databases

16 - Kubernetes Volumes

17 - Volumes vs Persistent Volumes

18 - Persistent Volumes vs Persistent Volume Claims

19 - Claim Config Files

20 - Persistent Volume Access Modes

21 - Where Does Kubernetes Allocate Persistent Volumes?

22 - Designating a PVC in a Pod Template

23 - Applying a PVC

24 - Defining Environment Variables

25 - Adding Environment Variables to Config

26 - Creating an Encoded Secret

27 - Passing Secrets as Environment Variables

28 - Environment Variables as Strings



                    Section 16 - Handling Traffic with Ingress Controllers
1 - Load Balancer Services

2 - A Quick Note on Ingresses

3 - One Other Quick Note!

4 - Behind the Scenes of Ingress

5 - More Behind the Scenes of Ingress

6 - Optional Reading on Ingress Nginx

7 - Setting up Ingress Locally

8 - Creating the Ingress Config

9 - Testing Ingress Locally

10 - The Minikube Dashboard



                    Section 17 - Kubernetes Production Deployment
1 - The Deployment Process

2 - Google Cloud vs AWS for Kubernetes

3 - Creating a Git Repo

4 - Linking the Github Repo to Travis

5 - Creating a Google Cloud Project

6 - Linking a Billing Account

7 - Kubernetes Engine Init

8 - Creating a Cluster with Google Cloud

9 - Don't Forget to Cleanup!

10 - Kubernetes Dashboard on Google Cloud

11 - Travis Deployment Overview

12 - Installing the Google Cloud SDK
05:44
Generating a Service Account
05:29
Running Travis CLI in a Container
09:17
Encrypting a Service Account File
07:54
More Google Cloud CLI Config
04:39
Running Tests with Travis
06:18
Custom Deployment Providers
03:49
Unique Deployment Images
08:33
Unique Tags for Built Images
07:47
Updating the Deployment Script
07:51
Configuring the GCloud CLI on Cloud Console
05:34
Creating a Secret on Google Cloud
02:24
Helm Setup
08:15
Kubernetes Security with RBAC
08:21
Assigning Tiller a Service Account
05:08
Ingress-Nginx with Helm
01:56
The Result of Ingress-Nginx
03:48
Finally - Deployment!
03:30
Did I Really Type That?
00:45
Verifying Deployment
05:20
A Workflow for Changing in Prod
04:29
Merging a PR for Deployment
01:01
That's It! What's Next?



                    Section 18 - HTTPS Setup with Kubernetes
1 - HTTPS Setup Overview

2 - Domain Purchase

3 - Domain Name Setup

4 - Cert Manager Install

5 - How to Wire Up Cert Manager

6 - Issuer Config File

7 - Certificate Config File

8 - Deploying Changes

9 - Verifying the Certificate

10 - Ingress Config for HTTPS

11 - It Worked!

12 - Google Cloud Cleanup

13 - Local Environment Cleanup

