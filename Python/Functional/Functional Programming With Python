                      Functional Programming With Python
                      Course Notes
                      
                      Section 1 - Introduction
1 - Introduction
A very quick run through of the syllabus
The course will be making use of Python libraries in the course including
  - Toolz -- A general purpose utility library for functional programming in Python
  - Pyrsistent -- Provides high-performance immutable data structures
  - Hypothesis -- Gives property based testing
  - Effect -- Allows for side effects in pure functions

2 - Libraries And Setting Up Our Environment
Author recommends using if you are not familiar with setting up python environment
  http://docs.python-guide.org/en/latest/

3 - About The Author
A quick biography of the author

4 - How to Access your Working Files
How to use the working files that came with the course



                      Section 2 - Functional Programming
1 - What is Functional Programming
Functional Programming is like it says programming functions
  - There is a difference between functions in imperative programming and functions as in Functional Programming
There are fewer classes, control flow primitives and mutations as functions can give the same power  
Functional programming comes from the mathematical idea of functions
A Side Effect is
  - Comes from non-mathematical functions
  - If has an effect on the state of the world
  - It is observable from outside
  - Functions without side effects are called pure functions
Example Syntax
  // This is a pure function
  def append2_a(l):
    return l + [2]
  
  // This function has a side effect
  def append2_b(l):
    l.append(2)
    return l
  
  l = [1]
  append2_a(l)
Code with side effects can be more difficult to maintain and debug
Some side effects are necessary
  - Read input interactively
  - Display things to the screev
  - Communicate over the network
  - You will need to sort out what is necessary and unnecessary

2 - Why Functional Programming
Using Functional Programming will probably change the way you think about programming
  - It is a new way of thinking about the problem you are solving
  - A lot of programmers like working with new technology and are better when happy

3 - First Class Functions
Python has a couple of important features which allow functional programming
  - Functions are first class values
    - This means that they can be passed around like any other value
  - Functions have closures
    - This means that they capture their environment
    - This means that their values get carried when the functions are passed around
      - Usually a variable in a function diappears when it is passed around but if an inner function
        references that variables then it will be atached to that function and go along with it
    - This is used quite a lot when using Python
Example Syntax
  def outer():
    x = 1
    def inner():
      return x
    return inner
    
  f = outer()
  assert f() == 1
  print "OK!!"
 
 - First class functions with closures are necessary to have meaningful abstraction

Python does miss some features that are available in other languages
  - A strong library of built-in pure functions
  - Efficient immutable data structures
  - Cheap recursion

4 - Recursion
Example Syntax
  def mysum(nums):
    if nums == []:
      // Where the function contains nothing there is no need to do further recursion
      // This is referred to as the base case
      return 0
    else:
      return nums[0] + mysum(nums[1:])
  
  // Because the mysum function is calling itself it is called recursion
  print mysum([1, 2, 3])

  def add1_all(nums):
    if nums = []:
      // In this base case there is an empty list returned 
      return []
    else:
      return [nums[0] + 1] + add1_all(nums[1:])
      
  print add1_all([1, 2, 3])
 
List concatenation is very inefficient and if a big enough input was received there could be a stack overflow
This is a more realistic example using a domain model of groups of people
  class Person(object):
    def __init__(self, name):
      self.name = name
  
  class Group(object):
    """Groups can contain Persons or more groups"""
    def __init__(self, members, subgroups):
      self.members = members
      self.subgroups = subgroups
  
  // The most natural idiommatic way in Python is still recursion to get all the members of a group
  def get_all_members(group):
    sub_members = []
    for subgroup in group.subgroups
      sub_members.extend(get_all_members(subgroup))
    return group.members + sub_members
  
  group = Group(['Sam', 'Jessie'], [Group(['Reese', 'Taylor'], [])])
  print get_all_members(group)

5 - Higher Order Functions
Good programmers will wish to type out abstractions so as to avoid typing the same patterns
Example Function
  // This rewrites the previous example
   def add1_all(nums):
      if nums = []:
        // In this base case there is an empty list returned 
        return []
      else:
        return [nums[0] + 1] + add1_all(nums[1:])
      
    print add1_all([1, 2, 3])
    
    def add2_all(nums):
      if nums = []:
        // In this base case there is an empty list returned 
        return []
      else:
        return [nums[0] + 2] + add2_all(nums[1:])

    print add2_all([1, 2, 3])

    //  This can be rewritten to avoid having to continually add more functions
    def mymap(f, l):
      if l == []
        return l
      return [f(l[0])] + mymap(f, l[1:])
      
      print mymap(lambda n: n+2, [1, 2, 3])
      
    // Using the my sum example
    def mysum(nums):
    if nums == []:
      return 0
    else:
      return nums[0] + mysum(nums[1:])
    
    def length(l):
      if l == []
        return 0
      else
        return 1 + length(l[1:])
    
    // The above functions can be extracted
    def map_and_add_nums(f, l):
      if l == []
        return 0
      else
        return f(l[0]) + map_and_add-nums(f, l[1:])
    
    print "Sum", map_and_add_nums(lambda n: n, [1, 2, 3])
    print "Length", map_and_add_nums(lambda n: n, [1, 2, 3]) 
    
    // Finding the biggest number in a list
    def biggest(nums, current_biggest=0):
      if nums == 0
        return current_biggest
      else
        bigger = nums[0] if nums[0] > current_biggest else current_biggest
        return biggest(nums[1:], bigger)
    
    print biggest([1, 2, 5, 3, -1])
    
    def myreduce(f, l, acc):
      if l == []:
        return acc
      else:
        new_acc = f(l[0], acc)
        return myreduce(f, l[1:], new_acc)
    
    def biggest(l):
      return myreduce(lambda num, acc: num if num > acc else acc, l, 0)
    def length(l):
      return myreduce(lambda _, acc: acc + 1, l, 0)
    def mysum(l):
      return myreduce(lambda num, acc: num + acc, l, 0)
    print "Biggest", biggest([1, 2, 5, 3])
    print "Length", length([1, 2, 3, 5, 6])
    print "Sum", mysum([5, 5, 8])
      
6 - Modifying Data Structures



                      Section 3 - A Tour of FP Libraries
1 - Immutable Data Structures Introduction To Pyrsistent

2 - Immutable Data Structures How Pyrsistent Works

3 - Toolz A Functional Standard Library

4 - Hypothesis PropertyBased Testing

5 - 


                      Section 4 - Implementing A Game
1 - 


                      Section 5 - Testing
1 - 


                      Section 6 - User Interface
1 -


                      Section 7 - Integrating With An Imperative Third Party Library
1 -


                      Section 8 - First Class Effects
1 -


                      Section 9 - WebUI
1 -


                      Section 10 - Conclusion
1 -                     
