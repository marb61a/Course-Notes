                    ASP.NET Core Test Driven Development
                    Course Notes
                    
                    
                    Section 1 - Introduction
1 - Welcome
A brief welcome from the instructor to the course

2 - What You Should Know
There are some pre-requisites for the course
  - A good understanding of C#
    - You should know what Classes and Interfaces are
  - ASP.Net MVC
  - A basic understanding of Test Driven Development

3 - Using The Exercise Files
How to make use of the exercise files that accompany the course


                    
                    Section 2 - Get Started With TDD In ASP.NET Core
1 - TDD And Tools
The course will be using certain tools
  - Visual Studio 2017 Community Edition
  - Resharper (Paid Tool but 30 day free trial available)
    - You don't have to use Resharper but there may be additional typing involved
  - There are also some libraries which will be used
    - xUnit which is a unit testing framework
      - https://xunit.github.io
    - Moq which is a fremwork for creating mocks
      - https://github.com/Moq/moq4/wiki/Quickstart
There will also be some C# design patterns used in the demo application to show how they work with TDD
  - Repository Pattern
    - Repositories are responsible for interfacing with the data store
    - The services will perform business logic
    - The MVC controllers will present data to and take information from the user
TDD Basics
At the core of Test Driven Development is the Red, Green, Refactor cycle
  - Red -> Write a test that fails
  - Green -> Make a small change that makes tests pass
  - Refactor -> Restructure the code to improve code quality
The course will stick to the basics of how to apply TDD is ASP.Net Core using C#

2 - Dependency Injection (DI) And Inversion of Control (IoC)
Dependency Injection is a key component of writing testable code
  - Not only does it separate class responsibilities but can make writing code easier
Dependency Injection and Inversion of Control are often used together
  - IoC is a design principle
    - It states that your framework should be responsible for creating and calling classes
  - DI is a design pattern
    - Your classes are provided the dependencies you need to run
Example Syntax
  // A sample controller
  public class HomeController : Controller
  {
    private readonly ILogger _logger;
    
    public HomeController(ILogger, logger){
      _logger = logger;
    }
    
    public IActionResult Index(){
      _logger.Log("Someone visited the home page!");
      return View();
    }
  }
HomeController does not create its own logger
  - ILogger is a dependency, which is then injected
  - ILogger is an interface which creates a layer of abstraction
    - The class itself does not care about which logger is being used

Interfaces are key to writing clean testable code because
  - They can be mocked in tests
  - They help separate out responsibilities and focus on the class you are currently writing
IoC Container of Injection Container
  - These are tools to help achieve DI and IoC in code
  - Some popular ones are Castle Windsor, Autofac & Ninject
  - The course will use the built in container rather than a 3rd party one

3 - Configure The App For Testability
The course will consist of working on a sample website app called Landon Hotel
  - It is a standard bootstrap MVC website
  - Landon Hotel wishes to improve it's booking system to show booking cost
Example Syntax
  // Setting up the IoC Container
  // Startup.cs
  using Microsoft.AspNetCore.Builder;
  using Microsoft.AspNetCore.Hosting;
  using Microsoft.Extensions.Configuration;
  using Microsoft.Extensions.DependencyInjection;
  using Microsoft.Extensions.Logging;
  using LandonHotel.Services;
  
  namespace LandonHotel{
    public class Startup{
      public Startup(IHostingEnvironment env){
        var builder = new ConfigurationBuilder()
          .SetBasePath(env.ContentRootPath)
          .AddJsonPath("appsettings.json", optional: false, reloadOnChange: true)
          .AddJsonPath($"appsettings.{env.EnvironmentName}.json", optional: true)
        
        if(env.IsDevelopment()){
          builder.AddUserSecrets<Startup>():
        }
        
        builder.AddEnvironmentVariables();
        Configuration = builder.Build();
      }
      
      public IConfigurationRoot Configuration { get; }
      
      // This is the method that gets called by the runtime, use this method to add services to the container
      public void ConfigureServices(IServiceCollection services){
        // Framework services
        services.AddMvc();
        services.AddTransient<IRoomService, RoomService>();
        services.AddTransient<IBookingService, BookingService>();
        services.AddTransient<IRoomsRepository, RoomsRepository>();
        
      }
      
      public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory){
      
      }
    }
  }
  
  // BookingService.cs
  using LandonHotel.Data;
  using LandonHotel.Repositories;
  
  namespace LandonHotel.Services{
    public class BookingService : IBookingService{
      private readonly IRoomsRepository _roomRepo;
    
      public BookingService(IRoomsRepository roomRepo){
        _roomRepo = roomRepo;
      }
      
      public int CalculateBookingCost(int roomId, Booking booking){
        return 0;
      }
    }
  }

                    
                    Section 3 - Write Untested Code
1 - Test Base Case
Example Syntax
  // The client has asked that there be a verification of the booking validity before it gets booked
  // There are 3 criteria for the guest in the methods
  // Booking Service.cs
  using LandonHotel.Data;
  using LandonHotel.Repositories;
  using LandonHotel.Services;
  
  namespace LandonHotel.Services{
    public class BookingService : IBookingService{
      private readonly IBookingRepository _bookingRepo;
      private readonly IRoomsRepository _roomRepo;
    
      public BookingService(IBookingRepository bookingRepo, IRoomsRepository roomRepo){
        _bookingRepo = bookingRepo;
        _roomRepo = roomRepo;
      }
      
      public bool IsBookingValid(int roomId, Booking booking){
        var guestIsSmoking = booking.IsSmoking;
        var guestIsBringingPets = booking.HasPets;
        var numberOfGuests = booking.NumberOfGuests;
        return false;
      }
      
    }
  }

2 - Test N+1 Case

3 - Refactor Code And Tests

4 - Complete Test Cases

5 - Finish And Run The App


                    
                    Section 4 - Test Changes In Untested Code
1 - TDD In Untested Code

2 - Make Untestable Code Testable

3 - Confidently Change Your Code Part 1

4 - Confidently Change Your Code Part 2

5 - Refactor Your Existing Code



                    Section 5 - Conclusion
1 - Next Steps
Some recommendations from the instructor on where to proceed from this course
