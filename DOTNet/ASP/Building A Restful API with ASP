                    Building A Restful API with ASP.NET Core
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A very brief overview of the course from the instructor
  - Building an API is one thing building a Restful API is another
  - By the end of the course the student will have built a level 3 maturity API (The highest)

  
                    Section 2 - Introducing REST
1 - Coming Up
REST will be introduced in this module
Many API's that are called Restful are not really
A run through of the material that the section covers

2 - Course Prerequisites
The course has some prerequisites
  - The student doesn't need to know anything about REST
  - Knowledge of C# is required
  - Some knowledge of ASP.NET Core would be handy

3 - Tooling

4 - Introducing REST

5 - Learning What the REST Constraints Are About
REST is defined by 6 constraints, one of these is optional
  - A constraint is a design decision that can have positive or negative impacts
  - The Client-Server constraint enforces client-server architecture
    - The client or API-consumer should not be concerned with how data is stored
    - The server should not be concerned with things like UI or user state
  - The next constraint is Statelessness
    - This means that the necessary state to handle the request is contained within the request
    - This constraint is why REST can scale so easily, there is no need for things like Session state on the server
  - Cacheable
    - This states that each response message muct explicitly state if it can be cached or not
  - Layered System Constraint
    - REST can be compromised of multiple architectural layers
    - No one layer can directly access a layer that is beyond the next layer
    - This means that a client cannot tell what layer it is connected to
  - Code On Demand (This is an optional constraint)
    - This states that a server can customise or extend client functionality
  - The Uniform Interface Constraint
    - This is divided into 4 sub-constraints
    - It states that the API and its consumers share one single technical interface consisting of
      - URI, Method, Media Type

6 - The Richardson Maturity Model

7 - Positioning ASP.NET Core for Building RESTful APIs

8 - Demo - Inspecting the Starter Solution

9 - Summary
A short summary of the material covered in the chapter 



                    Section 3 - Getting Resources
1 - Coming Up
A high level overview of what the section will cover

2 - Structuring Our Outer Facing Contract

3 - Demo - Implementing the Outer Facing Contract (Part 1)

4 - Working with Routing

5 - Interacting with Resources Through HTTP Methods

6 - Demo - Implementing the Outer Facing Contract (Part 2)

7 - Outer Facing Model vs. Entity Model

8 - Demo - Getting a Resource Collection

9 - Demo - Introducing AutoMapper

10 - Demo - Getting a Single Resource

11 - The Importance of Status Codes

12 - Demo - Returning Correct Status Codes

13 - Demo - Handling Faults

14 - Demo - Working with Parent/Child Relationships

15 - Formatters and Content Negotiation

16 - Demo - Working with Content Negotiation and Output Formatters

17 - Summary
A short summary of the material covered in the chapter 



                    Section 4 - Creating and Deleting Resources
1 - Coming Up
A high level overview of what the section will cover

2 - Method Safety and Method Idempotency
3m 29s
Demo - Creating a Resource
11m 33s
Demo - Creating a Child Resource
6m 47s
Demo - Creating Child Resources Together with a Parent Resource
4m 44s
Demo - Creating a Collection of Resources
4m 4s
Demo - Working with Array Keys and Composite Keys
8m 26s
Demo - Handling POST to a Single Resource
4m 45s
Demo - Supporting Additional Content-type Values and Input Formatters
2m 29s
Demo - Deleting a Resource
3m 26s
Demo - Deleting a Resource with Child Resources
1m 46s
Deleting Collection Resources
1m 18s
Summary
2m 48s
5
Updating Resources
44m 53s
Coming Up
1m 2s
Demo - Updating a Resource (Part 1)
6m 18s
The Repository Pattern
3m 17s
Demo - Updating a Resource (Part 2)
5m 18s
Updating Collection Resources
1m 29s
Upserting
3m 14s
Demo - Upserting with PUT
3m 33s
Partially Updating a Resource
4m 14s
Demo - Partially Updating a Resource
6m 55s
Demo - Upserting with PATCH
3m 15s
HTTP Method Overview by Use Case
4m 39s
Summary
1m 34s
6
Working with Validation and Logging
44m 33s
Coming Up
0m 59s
Working with Validation in a RESTful World
4m 21s
Demo - Working with Validation on POST
10m 20s
Demo - Working with Validation on PUT
6m 52s
Demo - Working with Validation on PATCH
5m 58s
Demo - Logging Faults
7m 37s
Demo - Logging Errors and Other Information
2m 1s
Demo - Logging to a File
4m 57s
Summary
1m 25s
7
Implementing Paging, Filtering, and Searching
35m 10s
Coming Up
0m 55s
Paging Through Collection Resources
2m 26s
The Principle of Deferred Execution
1m 39s
Demo - Paging Through Collection Resources (Part 1)
8m 6s
Returning Pagination Metadata
2m 32s
Demo - Paging Through Collection Resources (Part 2)
10m 30s
Filtering and Searching
1m 58s
Demo - Filtering Collection Resources
3m 5s
Demo - Searching Through Collection Resources
2m 36s
Summary
1m 17s
8
Implementing Sorting and Data Shaping
40m 39s
Coming Up
0m 48s
Sorting Collection Resources
0m 57s
Demo - Sorting Collection Resources (Part 1)
2m 32s
Creating a Property Mapping Service
2m 35s
Demo - Creating a Property Mapping Service
3m 52s
Demo - Sorting Collection Resources (Part 2)
6m 47s
Demo - Taking Consumer Errors into Account When Sorting
4m 5s
Shaping Resources
1m 9s
Demo - Creating a Method to Shape Resources
5m
Demo - Shaping Collection Resources
4m 32s
Demo - Camel-casing Dictionaries When Serializing to JSON
1m 33s
Demo - Shaping a Single Resource
4m 31s
Exploring Additional Options
1m 26s
Summary
0m 46s
9
Getting Started with HATEOAS
36m 46s
Coming Up
0m 38s
Hypermedia as the Engine of Application State
8m 15s
Demo Introduction â€“ Supporting HATOEAS
2m 1s
Demo - Supporting HATEOAS (Base and Wrapper Class Approach)
9m 37s
Demo - Supporting HATEOAS (Dynamic Approach)
14m 44s
Summary
1m 28s
10
Advanced HATEOAS, Media Types, and Versioning
38m 45s
Coming Up
0m 40s
HATEOAS and Content Negotiation
3m 49s
Demo - HATEOAS and Content Negotiation
4m 23s
Demo - Working Towards Self-discoverability with a Root Document
3m 14s
Revisiting Media Types
2m 47s
Versioning in a RESTful World
5m 49s
Demo - Media Types and Versioning
11m 9s
Supporting Multiple Media Types
3m 14s
Other Approaches and Options
2m
Summary
1m 35s
11
Working with Caching and Concurrency
43m 4s
Coming Up
0m 47s
Working with Caching
4m 26s
The Expiration Model
5m 31s
The Validation Model
7m 45s
Cache-control Directives
3m 42s
Supporting Cache Headers
2m 3s
Demo - Supporting HTTP Cache Headers
7m 8s
Cache Stores
4m 8s
Dealing with Concurrency in a RESTful World
3m 14s
Demo - Dealing with Concurrency
2m 47s
Summary
1m 27s
12
Protecting, Testing, and Documenting Our API
30m 16s
Coming Up
1m 23s
Rate Limiting and Throttling
2m 13s
Demo - Rate Limiting and Throttling
6m 33s
Demo - Testing our API with Postman
5m 53s
Automated Testing and Continuous Integration
1m 55s
Documenting our API
4m 46s
Working with OPTIONS
1m 11s
Demo - Supporting the OPTIONS Method
1m 50s
Working with HEAD
0m 24s
Demo - Supporting the HEAD Method
1m 53s
Summary
2m 10s
