                    Building A Restful API with ASP.NET Core
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A very brief overview of the course from the instructor
  - Building an API is one thing building a Restful API is another
  - By the end of the course the student will have built a level 3 maturity API (The highest)

  
                    Section 2 - Introducing REST
1 - Coming Up
REST will be introduced in this module
Many API's that are called Restful are not really
A run through of the material that the section covers

2 - Course Prerequisites
The course has some prerequisites
  - The student doesn't need to know anything about REST
  - Knowledge of C# is required
  - Some knowledge of ASP.NET Core would be handy

3 - Tooling
IDE Types that the course will use(choose one)
  - Visual Studio 2015 - Update 3 or Community Edition
  - Visual Studio 2017
    - There are differences in the project system 2015 uses project.json, 2017 uses csproj/msbuild
  - Visual Studio Code
    - This also uses csproj/msbuild
You will need to have .NET core installed
  - .NET Core will probably have different version due to high release speed
Other Tools being used
  - Postman for API calls (requests to the API and the response messages)
    - https://www.getpostman.com
    - Fiddler or another tool can be used instead
    - HTTP requests from the course are included in the exercise files and can be imported
  - A web browser of choice

4 - Introducing REST

5 - Learning What the REST Constraints Are About
REST is defined by 6 constraints, one of these is optional
  - A constraint is a design decision that can have positive or negative impacts
  - The Client-Server constraint enforces client-server architecture
    - The client or API-consumer should not be concerned with how data is stored
    - The server should not be concerned with things like UI or user state
  - The next constraint is Statelessness
    - This means that the necessary state to handle the request is contained within the request
    - This constraint is why REST can scale so easily, there is no need for things like Session state on the server
  - Cacheable
    - This states that each response message muct explicitly state if it can be cached or not
  - Layered System Constraint
    - REST can be compromised of multiple architectural layers
    - No one layer can directly access a layer that is beyond the next layer
    - This means that a client cannot tell what layer it is connected to
  - Code On Demand (This is an optional constraint)
    - This states that a server can customise or extend client functionality
  - The Uniform Interface Constraint
    - This is divided into 4 sub-constraints
    - It states that the API and its consumers share one single technical interface consisting of
      - URI, Method, Media Type

6 - The Richardson Maturity Model
The Richardson Maturity Model is a model designed by Leonard Richardson
  - It creates API's by their Restful maturity
  - Level 0 - The Swamp of POX (Plain Old XML)
    - This level states that HTTP is used for remote interaction, the rest of the protocol isn't used as it should be7
    - There are a lot of RPC style implementations (eg SOAP)
  - Level 1 Resources
    - Each Resource is mapped to a URI
    - HTTP methods are not used as they should be
    - From a design point of view there is educed complexity
  - Level 2 Verbs
    - The correct HTTP verbs are used
    - The correct Status Codes are also used
    - It removes unnecessary variation
  - Level 3 Hypermedia
    - The API supports HATEOAS (Hypermedia As The Engine Of Application State)
    - This means that discoverability into your API

7 - Positioning ASP.NET Core for Building RESTful APIs

8 - Demo - Inspecting the Starter Solution

9 - Summary
A short summary of the material covered in the chapter 



                    Section 3 - Getting Resources
1 - Coming Up
A high level overview of what the section will cover

2 - Structuring Our Outer Facing Contract

3 - Demo - Implementing the Outer Facing Contract (Part 1)

4 - Working with Routing

5 - Interacting with Resources Through HTTP Methods

6 - Demo - Implementing the Outer Facing Contract (Part 2)

7 - Outer Facing Model vs. Entity Model

8 - Demo - Getting a Resource Collection

9 - Demo - Introducing AutoMapper

10 - Demo - Getting a Single Resource

11 - The Importance of Status Codes

12 - Demo - Returning Correct Status Codes

13 - Demo - Handling Faults

14 - Demo - Working with Parent/Child Relationships

15 - Formatters and Content Negotiation

16 - Demo - Working with Content Negotiation and Output Formatters

17 - Summary
A short summary of the material covered in the chapter 



                    Section 4 - Creating and Deleting Resources
1 - Coming Up
A high level overview of what the section will cover

2 - Method Safety and Method Idempotency
Method Safety and Method Idempotency are important concepts within the HTTP standard
  - A method is considered safe when it does not change resource representation
  - A method can be considered as being idempotent when it is called many times with the same result
  HTTP Method   Safe  Idempotent
  GET             /         /
  OPTIONS         /         /
  HEAD            /         /
  POST            x         x
  DELETE          x         /
  PUT             x         /
  PATCH           x         x
The above table shows method safety and idmepotency which will help decide which method to use for which use case

3 - Demo - Creating a Resource

4 - Demo - Creating a Child Resource

5 - Demo - Creating Child Resources Together with a Parent Resource

6 - Demo - Creating a Collection of Resources

7 - Demo - Working with Array Keys and Composite Keys

8 - Demo - Handling POST to a Single Resource

9 - Demo - Supporting Additional Content-type Values and Input Formatters

10 - Demo - Deleting a Resource

11 - Demo - Deleting a Resource with Child Resources

12 - Deleting Collection Resources

13 - Summary
A short summary of the material covered in the chapter 



                    Section 5 - Updating Resources
1 - Coming Up
A high level overview of what the section will cover

2 - Demo - Updating a Resource (Part 1)

3 - The Repository Pattern

4 - Demo - Updating a Resource (Part 2)

5 - Updating Collection Resources

6 - Upserting

7 - Demo - Upserting with PUT

8 - Partially Updating a Resource

9 - Demo - Partially Updating a Resource

10 - Demo - Upserting with PATCH

11 - HTTP Method Overview by Use Case

12 - Summary
A short summary of the material covered in the chapter 



                    Section 6 - Working with Validation and Logging
1 - Coming Up

2 - Working with Validation in a RESTful World

3 - Demo - Working with Validation on POST

4 - Demo - Working with Validation on PUT

5 - Demo - Working with Validation on PATCH

6 - Demo - Logging Faults

7 - Demo - Logging Errors and Other Information

8 - Demo - Logging to a File

9 - Summary
A short summary of the material covered in the chapter 



                    Section 7 - Implementing Paging, Filtering, and Searching
1 - Coming Up

2 - Paging Through Collection Resources

3 - The Principle of Deferred Execution

4 - Demo - Paging Through Collection Resources (Part 1)

5 - Returning Pagination Metadata

6 - Demo - Paging Through Collection Resources (Part 2)

7 - Filtering and Searching

8 - Demo - Filtering Collection Resources

9 - Demo - Searching Through Collection Resources

10 - Summary
A short summary of the material covered in the chapter 



                    Section 8 - Implementing Sorting and Data Shaping
1 - Coming Up
0m 48s
Sorting Collection Resources
0m 57s
Demo - Sorting Collection Resources (Part 1)
2m 32s
Creating a Property Mapping Service
2m 35s
Demo - Creating a Property Mapping Service
3m 52s
Demo - Sorting Collection Resources (Part 2)
6m 47s
Demo - Taking Consumer Errors into Account When Sorting
4m 5s
Shaping Resources
1m 9s
Demo - Creating a Method to Shape Resources
5m
Demo - Shaping Collection Resources
4m 32s
Demo - Camel-casing Dictionaries When Serializing to JSON
1m 33s
Demo - Shaping a Single Resource
4m 31s
Exploring Additional Options
1m 26s
Summary
0m 46s
9
Getting Started with HATEOAS
36m 46s
Coming Up
0m 38s
Hypermedia as the Engine of Application State
8m 15s
Demo Introduction â€“ Supporting HATOEAS
2m 1s
Demo - Supporting HATEOAS (Base and Wrapper Class Approach)
9m 37s
Demo - Supporting HATEOAS (Dynamic Approach)
14m 44s
Summary
1m 28s
10
Advanced HATEOAS, Media Types, and Versioning
38m 45s
Coming Up
0m 40s
HATEOAS and Content Negotiation
3m 49s
Demo - HATEOAS and Content Negotiation
4m 23s
Demo - Working Towards Self-discoverability with a Root Document
3m 14s
Revisiting Media Types
2m 47s
Versioning in a RESTful World
5m 49s
Demo - Media Types and Versioning
11m 9s
Supporting Multiple Media Types
3m 14s
Other Approaches and Options
2m
Summary
1m 35s
11
Working with Caching and Concurrency
43m 4s
Coming Up
0m 47s
Working with Caching
4m 26s
The Expiration Model
5m 31s
The Validation Model
7m 45s
Cache-control Directives
3m 42s
Supporting Cache Headers
2m 3s
Demo - Supporting HTTP Cache Headers
7m 8s
Cache Stores
4m 8s
Dealing with Concurrency in a RESTful World
3m 14s
Demo - Dealing with Concurrency
2m 47s
Summary
1m 27s
12
Protecting, Testing, and Documenting Our API
30m 16s
Coming Up
1m 23s
Rate Limiting and Throttling
2m 13s
Demo - Rate Limiting and Throttling
6m 33s
Demo - Testing our API with Postman
5m 53s
Automated Testing and Continuous Integration
1m 55s
Documenting our API
4m 46s
Working with OPTIONS
1m 11s
Demo - Supporting the OPTIONS Method
1m 50s
Working with HEAD
0m 24s
Demo - Supporting the HEAD Method
1m 53s
Summary
2m 10s
