                    CLR Reflection For Developers
                    Course Notes
                    
                    
                    Section 1 - Introduction
1 - Welcome
A brief welcome to the course from the instructor

2 - What You Should Know
Some prerequisites for the course are
  - .NET developer or have access to some version of Visual Studio
  - Comfortable with OO COncept eg class, objects
  - Familiarity with the command line

3 - Using The Exercise Files
It is recommended to follow along
There are exercise files available with both a beginning and an end file for each chapter



                    Section 2 - Reflection
1 - Reflection Overview
The course covers .NET Reflection
Reflection 
  - Gives runtime access to type metadata
  - Read only information as once it is defined it is immutable
    - some languages allow run time modifications but not the CLR
  - Type information such as fields, methods etc
  - Gives instance information such as values of fields or method invocations and results

2 - Point Demo
Example Syntax
  // Console application to demonstrate Reflection
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks
  
  namespace Reflection{
    public class Point{
      public Point(int x, int y){X = x; Y = y;}
      public int X {get; set;}
      public int Y {get; set;}
    
      public static double Distance(Point lhs, Point rhs){
        return Math.Sqrt(
          (Math.Pow((double)rhs.X - (double)lhs.X, 2)) +
          (Math.Pow((double)rhs.Y - (double)lhs.Y, 2))
        );
      }
      
      public static Point ORIGIN {get; {return new Point(0, 0); }}
      
      public override string ToString(){
        return String.Format("({0} {1})", X, Y);
      }
      
      public override bool Equals(object other){
        if(Object.ReferenceEquals(this, other))
          return true;
          
        if(!(other is Point))
          return false
        
        Point rhs = (Point) other;
        return (X == rhs.X) && (Y == rhs.Y);
      }
      
      public static bool operator == (Point lhs, Point rhs){
        return (lhs.X == rhs.X) && (lhs.Y == rhs.Y);
      }
      
      public static bool operator != (Point lhs, Point rhs){
        return !(lhs.X == rhs.X);
      }
    }
  }



                    Section 3  - IL Disassembler
1 - ILDasm.exe
IL Disassembler will be an invaluable tool
  - It ships with the .NET sdk
  - It is a CLI disassembler
  - Reverse CLI assembley to CIL (Technically IL Assembler) bytecode

2 - ILDasm.exe Demo



                    Section 4 - Reflection Namespace And Types
1 - Reflection Types
Most of the Reflection API lives inside the System.Reflection namespace
  - Ships with the CLR frameworks (.NET, Mono etc)
  - There are some differences between Windows.Net CLR and Core CLR
Within the System.Reflection namespace most classes will be type centric
  - System.Type / System.Reflection.TypeInfo: type metadata
    - Baseclass, interfaces, fields, methods, constructors and events
    - Nearly everything but comments

2 - Reflection Types Demo
Example Syntax
  // Continuing to use the demo app from previous sections
  public class Program
  {
    public static void Main(string[] args)
    {
      var ptType = typeOf(point);
      Console.WriteLine(ptType);                            // Will return Reflection Point
    }
  }

3 - Assemblies Modules Demo



                    Section 5 - Type API
1 - Type API Introduction     

2 - Type API Demo


 
                    Section 6 - Properties API
1 - Properties API Introduction

2 - Properties API Demo



                    Section 7 - MethodBase And MethodInfo API
1 - MethodBase And MethodInfo API Introduction

2 - MethodBase And MethodInfo API Demo


                    
                    Section 8 - Constructors API
1 - Constructors API Introduction

2 - Constructors API Demo



                    Section 9 - Fields API
1 - Fields API Introduction

2 - Fields API Demo



                    Section 10 - Objects
1 - Constructing Objects

2 - Constructing Objects Demo

3 - Accessing Properties

4 - Accessing Properties Demo

5 - Invoking Methods

6 - Invoking Methods Demo

7 - Accessing Fields

8 - Accessing Fields Demo

                    
                    
                    Section 11 - Conclusion
1 - Summary
A quick summary of what the course covered
