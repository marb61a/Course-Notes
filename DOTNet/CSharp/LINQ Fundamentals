                    LINQ Fundamentals For C# 6
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A brief introduction to the course and instructor
LINQ - Language INtegrated Query 
Using the features of LINQ is highly recommended by the instructor
Students should be able to use LINQ in their own applications by the end of the course



                    Section 2 -  An Introduction
1 - The Start
An introduction to the course by the author

2 - What is LINQ?
When C# was in earlier versions the designers wanted a query feature to be added to the language
  - This was because where the data was determined the tools and API's that could be used to access it
  - For example if data was in-memory you would use the generic collection classes provided by .NET
  - If the data was on a SQL Server then you would need to use ADO.net
  - There are also an entire set of tools for querying XML data
Microsoft designed LINQ to have one common API to replace the above

3 - Writing a Report without LINQ
The example is to list the 5 largest files inside a directory
Example Syntax
  // The instructor uses the Windows directory for the example but that is not copulsory
  // You can see what files these should be using the command line
  // dir /os which will order these files by size
  // After using the name of a method in a program using ctrl-. will generate the method in Visual Studio
  using System;
  using System.Collections.Generic;
  using System.IO;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace Introduction{
    class Program{
      static void Main(string[] args){
        // Windows uses forwardslashes rather than backslashes
        string path = @"C:\windows";
        ShowLargeFilesWithoutLinq(path);
      }
      
      private static void ShowLargeFilesWithoutLinq(){
        // Without LINQ create an instance of the directoryinfo class which isin the system.io namespace
        DirectoryInfo directory = new DirectoryInfo(path);
        // This returns an array of file info objects
        FileInfo[] files = directory.GetFiles();
        Array.Sort(files, new FileInfoComparer());
        
        for(i = 0; i < 5; i++){
          FileInfo file = files[i];
          // Using C# 6 string interpolation
          // The -20 value will left justify the response, the + will right justify
          // The N will write out as a number so that there will be commas, the 0 is for
          // the number of places after the decimal point
          Console.WriteLine($"{file.Name, -20 } : {file.length, 10:N0}");
        }
      }
    }
    
    // The IComparer interface only needs a single method
    public class FileInfoComparer : IComparer<FileInfo>{
      // This method returns -1 if the first file is less than the second file
      // return a 0 if they are equal and a 1 if it is greater that the file that it is compared to
      public int Compare(FileInfo x, FileInfo y){
        return y.Length.CompareTo(x.Length);
      }
    }
  }

4 - Writing a Report with LINQ
This section will reimplement the previous example this time using LINQ instead
Example Syntax 
  // With LINQ example
  using System;
  using System.Collections.Generic;
  using System.IO;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace Introduction{
    class Program{
      static void Main(string[] args){
        string path = @"C:\windows";
        ShowLargeFilesWithLinq(path);
      }
            
      public static void ShowLargeFilesWithLinq(string path){
        // LINQ can appear mysterious at first
        var query = from file in new DirectoryInfo(path).GetFiles()
                    orderby file.length descending
                    select file;
        // The above makes use of one version of syntax which is similar to SQL, below is the second of 2 types of syntax
        // The take 5 is added to the method calls and removed from the for loop and they each return the same
        var query = from file in new DirectoryInfo(path).GetFiles()
                    .OrderByDescending(f => file.Length)
                    .Take(5);
        
        foreach(var file in query.Take(5)){
          Console.WriteLine($"{file.Name, -20 } : {file.length, 10:N0}");
        }
      }
    }    
  }

5 - The Roadmap
A quick outline of what the course will cover



                    Section 3 - LINQ and C#
1 - Introduction
An introduction to the material to be covered in the section

2 - Evolving the Language
The ability to write easy to read & non verbose code has been a while coming in C#
LINQ is designed to work against data sources
Example Syntax
  // The example is imagined to be be LINQ designers on a whiteboard
  // Sequence is used to represent a data source eg Database or Array
  // Common filters like Where should be easy to express not just that you wish to filter but how
  Sequence<Employee> scotts = employees.Where(name == "Scott");
  
  // The equivalent of above in C# 2.0
  // IEnumerable can be iterated over
  IEnumerable<Employee> scotts = 
    EnumerableExtensions.Where(
      delegate(Employee e){
        return e.name == "Scott";
      } 
    )
  
  // LINQ today -- Lokks like SQL
  var scotts = 
    from e in employees
    where e.name == "Scott"
    select e

3 - The Power of IEnumerable
Example Syntax
  // This will be a console application
  // Employee.cs file
  namespace Features{
    public class Employee{
      public int Id { get; set; }
      public string Name { get; set; }
    } 
  }
  
  // The Program.cs file
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks
  
  namespace Features{
    class Program{
      static void main(string[] args){
        // You could change this to an IEnumerable <Employee> and it would still work as
        // the IEnumerable can be iterated over
        Employee [] developers = new Employee[]
        {
          new Employee {Id = 1, name = "Jack"}
          new Employee {Id = 2, name = "Joe"}
        };
        
        List<Employee> sales = new List <Employee>()
        {
          new Employee {id = 3, name = "Jim"}
        };
        
        // GetEnumerator is one of the few methods available without LINQ
        // This is essentially a forEach statement but is a lot more difficult
        IEnumerator<Employee> enumerator = developers.GetEnumerator();
        while(enumerator.MoveNext()){
          Console.WriteLine(enumerator.Current.Name);
        }
      }
    }
  }
There are a few different methods that can be used to iterate over the collections above
  - Both of the above collections have a method called GetEnumerator() which can be used
  - This is because both implement and interface called IEnumerable<T>
  - This is a very important interface for LINQ as all query operations operate off of this interface or another
    - One reason for its importance is the ability to represent many different data structures
    - Most data structures can be hidden behind IEnumerable
If using Visual Studio by hovering over a method and pressing F12 will show the metadata view of the class
  - This metadata will show IEnumerable<T> as one the interfaces

4 - Creating an Extension Method
Extension Methods in C# allow for the definition of a static method which appears to be a member of another type, any type
Example Syntax
  // Creating extension methods
  public static class StringExtensions{
    // Using the this keyword tells the C# compiler that this is an extension method
    // There can be as many parameters as needed but only the first has the this modifier
    static public double ToDouble(this string data){
      double result = double.Parse();
      return result;
    }
  }
  
  // Using extension methods allows for static method invocation with instance syntax
  string text = "43.35";
  double data = text.ToDouble();
LINQ makes heavy use of extension methods such as IEnumerable
  - All LINQ query operators are defined as extension methods

Example Syntax
  // Using the employee example from above
  // The example is for counting employees in a departments
  static void main(string[] args){
    Employee [] developers = new Employee[] {
      new Employee {Id = 1, name = "Jack"}
      new Employee {Id = 2, name = "Joe"}
    };

    List<Employee> sales = new List <Employee>(){
      new Employee {id = 3, name = "Jim"}
    };
    
    // Linq has a built in Count() method but the example builds its own to show how LINQ's works
    Console.WriteLine(Developers.Count());
    
    IEnumerator<Employee> enumerator = developers.GetEnumerator();
    while(enumerator.MoveNext()){
      Console.WriteLine(enumerator.Current.Name);
    }
  }
  
  // MyLinq.cs
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks
  
  namespace Features{
    public static class MyLinq{
      // Knowledge of C# Generics is recommended with LINQ
      public static int Count<T>( this IEnumerable<T> sequence){
        int count = 0;
        foreach(var item in sequence){
          count += 1;
        }
        
        return count;
      }
    }
  }

5 - Understanding Lambda Expressions
Example Syntax
  // The example ask that you imagine that you are working with an array of strings
  // These string are names of cities from which you are then going to pull out the cities beginning with L
  // The Where method is a LINQ method which knows where to filter in a generic sense but needs code for specifics
  IEnumerable<string> filteredList = cities.Where(StartsWithL);
  
  // This is the named mathod approach where the method is passed in somewhere using its name
  // Using this approach can become cumbersome if used on every filtering or sort operation in an application
  public bool StartsWithL(string name){
    return name.StartsWithL("L");
  }
  
  // Using delegate syntax for the same example, which will function the exact same way
  // This allows for an inline or anonymous method to be called
  // This kind of syntax can be noisy and difficult to read and is one of the reasons behind LINQ
  IEnumerable<string> filteredList = 
    cities.Where(delegate(string s) { return s.StartsWithL("L"); })

  // A lambda expression version of the above example
  IEnumerable<string> filteredList = cities.Where(s => s.StarsWithL("L"))

Example Syntax
  // Again using the employee example that has been previously used
  foreach(var employee in developers.Where(NameStartsWithS)){
    Console.WriteLine(employee.Name);
  }
  
  private static bool NameStartsWithS(Employee){
    return Name.StartsWith("S");
  }

Anonymous methods are good for filtering and sorting
  - They can however be verbose and this is something that the Linq designers wanted to avoid
Example Syntax
  // The foreach from above rewritten to use lambda functionality
  foreach(var employee in developers.Where(e => e.Name.StartsWith("S"))){
    Console.WriteLine(employee.Name);
  }

6 - Using Func and Action Types
Func types are used by many Linq Operators 
  - This means that they will need to be understood well
Example Syntax
  // Using a new example in the employee code from prvioes sections
  // The func type was introduced as an easy way to work with delegates
  // The example below takes an int and returns an int
  // Using the types is optional as the C# complier will usually figure them out but they can be explicitly stated
  // If using curly braces then using the return keyword is needed
  func<int, int> f = Square;
  func<int, int> square = x => x * x;
  // When using more than one paramenter in a Lambda function the parameters need to be surrounded by parentheses
  func<int, int, int> = (x, y) => x + y;
  
  Console.WriteLine(square(add(3, 5)));                   // Will return 64 as 3 + 5 is 8 and 8 squared is 64


7 - Using var for Implicit Typing
The var kayword was introduced to C# at the same time as Linq
  - It makes working with queries easier in many scenarios but is not essential
  - Using var allows the compiler to infer the data type which avoids having to explicitly specify the type
  - Using var does not introduce dynamic typing as the variables are still strongly typed
  - Instructor highly recommends using var as it makes code more readable 
  - Using var is restricted to local variables, it is not used
    - Defining parameters to a method
    - Defining a field or proerty of a class
Example Syntax
  // Some examples, all the console writelines will return true
  var name = "Jack";
  var x = 3.0;
  var y = 2;
  var z = x * y;
  
  Console.WriteLine(name is string);
  Console.WriteLine(x is double);
  Console.WriteLine(y is int);
  Console.WriteLine(z is double);
  
  // Using the previous employee example to change local variables only to use var
  IEnumerable<Employee> developers = new Employee[]
  {
    new Employee{Id = 1, name = "Jack"},
    new Employee{Id = 2, name = "Jim"}
  }
  IEnumerable<Employee> sales = new List<Employee>()
  {
    new Employee{Id = 3, name = "Bob"}
  }
  
  // After changing
  var developers = new Employee[]
  {
    new Employee{Id = 1, name = "Jack"},
    new Employee{Id = 2, name = "Jim"}
  }
  
  var sales = new List<Employee>()
  {
    new Employee{Id = 3, name = "Bob"}
  }

8 - Query Syntax versus Method Syntax

9 - Summary
A quick summary of what the chapter covered



                    Section 4 - LINQ Queries
1 - Introduction
An introduction to the material to be covered in the section

2 - Creating a Custom Filter Operator

3 - Creating an Operator with Yield Return

4 - Deferred Execution Explained

5 - Taking Advantage of Deferred Execution

6 - Avoiding Pitfalls of Deferred Execution

7 - Exceptions and Deferred Queries

8 - All About Streaming Operators

9 - Querying Infinity

10 - Summary
A quick summary of what the chapter covered



                    Section 5 - Filter, Ordering & Projecting
1 - Introduction
An introduction to the material to be covered in the section

2 - A File Full of Fuel Efficiency

3 - How to Process a CSV File with LINQ

4 - Implementing a File Processor

5 - Finding the Most Fuel Efficient Car

6 - Filtering with Where and First

7 - Quantifying Data with Any, All, Contains

8 - Projecting Data with Select

9 - Flattening Data with SelectMany

10 - Summary
A quick summary of what the chapter covered



                    Section 6 - Joining, Grouping & Aggregating
1 - Introduction
An introduction to the material to be covered in the section

2 - Adding a Second Data Source

3 - Joining Data with Query Syntax

4 - Joining Data Using Method Syntax

5 - Creating a Join with a Composite Key

6 - Grouping Data

7 - Using a GroupJoin for Hierarchical Data

8 - Challenge Answer: Group by Country

9 - Aggregating Data

10 - Efficient Aggregation with Extension Methods

11 - Summary
A quick summary of the what the chapter covered



                    Section 7 LINQ to XML
1 - Introduction
An introduction to the material to be covered in the section

2 - System.Xml.Linq

3 - Building Element-oriented XML

4 - Functional Construction for Less Code

5 - Load and Query XML with LINQ

6 - Working with XML Namespaces

7 - Summary
A quick summary of what the chapter covered



                    Section 8 - LINQ and the Entity Framework
1 - Introduction
An introduction to the material to be covered in the section

2 - Setting up the Entity Framework

3 - Inserting Data into a New Database

4 - Writing a Basic Query with LINQ

5 - Working with IQueryables and Expression Trees

6 - Caveats and Pitfalls of Remote LINQ

7 - An Advanced LINQ Query

8 - Summary
A quick summary of what the chapter covered

