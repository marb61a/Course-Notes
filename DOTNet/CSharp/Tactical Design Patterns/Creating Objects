                    Tactical Design Patterns in .NET: Creating Objects
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A quick introduction to the author and course


                    Section 2 - Understanding Constructors and Their Roles
1 - Motivation to Apply a Design Pattern
Part of a series of courses but it is not compulsory that you watch
  - They can also be watched in any order
There is a division between how patterns are applied in theory and in practice
In Theory
  - Division is formal and precise
  - The main motivation is to produce a good design
In Practice
  - The division rarely conforms to usage
  - The main motivation in practice is to improve a design
Nested calculations hide added responsibilities
A strategy pattern is meant to objectivize the changing implementation, to turn a specific implementation into an object
so that the implementation can vary by varying the objects supplied from the outside

2 - Division of Design Patterns
The previous courses in the series and this cover different types of design pattern
  - Again it is not compulsory to watch these
  - This course is dedicated to patterns that help create objects and object graphs
  - These include Abstract Factory, Factory Method, Builder, Specification
In the book the creation patterns covered Abstract Factory, Factory Method, Builder. Singleton & Prototype
  - This course will not cover the Singleton and Prototype patterns
Specification is not a creation pattern
  - In the book it describes an expression (Boolean, Arithmetic), it validates an object
  - As a builder it describes an object and its parts, it specialises that knowledge to create that object
Pattern implementations can be connected and combined
Do not start from object roles in a design instead start from the problem that hurts the design

3 - What Does It Mean to Create an Object?
This is one of the most fundamental questions of OOP
  - Most objects are short-lived objects
  - Some objects eg key-value pairs are easy to create
  - Contextual objects can be called dependencies
  - Creational pattern is supposed to bring order to creating objects
  - The more complex the object graph the more complex the design pattern
  - The simplest of all creators is the Factory
    - Its target will not to reduce complexity but to decouple the client from the concrete object
  - Abstract Factory will handle one level of dependencies only
  - A new object will be created and its dependencies supplied in a single operation
  - The builder pattern comes in where more than 1 process is needed before the object is constructed
    - As can be imagined Builders will cover more complex cases than factories
  - Builders may use part-builders to help construct objects
    - part-builders can be fairly simple
    - This can be troublesome where the object graph is complex
  - The specification pattern will be introduced where the object graph is too complex for part-builders
    - This isn't part of the creational patterns

4 - All Objects Must Be Consistent
This is where the high level approach to objects comes to an end
  - All object creation calls the classes contructor
  - Only a small numeber of classes support parameterless constructors
    - This is because underneath everything its existence is to create an object
    - It should also do everything that needs to be done prior to the object creation
  - Some programmers have relaxed the object construction phase
    - This is not good as it puts the pressure on the caller
    - If there are issues with the caller then failures are bound to occur
      -These could happen in production if some use cases have not been properly tested
Example Syntax
  // A sample program demonstrating the average speed at which someone travels
  class RoadSegment
  {
    private double distanceKm;
    private TimeSpan timeSpent;
    
    public double DistanceKm
    {
      get {return this.distanceKm; }
      set
      { 
        if(value <= 0) throw new ArgumentException();
        this.distanceKm = value;
      }
    }
    
    public TimeSpan TimeSpent
    {
      get {return this.timeSpent;}
      set
      {
        if(value <= new TimeSpan(0)) throw new ArgumentException();
        this.timeSpent = value;
      }
    }
    
    public double VelocityKph => this.DistanceKm / this.TimeSpent.TotalHours;
  }

5 - Summary
A quick run through of what the course covered in the chapter

6 - What Follows in this Course



                    Section 3 - Advancing from Constructor to Abstract Factory
1 - Abstract Factory by the Book

2 - Abstractness of Abstract Products

3 - Constructor Arguments

4 - Strongly-typed Abstract Factory

5 - Summary
A quick run through of what the course covered in the chapter



                    Section 4 - Avoiding Excess Factory Abstractness
1 - Downfall of the Pure Abstract Factory

2 - Abstract Factory in ASP.NET MVC Applications

3 - Implementing Controller Factory in ASP.NET MVC

4 - The Doom of Strongly-typed Code

5 - Concrete Factory Should Not Recover from Errors

6 - Summary
A quick run through of what the course covered in the chapter



                    Section 5 - Understanding Dependencies, Covariance, and Contravariance
1 - Understanding Dependencies

2 - Encapsulation of Dependencies

3 - Covariance of Abstract Products

4 - Contravariance of Concrete Products

5 - Covariance vs. Contravariance Clash

6 - Summary
A quick run through of what the course covered in the chapter



                    Section 6 - Applying the Substitution and Liskov Substitution Principles
1 - Object Producer vs. Object Consumer

2 - Understanding the Substitution Principle

3 - Object Layout and Substitution Principle

4 - Strengthening the Substitution Principle

5 - Breaking the Liskov Substitution Principle

6 - Behavioral Subtyping and Liskov Substitution Principle

7 - Enforcing the Liskov Substitution Principle

8 - Summary
A quick run through of what the course covered in the chapter



                    Section 7 - Returning to Concrete Classes with the Builder Pattern
1 - Stepping Back from Polymorphism

2 - Builder Pattern by the Book

3 - Enforcing Constructor Preconditions

4 - Strengthening the Builder

5 - Turning the Builder into Finite State Machine

6 - Casting Finite State Machine into Proper State Pattern

7 - Summary
A quick run through of what the course covered in the chapter



                    Section 8 - Embedding Calling Protocols into the Builder
1 - Adding Complexity to the Product

2 - Handling Added Complexity in the Builder

3 - Identifying the Problem of the Calling Protocol

4 - Applying Interface Segregation Principle to the Builder

5 - Implementing the Fluent Interface in the Builder

6 - Brushing Up the Fluent Interface of the Builder

7 - Enforcing Contracts on Interfaces

8 - Enforcing Command/Query Separation Principle

9 - Cleaning up the Code

10 - Summary
A quick run through of what the course covered in the chapter



                    Section 9 - Breathing Life Back into Factory Methods with Lambdas
1 - Factory Method by the Book

2 - Recognizing Rigidity of the Factory Method

3 - Injecting Factory Method Like a Strategy

4 - Bringing Covariance Back to the Builder Pattern

5 - Introducing Higher Order Factory Methods

6 - Letting the Graph of Factory Methods Create the Graph of Objects

7 - Summary
A quick run through of what the course covered in the chapter



                    Section 10 - Building Complex Objects with the Specification Pattern
1 - Specification Pattern by the Book

2 - Introducing Configurable Specifications

3 - Turning Validating Specification into Building Specification

4 - Defining Specifications on the Fly

5 - Incomplete Object vs. Incomplete Specification

6 - Implementing the Specification

7 - Showing the Flexibility of Specifications

8 - Summary
A quick run through of what the course covered in the chapter



                    Section 11 - Building Object Graphs with the Specification Pattern
1 - Nesting the Specifications

2 - The Idea of Comparing Future Objects

3 - Simulating Covariance

4 - Simulating Covariance in Specifications

5 - Comparing Future Objects

6 - Comparison of Creational Methods

7 - Summary
A quick run through of what the course covered in the chapter
