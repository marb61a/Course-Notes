                    Tactical Design Patterns in .NET: Creating Objects
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A quick introduction to the author and course


                    Section 2 - Understanding Constructors and Their Roles
1 - Motivation to Apply a Design Pattern
Part of a series of courses but it is not compulsory that you watch
There is a division between how patterns are applied in theory and in practice

2 - Division of Design Patterns

3 - What Does It Mean to Create an Object?

4 - All Objects Must Be Consistent

5 - Summary

6 - What Follows in this Course



                    Section 3 - Advancing from Constructor to Abstract Factory
1 - Abstract Factory by the Book

2 - Abstractness of Abstract Products

3 - Constructor Arguments

4 - Strongly-typed Abstract Factory

5 - Summary



                    Section 4 - Avoiding Excess Factory Abstractness
1 - Downfall of the Pure Abstract Factory

2 - Abstract Factory in ASP.NET MVC Applications

3 - Implementing Controller Factory in ASP.NET MVC

4 - The Doom of Strongly-typed Code

5 - Concrete Factory Should Not Recover from Errors
3m 20s
Summary
4m 2s
5
Understanding Dependencies, Covariance, and Contravariance
37m 17s
Understanding Dependencies
8m 48s
Encapsulation of Dependencies
6m 45s
Covariance of Abstract Products
6m 16s
Contravariance of Concrete Products
8m 3s
Covariance vs. Contravariance Clash
4m 9s
Summary
3m 14s
6
Applying the Substitution and Liskov Substitution Principles
44m 19s
Object Producer vs. Object Consumer
3m 40s
Understanding the Substitution Principle
4m 45s
Object Layout and Substitution Principle
8m 7s
Strengthening the Substitution Principle
2m 34s
Breaking the Liskov Substitution Principle
6m 36s
Behavioral Subtyping and Liskov Substitution Principle
8m 26s
Enforcing the Liskov Substitution Principle
7m 3s
Summary
3m 6s
7
Returning to Concrete Classes with the Builder Pattern
40m 11s
Stepping Back from Polymorphism
4m 16s
Builder Pattern by the Book
5m 3s
Enforcing Constructor Preconditions
7m 10s
Strengthening the Builder
6m 8s
Turning the Builder into Finite State Machine
7m 6s
Casting Finite State Machine into Proper State Pattern
9m 6s
Summary
1m 20s
8
Embedding Calling Protocols into the Builder
60m 10s
Adding Complexity to the Product
6m 45s
Handling Added Complexity in the Builder
5m 57s
Identifying the Problem of the Calling Protocol
5m 54s
Applying Interface Segregation Principle to the Builder
6m 51s
Implementing the Fluent Interface in the Builder
4m 50s
Brushing Up the Fluent Interface of the Builder
6m 5s
Enforcing Contracts on Interfaces
8m 29s
Enforcing Command/Query Separation Principle
4m 25s
Cleaning up the Code
8m 34s
Summary
2m 16s
9
Breathing Life Back into Factory Methods with Lambdas
43m 51s
Factory Method by the Book
8m
Recognizing Rigidity of the Factory Method
4m 22s
Injecting Factory Method Like a Strategy
9m 24s
Bringing Covariance Back to the Builder Pattern
6m 58s
Introducing Higher Order Factory Methods
7m 31s
Letting the Graph of Factory Methods Create the Graph of Objects
4m 12s
Summary
3m 21s
10
Building Complex Objects with the Specification Pattern
46m 53s
Specification Pattern by the Book
7m 37s
Introducing Configurable Specifications
10m 32s
Turning Validating Specification into Building Specification
4m 21s
Defining Specifications on the Fly
4m
Incomplete Object vs. Incomplete Specification
6m 59s
Implementing the Specification
6m 39s
Showing the Flexibility of Specifications
4m 38s
Summary
2m 5s
11
Building Object Graphs with the Specification Pattern
43m 5s
Nesting the Specifications
4m 7s
The Idea of Comparing Future Objects
4m 27s
Simulating Covariance
10m 13s
Simulating Covariance in Specifications
4m 49s
Comparing Future Objects
6m 53s
Comparison of Creational Methods
6m 32s
Summary
6m 2s
