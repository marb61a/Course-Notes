                    Tactical Design Patterns in .NET: Creating Objects
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A quick introduction to the author and course


                    Section 2 - Understanding Constructors and Their Roles
1 - Motivation to Apply a Design Pattern
Part of a series of courses but it is not compulsory that you watch
  - They can also be watched in any order
There is a division between how patterns are applied in theory and in practice
In Theory
  - Division is formal and precise
  - The main motivation is to produce a good design
In Practice
  - The division rarely conforms to usage
  - The main motivation in practice is to improve a design
Nested calculations hide added responsibilities
A strategy pattern is meant to objectivize the changing implementation, to turn a specific implementation into an object
so that the implementation can vary by varying the objects supplied from the outside

2 - Division of Design Patterns
The previous courses in the series and this cover different types of design pattern
  - Again it is not compulsory to watch these
  - This course is dedicated to patterns that help create objects and object graphs
  - These include Abstract Factory, Factory Method, Builder, Specification
In the book the creation patterns covered Abstract Factory, Factory Method, Builder. Singleton & Prototype
  - This course will not cover the Singleton and Prototype patterns
Specification is not a creation pattern
  - In the book it describes an expression (Boolean, Arithmetic), it validates an object
  - As a builder it describes an object and its parts, it specialises that knowledge to create that object
Pattern implementations can be connected and combined
Do not start from object roles in a design instead start from the problem that hurts the design

3 - What Does It Mean to Create an Object?

4 - All Objects Must Be Consistent

5 - Summary
A quick run through of what the course covered in the chapter

6 - What Follows in this Course



                    Section 3 - Advancing from Constructor to Abstract Factory
1 - Abstract Factory by the Book

2 - Abstractness of Abstract Products

3 - Constructor Arguments

4 - Strongly-typed Abstract Factory

5 - Summary
A quick run through of what the course covered in the chapter



                    Section 4 - Avoiding Excess Factory Abstractness
1 - Downfall of the Pure Abstract Factory

2 - Abstract Factory in ASP.NET MVC Applications

3 - Implementing Controller Factory in ASP.NET MVC

4 - The Doom of Strongly-typed Code

5 - Concrete Factory Should Not Recover from Errors

6 - Summary
A quick run through of what the course covered in the chapter



                    Section 5 - Understanding Dependencies, Covariance, and Contravariance
1 - Understanding Dependencies

2 - Encapsulation of Dependencies

3 - Covariance of Abstract Products

4 - Contravariance of Concrete Products

5 - Covariance vs. Contravariance Clash

6 - Summary
A quick run through of what the course covered in the chapter



                    Section 6 - Applying the Substitution and Liskov Substitution Principles
1 - Object Producer vs. Object Consumer

2 - Understanding the Substitution Principle

3 - Object Layout and Substitution Principle

4 - Strengthening the Substitution Principle

5 - Breaking the Liskov Substitution Principle

6 - Behavioral Subtyping and Liskov Substitution Principle

7 - Enforcing the Liskov Substitution Principle

8 - Summary
A quick run through of what the course covered in the chapter



                    Section 7 - Returning to Concrete Classes with the Builder Pattern
1 - Stepping Back from Polymorphism

2 - Builder Pattern by the Book
5m 3s
Enforcing Constructor Preconditions
7m 10s
Strengthening the Builder
6m 8s
Turning the Builder into Finite State Machine
7m 6s
Casting Finite State Machine into Proper State Pattern
9m 6s
Summary
1m 20s
8
Embedding Calling Protocols into the Builder
60m 10s
Adding Complexity to the Product
6m 45s
Handling Added Complexity in the Builder
5m 57s
Identifying the Problem of the Calling Protocol
5m 54s
Applying Interface Segregation Principle to the Builder
6m 51s
Implementing the Fluent Interface in the Builder
4m 50s
Brushing Up the Fluent Interface of the Builder
6m 5s
Enforcing Contracts on Interfaces
8m 29s
Enforcing Command/Query Separation Principle
4m 25s
Cleaning up the Code
8m 34s
Summary
2m 16s
9
Breathing Life Back into Factory Methods with Lambdas
43m 51s
Factory Method by the Book
8m
Recognizing Rigidity of the Factory Method
4m 22s
Injecting Factory Method Like a Strategy
9m 24s
Bringing Covariance Back to the Builder Pattern
6m 58s
Introducing Higher Order Factory Methods
7m 31s
Letting the Graph of Factory Methods Create the Graph of Objects
4m 12s
Summary
3m 21s
10
Building Complex Objects with the Specification Pattern
46m 53s
Specification Pattern by the Book
7m 37s
Introducing Configurable Specifications
10m 32s
Turning Validating Specification into Building Specification
4m 21s
Defining Specifications on the Fly
4m
Incomplete Object vs. Incomplete Specification
6m 59s
Implementing the Specification
6m 39s
Showing the Flexibility of Specifications
4m 38s
Summary
2m 5s
11
Building Object Graphs with the Specification Pattern
43m 5s
Nesting the Specifications
4m 7s
The Idea of Comparing Future Objects
4m 27s
Simulating Covariance
10m 13s
Simulating Covariance in Specifications
4m 49s
Comparing Future Objects
6m 53s
Comparison of Creational Methods
6m 32s
Summary
6m 2s
