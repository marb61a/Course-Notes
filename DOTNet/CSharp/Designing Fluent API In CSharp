                    Designing Fluent API In CSharp
                    Course Notes
                    
                    
                    Section 1 - Course Overview
1 - Course Overview
Brief intro to the instructor
A very quick overview of the course
There is only one main pre-requisite for the course
  - Intermediate knowledge of C#
    - More specifically Generics, Interfaces, Inheritance and Unit Testing
  
  
                    
                    Section 2 - Designing Fluent API's in C#
1 - The Benefits Of Fluent API's
A demonstration of the the benefits of using Fluent API's
Example Syntax
  // This is a LINQ related demonstration
  using System.Collections.Generic;
  using System.Linq;
  
  namespace FluentApi{
    class LinqExample{
      // This is the fluent example and all the processing is done fairly quickly
      // It will filter and sort a list of items
      public IEnumerable<Shape> ProcessViaLinq(IEnumerable<Shape> input){
        return input
          .where(x => x.Color == "Blue")
          .OrderBy(x => x.Width)
          .ThenBy(x => x.Height)
      }
      
      public IEnumerable<Shape> ProcessWithoutLinq(IEnumerable<Shape> input){
        var output = new List<Shape>();
        foreach(var shape in input){
          if(shape.Color == "Blue"){
            output.Add(shape);
          }
        }
        
        output.sort(CompareShapes);
        return output;
      }
      
      private int CompareShapes(Shape x, Shape y){
        var compareValue = x.Width.CompareTo(y.Width);
        if(compareValue != 0)
          return compareValue;
        
        return x.Height.CompareTo(y.Height);
      }
    }
  }
  
  // The INotifyPropertyChanged interface (should be familiar to C#)
    namespace System.ComponentModel{
      // This notifies clients that a property value has changed
      // Writing unit tests for this can be extremely tedious
      public interface INotifyPropertyChanged{
        // This event occurs when a property value changes
        event PropertyChangedEventHandler PropertyChanged;
      }
    }

    // Continuing above where we expect change events for first name, last name and full name
    using System.ComponentModel
    namespace FluentApi{
      class Person : INotifyPropertyChanged{
        public event PropertyChangedEventHandler PropertyChanged;

        public string FirstName;
        public string LastName;
        public string FullName;
      }
    }
    
    // Unit test for setting the firstname property was set and verifying that the above has fired 
    void LongForm(){
      var testee = new Person();
      var notifications = new List<string>();
      
      testee.PropertyChanged += (o, e) => notifications.Add(e.PropertyName);
      testee.FirstName = "John";
      
      Assert.That(notifications, Contains.Item("FirstName").And.Contains("FullName"));
    }
    
    // The above rewritten using Fluent API
    using NUnit.Framework;
    using System.Generics.Collection;
    using FluentApi.NotifyPropertyChanged;
    
    namespace FluentApi{
      // This is a much cleaner colution as it uses properties instead of hardcoded values and
      // so any errors are much easier to resolve
      class NotifyPropertyChangedExample{
        void fluent(){
          var testee = new Person();
          
          testee.shouldNotifyFor(t => t.FirstName)
            .And(t => t.FullName)
            .When(() => testee.FirstName = "John");
        }
        
        void LongForm(){
         var testee = new Person();
         ...
        }
      }
    }
    

2 - Course Synopsis
There are some prerequisites for students
  - Intermediate level C# skills covering Inheritance, Generics, Unit Testing
  - You should be code for others to use
  - You can talk to your users
  - A desire for creative elegant solutions to problems
There is also a run through of the course syllabus
  - There will be a mix of theory and practice in the course covering different areas

3 - Domain Specific Languages (DSL) And Fluent API's
Domain Specific Languages are languages built to address a specific problem
  - Because they are limited in target they will also be limited in scope
  - They do however solve specific types of problems extremely well
  - Some DSL's are fully fledged languages with compilers etc
  - In the case of C# these are a type of Embedded DSL
  - Embedded DSL's are DSL's that are expressed using the syntax of a host language
DSL's are important to discuss when designing Fluent APIs in order to focus on the problem domain to be solved
Revisiting the examples from earlier in order to understand how their API express solutions
The first example used is the LINQ example which filters and sorts a list of items

4 - Collaboration And Refinement Of Fluent API Drafts

5 - Feedback, Tests And Documentation

6 - Recap
A brief recap of the material covered in this section


                    
                    Section 3 - Identifying The Components Of Fluent API's
1 - Method Chaining

2 - Characteristics Of Fluent API's

3 - Components Of Fluent API's

4 - Type Inference And Verbose Method Signatures

5 - Recap
A brief recap of the material covered in this section



                    Section 4 - Case Study Fluent Testing Of INotifyPropertyChanged
1 - Path To The First Passing Test                     

2 - Adding A Simple Fluent Call

3 - Refactoring To Accomodate Fluent Tests

4 - Exclusive Notification Verification 

5 - Recap
A brief recap of the material covered in this section
  
  
  
                    Section 5 - Case Study Fluent Mapper
1 - The Path To The First Working Test

2 - New Pattern Context Arc

3 - Hiding Implementation Details

4 - A Completed Context Arc

