                    Applying Functional Principles In CSharp
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A very quick overview of the course


                    Section 2
1 - Introduction

2 - Getting Started

3 - Course Outline and Prerequisites

4 - What Is Functional Programming?

5 - Why Functional Programming?

6 - Summary



                    Section 3 - Refactoring to an Immutable Architecture
1 - Introduction
A brief introduction to what lies ahead in the chapter

2 - Vocabulary Used

3 - Why Does Immutability Matter?

4 - Mutability and Temporal Coupling

5 - Immutability Limitations

6 - How to Deal with Side Effects

7 - Example Introduction

8 - Mutable Implementation

9 - Refactoring the First Method

10 - Refactoring the Second Method

11 - Implementing a Mutable Shell

12 - Recap: Refactoring to an Immutable Architecture

13 - Summary



                    Section 4 - Refactoring Away from Exceptions
1 - Introduction
0m 26s
Exceptions and Readability
3m 16s
Use Cases for Exceptions
3m 14s
Fail Fast Principle
4m 30s
Where to Catch Exceptions
4m 11s
The Result Class
6m 38s
Recap: The Result Class
1m 22s
The Result Class and CQS
1m 25s
Refactoring Away from Exceptions
5m 59s
Summary
1m 45s
5
Avoiding Primitive Obsession
20m 25s
Introduction
0m 23s
What Is Primitive Obsession?
2m 41s
How to Get Rid of Primitive Obsession
3m 6s
Primitive Obsession and Defensive Programming
1m 16s
Primitive Obsession: Limitations
1m 19s
Where to Convert Primitive Types into Value Objects?
1m 47s
Refactoring Away from Primitive Obsession
6m 55s
Recap: Refactoring Away from Primitive Obsession
1m 33s
Summary
1m 21s
6
Avoiding Nulls with the Maybe Type
26m 11s
Introduction
0m 18s
The Billion-dollar Mistake
4m 18s
Non-nullability on the Language Level
2m 43s
Mitigating the Billion-dollar Mistake
7m 11s
Enforcing the Use of the Maybe Type
6m 38s
Recap: Mitigating the Billion-dollar Mistake
1m 56s
Limitations
1m 48s
Summary
1m 16s
7
Handling Failures and Input Errors in a Functional Way
16m 47s
Introduction
0m 18s
Traditional Approach to Handling Failures and Input Errors
2m 33s
Refactoring the Method Using the Result and Maybe Types
3m 59s
Introducing Railway-oriented Programming
6m 51s
Recap: Introducing Railway-oriented Programming
1m 45s
Summary
1m 18s
8
Putting It All Together
65m 17s
Introduction
0m 48s
Domain Model Introduction
1m 58s
Application Code Introduction
9m 18s
Refactoring Away from Exceptions
10m 12s
Recap: Refactoring Away from Exceptions
1m 2s
Refactoring Away from Primitive Obsession
8m 46s
Recap: Refactoring Away from Primitive Obsession
1m 1s
Refactoring to More Explicit Code
6m 24s
Recap: Refactoring to More Explicit Code
0m 43s
Making Nulls Explicit
6m 40s
Recap: Making Nulls Explicit
0m 48s
Representing Reference Data as Code
3m 57s
Recap: Representing Reference Data as Code
2m 9s
Railway-oriented Programming
5m 57s
Recap: Railway-oriented Programming
1m 11s
Module Summary
1m 45s
Resource List
1m 3s
Course Summary
1m 26s
