                    Applying Functional Principles In CSharp
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
A very quick overview of the course


                    Section 2 - Introduction
1 - Getting Started
A brief introduction to what lies ahead in the course

2 - Course Outline and Prerequisites
The student should be at least familiar with the features of C# that help write code in a more functional way
These features are - LINQ, Lambdas, Delegates
A brief introduction to what lies ahead in the chapter

3 - What Is Functional Programming?

4 - Why Functional Programming?

5 - Summary



                    Section 3 - Refactoring to an Immutable Architecture
1 - Introduction
A brief introduction to what lies ahead in the chapter

2 - Vocabulary Used

3 - Why Does Immutability Matter?

4 - Mutability and Temporal Coupling

5 - Immutability Limitations

6 - How to Deal with Side Effects

7 - Example Introduction

8 - Mutable Implementation

9 - Refactoring the First Method

10 - Refactoring the Second Method

11 - Implementing a Mutable Shell

12 - Recap: Refactoring to an Immutable Architecture

13 - Summary



                    Section 4 - Refactoring Away from Exceptions
1 - Introduction

2 - Exceptions and Readability

3 - Use Cases for Exceptions

4 - Fail Fast Principle

5 - Where to Catch Exceptions

6 - The Result Class

7 - Recap: The Result Class

8 - The Result Class and CQS

9 - Refactoring Away from Exceptions

10 - Summary



                    Section 5 - Avoiding Primitive Obsession
1 - Introduction

2 - What Is Primitive Obsession?

3 - How to Get Rid of Primitive Obsession

4 - Primitive Obsession and Defensive Programming

5 - Primitive Obsession: Limitations

6 - Where to Convert Primitive Types into Value Objects?

7 - Refactoring Away from Primitive Obsession

8 - Recap: Refactoring Away from Primitive Obsession

9 - Summary



                    Section 6 - Avoiding Nulls with the Maybe Type
1 - Introduction

2 - The Billion-dollar Mistake

3 - Non-nullability on the Language Level

4 - Mitigating the Billion-dollar Mistake

5 - Enforcing the Use of the Maybe Type

6 - Recap: Mitigating the Billion-dollar Mistake

7 - Limitations

8 - Summary



                    Section 7 - Handling Failures and Input Errors in a Functional Way
1 - Introduction
Traditional Approach to Handling Failures and Input Errors
2m 33s
Refactoring the Method Using the Result and Maybe Types
3m 59s
Introducing Railway-oriented Programming
6m 51s
Recap: Introducing Railway-oriented Programming
1m 45s
Summary
1m 18s
8
Putting It All Together
65m 17s
Introduction
0m 48s
Domain Model Introduction
1m 58s
Application Code Introduction
9m 18s
Refactoring Away from Exceptions
10m 12s
Recap: Refactoring Away from Exceptions
1m 2s
Refactoring Away from Primitive Obsession
8m 46s
Recap: Refactoring Away from Primitive Obsession
1m 1s
Refactoring to More Explicit Code
6m 24s
Recap: Refactoring to More Explicit Code
0m 43s
Making Nulls Explicit
6m 40s
Recap: Making Nulls Explicit
0m 48s
Representing Reference Data as Code
3m 57s
Recap: Representing Reference Data as Code
2m 9s
Railway-oriented Programming
5m 57s
Recap: Railway-oriented Programming
1m 11s
Module Summary
1m 45s
Resource List
1m 3s
Course Summary
1m 26s
