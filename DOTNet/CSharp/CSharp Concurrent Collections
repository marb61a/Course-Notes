                    C# Concurrent Collections
                    Course Notes


                    Section 1 - Introducing the Concurrent Collections
1 - Welcome and Course Overview
Brief intro to the author
The Concurrent Collections are a new set of collection types (they were introduced in .NET4)
  - They are specifically designed to be used in a multi threaded environment
The goal of the course is to teach the student how to use these collections safely and correctly
There is an introduction to the course syllabus
  - The course starts of covering mainly concepts
There are some prerequisites
  - It is not a general threading course
  - You should know how to use Generics

2 - Module Overview
A quick run through of the material to be covered in the module

3 - Introducing the Sample: The Geek Clothing Company
Demo of the Submit Orders App
  - The demo is for a sample app which simulates accepting orders for t-shirts
Example Syntax
  // Program.cs
  static void main(string[] args){
    var orders = new Queue<string>();
    PlaceOrders(orders, "Mark");
    PlaceOrders(orders, "Ramdevi");
    
    foreach(order in orders)
      Console.Writeline("Order: " + order);
  }
  
  static void PlaceOrders(Queue<string> orders, string customerName){
    for(int i = 0; i < 5; i++){
      Thread.Sleep(1);
      string orderName = string.Format("{0} wants t-shirt {1}", customerName, i + 1);
      orders.Enqueue(orderName);
    }
  }

4 - Making the Queue Multithreaded  
Continuing on from the previous section but making the example multithreaded
Example Syntax
  // Program.cs
  // This code will have an intermittent bug due to thread safety issues with the enqueue method
  // This method which is inbuilt is not guaranteed to be thread safe
  static void main(string[] args){
    var orders = new Queue<string>();
    
    // Using threads for order placement
    Task task1 = Task.Run(() => PlaceOrders(orders, "Mark"));
    Task task2 = Task.Run(() => PlaceOrders(orders, "Ramdevi"));
    
    // This means that both tasks must finish before we can see what is in the queue
    Task.WaitAll(task1, task2);
    
    foreach(order in orders)
      Console.Writeline("Order: " + order);
  }
  
  static void PlaceOrders(Queue<string> orders, string customerName){
    for(int i = 0; i < 5; i++){
      Thread.Sleep(1);
      string orderName = string.Format("{0} wants t-shirt {1}", customerName, i + 1);
      orders.Enqueue(orderName);
    }
  }

5 - Fixing the Code with ConcurrentQueue<T>
Example Syntax
  // Replacing Queue with ConcurrentQueue
  // ConcurrentQueue works similar to Queue but is Thread-Safe
  // Unfortunately most standard types do not have matching concurrent types
  // The techniques used in concurrent programmin are different than non-concurrent and requires a new mindset
  // Program.cs
  static void main(string[] args){
    // ConcurrentQueue is in the System.Collections.Concurrent namespace so a using statement will need to be added
    var orders = new ConcurrentQueue<string>();
    
    // Using threads for order placement
    Task task1 = Task.Run(() => PlaceOrders(orders, "Mark"));
    Task task2 = Task.Run(() => PlaceOrders(orders, "Ramdevi"));    
    Task.WaitAll(task1, task2);
    
    foreach(order in orders)
      Console.Writeline("Order: " + order);
  }
  
  static void PlaceOrders(ConcurrentQueue<string> orders, string customerName){
    for(int i = 0; i < 5; i++){
      Thread.Sleep(1);
      string orderName = string.Format("{0} wants t-shirt {1}", customerName, i + 1);
      orders.Enqueue(orderName);
    }
  }

6 - Why Did Queue<T>.EnQueue() Fail?

7 - Atomic Methods

8 - Why Locks Aren't Always So Great

9 - Concurrent Collections Don't Always Block Threads

10 - Concurrent Collections and Race Conditions

11 - What Concurrent Collections Are There?

12 - IProducerConsumerCollection<T> and BlockingCollection<T>

13 - Partitioner<T> and OrderablePartitioner<T>

14 - Module Summary
A quick summary on the material just covered



                    Section 2 - Introducing ConcurrentDictionary
1 - Module Overview
A very brief overview of the material to be covered in the section 

2 - Basic Dictionary Operations

3 - Converting to ConcurrentDictionary

4 - Why Is ConcurrentDictionary.Add() Hidden?

5 - Some Thread-friendly Methods

6 - The TryXXX Pattern and TryGetValue()

7 - The TryAdd() Method

8- The TryRemove() Method

9 - The TryUpdate() Method

10 - The Problem with TryUpdate()

11 - The AddOrUpdate() Method

12 - Beware Race Conditions!

13 - Do Each Operation in One Method Call!

14 - The GetOrAdd() Method

15 - Module Summary
A quick summary on the material just covered



                    Section 3 - Concurrent Dictionary Demo
1 - Module Overview
A very brief overview of the material to be covered in the section 

2 - Introducing the BuyAndSell Sample

3 - The Buy-sell Algorithm

4 - Using AddOrUpdate() to Update the Concurrent Dictionary

5 - Using Interlocked.Add() to Update the Total

6 - Thread-safe ... But No Locks!

7 - Why Can't We Use TryUpdate()?

8 - Conditionally Updating the Concurrent Dictionary

9 - Conditional Logic in AddOrUpdate(): Using a Lambda

10 - The Problem of Side-effects

11 - AddOrUpdate(): Avoiding Conditional Logic

12 - Summing ConcurrentDictionary Values Using Linq

13 - Using GetOrAdd() to Display Values

14 - Let's Stress-test the Demo!

15 - Module Summary
A quick run through of what the course covered in the chapter



                    Section 4 - The Producer-Consumer Collections: Queues, Stacks and Bags
1 - Module Overview
A very brief overview of the material to be covered in the section 

2 - A Queue Refresher

3 - Introducing ConcurrentQueue<T>

4 - ConcurrentStack<T>

5 - ConcurrentBag<T>: What Is It?

6 - What Is a Producer-consumer Scenario?

7 - The IProducerConsumerCollection<T> Interface

8 - Module Summary
A quick run through of what the course covered in the chapter



                    Section 5 - Producer-consumer and BlockingCollection Demo
1 - Module Overview
A very brief overview of the material to be covered in the section 

2 - Introducing the SalesBonuses Sample

3 - Logging Trades to the To-do Queue

4 - Enqueuing to the Concurrent Queue

5 - The Consumer Loop: Monitoring the Concurrent Queue

6 - The Main Program Flow

7 - Calculating Bonuses

8 - The Problem of Polling

9 - Introducing the Blocking Collection

10 - Using BlockingCollection<T>.Take() to Avoid Polling

11 - BlockingCollection<T> and IProducerConsumerCollection<T>

12 - BlockingCollection<T> Additional Features

13 - Module Summary
A quick run through of what the course covered in the chapter



                    Section 6 - Some Concurrent Collections Best Practices
1 - Module Overview
A very brief overview of the material to be covered in the section 

2 - Concurrent Collections and Performance

3 - Benchmarking ConcurrentDictionary with Multiple Threads

4 - Access Shared State Sparingly

5 - ConcurrentDictionary Uses Fine-grained Locking

6 - Count, IsEmpty, Etc. Perform Badly on ConcurrentDictionary

7 - Avoid Relying on the State of Concurrent Collections

8 - Enumerating While Modifying a Standard Collection

9 - Enumerating While Modifying a Concurrent Collection

10 - When Do You Need Concurrent Collections?

11 - Module Summary
A quick run through of what the course covered in the chapter

12 - Thanks to the Modelsâ€¦

13 - Course Summary
A quick run through of what the course covered in the course

