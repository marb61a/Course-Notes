                    C# Concurrent Collections
                    Course Notes


                    Section 1 - Introducing the Concurrent Collections
1 - Welcome and Course Overview
Brief intro to the author
The Concurrent Collections are a new set of collection types (they were introduced in .NET4)
  - They are specifically designed to be used in a multi threaded environment
The goal of the course is to teach the student how to use these collections safely and correctly
There is an introduction to the course syllabus
  - The course starts of covering mainly concepts
There are some prerequisites
  - It is not a general threading course
  - You should know how to use Generics

2 - Module Overview
A quick run through of the material to be covered in the module

3 - Introducing the Sample: The Geek Clothing Company
Demo of the Submit Orders App
  - The demo is for a sample app which simulates accepting orders for t-shirts
Example Syntax
  // Program.cs
  static void main(string[] args){
    var orders = new Queue<string>();
    PlaceOrders(orders, "Mark");
    PlaceOrders(orders, "Ramdevi");
    
    foreach(order in orders)
      Console.Writeline("Order: " + order);
  }
  
  static void PlaceOrders(Queue<string> orders, string customerName){
    for(int i = 0; i < 5; i++){
      Thread.Sleep(1);
      string orderName = string.Format("{0} wants t-shirt {1}", customerName, i + 1);
      orders.Enqueue(orderName);
    }
  }

4 - Making the Queue Multithreaded  
Continuing on from the previous section but making the example multithreaded
Example Syntax
  // Program.cs
  // This code will have an intermittent bug due to thread safety issues with the enqueue method
  // This method which is inbuilt is not guaranteed to be thread safe
  static void main(string[] args){
    var orders = new Queue<string>();
    
    // Using threads for order placement
    Task task1 = Task.Run(() => PlaceOrders(orders, "Mark"));
    Task task2 = Task.Run(() => PlaceOrders(orders, "Ramdevi"));
    
    // This means that both tasks must finish before we can see what is in the queue
    Task.WaitAll(task1, task2);
    
    foreach(order in orders)
      Console.Writeline("Order: " + order);
  }
  
  static void PlaceOrders(Queue<string> orders, string customerName){
    for(int i = 0; i < 5; i++){
      Thread.Sleep(1);
      string orderName = string.Format("{0} wants t-shirt {1}", customerName, i + 1);
      orders.Enqueue(orderName);
    }
  }

5 - Fixing the Code with ConcurrentQueue<T>

6 - Why Did Queue<T>.EnQueue() Fail?

7 - Atomic Methods

8 - Why Locks Aren't Always So Great

9 - Concurrent Collections Don't Always Block Threads

10 - Concurrent Collections and Race Conditions

11 - What Concurrent Collections Are There?

12 - IProducerConsumerCollection<T> and BlockingCollection<T>

13 - Partitioner<T> and OrderablePartitioner<T>

14 - Module Summary
A quick summary on the material just covered



                    Section 2 - Introducing ConcurrentDictionary
1 - Module Overview

2 - Basic Dictionary Operations

3 - Converting to ConcurrentDictionary

4 - Why Is ConcurrentDictionary.Add() Hidden?

5 - Some Thread-friendly Methods

6 - The TryXXX Pattern and TryGetValue()

7 - The TryAdd() Method

8- The TryRemove() Method

9 - The TryUpdate() Method

10 - The Problem with TryUpdate()

11 - The AddOrUpdate() Method

12 - Beware Race Conditions!

13 - Do Each Operation in One Method Call!

14 - The GetOrAdd() Method

15 - Module Summary
A quick summary on the material just covered



                    Section 3 - Concurrent Dictionary Demo
1 - Module Overview
A very brief overview of the material to be covered in the section 

2 - Introducing the BuyAndSell Sample

3 - The Buy-sell Algorithm

4 - Using AddOrUpdate() to Update the Concurrent Dictionary

5 - Using Interlocked.Add() to Update the Total

6 - Thread-safe ... But No Locks!

7 - Why Can't We Use TryUpdate()?

Conditionally Updating the Concurrent Dictionary
2m 37s
Conditional Logic in AddOrUpdate(): Using a Lambda
3m 3s
The Problem of Side-effects
2m 50s
AddOrUpdate(): Avoiding Conditional Logic
4m 18s
Summing ConcurrentDictionary Values Using Linq
3m 2s
Using GetOrAdd() to Display Values
1m 27s
Let's Stress-test the Demo!
2m 20s
Module Summary



                    Section 4 - The Producer-Consumer Collections: Queues, Stacks and Bags
1 - Module Overview

2 - A Queue Refresher
2m 30s
Introducing ConcurrentQueue<T>
3m 23s
ConcurrentStack<T>
2m 16s
ConcurrentBag<T>: What Is It?
4m 20s
What Is a Producer-consumer Scenario?
3m 35s
The IProducerConsumerCollection<T> Interface
3m 57s
Module Summary
1m 11s
5
Producer-consumer and BlockingCollection Demo
27m 28s
Module Overview
0m 53s
Introducing the SalesBonuses Sample
3m 24s
Logging Trades to the To-do Queue
1m 51s
Enqueuing to the Concurrent Queue
1m 29s
The Consumer Loop: Monitoring the Concurrent Queue
2m 31s
The Main Program Flow
2m 3s
Calculating Bonuses
3m 55s
The Problem of Polling
1m 3s
Introducing the Blocking Collection
2m 19s
Using BlockingCollection<T>.Take() to Avoid Polling
3m 18s
BlockingCollection<T> and IProducerConsumerCollection<T>
1m 48s
BlockingCollection<T> Additional Features
1m 39s
Module Summary
1m 8s
6
Some Concurrent Collections Best Practices
38m 47s
Module Overview
1m 30s
Concurrent Collections and Performance
4m 45s
Benchmarking ConcurrentDictionary with Multiple Threads
4m 34s
Access Shared State Sparingly
4m 7s
ConcurrentDictionary Uses Fine-grained Locking
2m 9s
Count, IsEmpty, Etc. Perform Badly on ConcurrentDictionary
2m 46s
Avoid Relying on the State of Concurrent Collections
1m 57s
Enumerating While Modifying a Standard Collection
2m 16s
Enumerating While Modifying a Concurrent Collection
3m 29s
When Do You Need Concurrent Collections?
5m 31s
Module Summary
1m 45s
Thanks to the Modelsâ€¦
1m 58s
Course Summary
1m 53s
