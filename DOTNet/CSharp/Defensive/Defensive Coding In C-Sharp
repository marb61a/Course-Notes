                    Defensive Coding In C#
                    Course Notes
                    
                    
                    Section 1 - Introduction
1 - Intro
Very quick overview of the course and intro to the author

2 - What Is Defensive Coding 
Defensive Coding is an approach to improve software and source code in terms of
  - General Quality which will reduces bugs and other issues
    - This is usually done with automated code testing
  - Making the source code comprehensible so that it is readable and understandable in a code audit
  - Making the software behaviour predicatble despite unexpected actions or inputs
The goals of Defensive Coding are
  - Clean Code which improves comprehension, simplifies maintenance and reduces bugs
  - Testable Code & Unit Tests which improves quality, confirms maintenance and reduces bugs

3 - Clean Code
Comprehensive Notes on Clean Code principles available at 
  - https://github.com/marb61a/Course-Notes/blob/master/DOTNet/CSharp/C# Developers: Learn the Art of Writing Clean Code 
  
4 - Testable Code And Unit Tests
Testable Code has many of the characteristics of clean code

5 - Predictable Code

6 - Topics
A quick overview of the topics covered in the course



                    Section 2 - Defending Your Methods Part 1
1 - Introduction
A quick introduction to what this section will cover

2 - Clean Testable And Predictable Methods
Clean Testable And Predictable Methods have the following characteristics
  - Each method has a clear single purpose
  - The method name should be a good ie identify its purpose
  - There should be focused code
  - The method should be as short in length as possible
  - You should be able to call it from an automated code test
  - There should be predictable results

3 - Example Clean Testable And Predictable Methods
A pseudocode example that is common in Windows Forms and Web Forms
  - This covers a button click event and would have 3 screens
Example Syntax
  public void button1_Click(){
    // ---- If this is a new customer then create the customer record ----
    // Determine whether or not the customer is an existing one
    // If not validate the information entered by the customer
    // If not valid then notify the user
    // If valid then open a connection
    // Set the stored procedure paramaters with the customer data and then call the save stored procedure
    
    // ---- Create the order for the customer----
    // If not validate the information entered by the customer
    // If not valid then notify the user
    // If valid then open a connection
    // Set the stored procedure paramaters with the order data and then call the save stored procedure
    
    // ---- Orders the item from inventory----
    // For each item ordered locate the item in inventory
    // If they are no longer available notify the user
    // If the items are back ordered and the customer does not wish to split orders then notify the customer
    // If the item is available decrement the quantity remaining
    // Open a connection
    // Set the stored procedure paramaters with the inventory data and then call the save stored procedure
    
    // ---- Process the payment ----
    // If using a credit card then process the credit card payment
    // If using Paypal then process the Paypal payment
    // If there is an issue then notify the user
    // Open a connection
    // Set the stored procedure paramaters with the payment data and then call the save stored procedure
    
    // ---- Send an email receipt ----
    // If the user requested a receipt, get the customer data and ensure email provided is valid
    // If not request an email address from the user
    // Open a connection
    // Set the stored procedure paramaters with the customer data and then call the save stored procedure
    // If a valid email address has been provided send a receipt
    
  }
If this code was real
  - The code would have a code smell due to several things
  - This method can perform several tasks, code in a method should be focused on one thing
  - It is also very badly named, good names help convey what the code is doing

4 - Demo Creating A Class Library Component
Example using Pseudo-code

5 - Demo Clean Testable And Predictable Methods

6 - Demo Named Argument

7 - Key Points
A quick overview of the main points covered in the section



                    Section 3 - Defending Your Methods Part 2
1 - Introduction
A quick introduction to what this section will cover

2 - Validating Mathod Parameters
Example Syntax
  // Example Code
  // A method takes in a set of inputs as method parameters, performs operations and returns a value in some cases
  public void PlaceOrder(Customer customer, Order order, Payment payment, bool allowSplitOrders, bool emailReceipt){
    cutomerRepository.Add(customer);
    orderRepository.Add(customer);
    inventoryRepository.OrderItems(order.allowSplitOrders);
    payment.ProcessPayment(payment);
    
    if(emailReceipt){
      customer.validateEmail();
      customerRepository.Update();
      emailLibrary.SendEmail(customer.EmailAddress, "Here is your receipt")
    }
  }
The first step to making a method predictable is to add guards to check incoming parameters
  - Only open the gates to valid input
  - Guards can check for null, invalid or unexpected values
  - Guard Clauses are code statemants that are written at the top of the method and validate incoming parameters
  - The number of parameters should be minimised, the fewer the better as they need validation
  - There could also be a convention for parameter ordering to give consistency

3 - Demo Validating Method Parameters
Example Syntax
  // Reusing the Acme example, the scenario is in the health industry on this occasion, it provides
  // customers with new features to entice them to return. In the example there is a pedometer WinForm application
  namespace{
    public partial class PedometerWin : Form
    {
      public PedometerWin(){
        InitializeComponent();
      }
      
      private void CalculateButton_Click(object sender, EventArgs e)
      {
        var customer = new Customer();
        var result = customer.CalculatePercentOfGoalSteps(this.GoalTextBox.Text, this.StepsTextBox.Text);
        ResultLabel.Text = "You reached " + result + "% of your goal";
      }
    }
  }
  
  // The CalculatePercentOfGoalSteps method syntax
  public decimal CalculatePercentOfGoalSteps(string goalSteps, string actualSteps)
  {
      // There is an unhandled divide by zero exception here
      return(Convert.ToDecimal(actualSteps) / Convert.ToDecimal(goalSteps)) * 100;

    // The second attempt at protecting the method by handling the divide by zero issue
    decimal result = 0;
    
    // This will have an exception as ToDecimal is expecting an actual value and if empty will crash
    var goalStepCount = Convert.ToDecimal(goalSteps);
    if(goalStepCount > 0){
      result = (Convert.ToDecimal(actualSteps) / goalStepCount) * 100;
    }
    
    return result;
  }

4 - Demo Method Overloading
Method overloading allows 

5 - Key Points
A quick overview of the main points covered in the section



                    Section 4 - Automated Code Testing
1 - Introduction
A quick introduction to what this section will cover

2 - Don't Have Time To Test

3 - Code First vs Test First

4 - Defining Unit Test Cases

5 - Creating Unit Tests

6 - Using Test Explorer

7 - Generating Unit Tests

8 - Unit Tests And Exceptions

9 - Dependencies

10 - Summary
A brief summary of what the chapter covered



                    Section 5 - Defending Your Methods Part 3 Returning Predicatble Results
1 - Introduction
A quick introduction to what this section will cover

2 - Method Results
GIGO - Acronym Garbage In Garbage Out
  - A clean method should not return garbage irrespective of what it takes in
  Example Syntax
  customer.ValidateEmail()
    - This method would validate whether a customer has a valid email address
    - It should have some way to tell calling code that an address is invalid
  - There are several way of providing results such as returning a value
    - For example return 0 if a problem occurs
      - This has a limit as it does not describe the problem
    - Most programmers do not return errors recently
  - An alternative to returning values is to throw exceptions
    - Exceptions were originally intended to report failures and using them to validate business rules may not be appropriate
  - The option that makes the most sense is to return a set of values
  - It is possible to return null eg Nullable Types
    - Most developers recommend not returning null

3 - Demo Returning A Value


4 - Demo Returning Exceptions

5 - Demo Returning Multiple Values

6 - Returning Null

7 - Summary
A brief summary of what the chapter covered



                    Section 6 - Defending Your Code Constructs
1 - Introduction
A quick introduction to what this section will cover

2 - Local Variable Declaration

3 - If Statements

4 - Switch Statements

5 - Enums

6 - Casting

7 - Summary
A brief summary of what the chapter covered

          
          
                    Section 7 - Asserts, Errors And Exceptions
1 - Introduction
A quick introduction to what this section will cover

2 - Demo: Preparing The Code Sample

3 - Asserts

4 - Anticipated Errors

5 - Unexpected Exceptions And A Global Exception Handler

6 - Exception Handling

7 - Summary
A brief summary of what the chapter covered



                    Section 8 - Final Words
1 - Introduction
A quick introduction to what this section will cover

2 - Legacy Code
Legcay Code has several different definitions
  - Code developed with older technologies
  - Code that has been inherited from an older version of the application
  - Code that has been inherited from someone else
  - Code that is no longer under development but is only being patched
  - Code that has an excessive amount of technical debt
The code developed today will be the legacy code of tomorrow
Tips for working with existing legacy code
  - Look at each method you have to change and evaluate its assumptions eg valid or invalid input assumptions
  - Where it is possible write automated code tests, they will provide documentation of the method assumptions
  - After doing the tests, ensure that the tests pass
  - After the above then the refactoring should begin again making sure that tests still pass
  - Make the change, this again may need new tests which still need to pass
  - Although the process may seem slow repaying technical debt needs to be done
  - If it is only a bug to fix, evaluate the bug and write an automated test which will fail
  - Then fix the issue and retest which should now pass

3 - For More Information

4 - Summary
A brief summary of what the chapter covered

