                    Defensive Coding In C#
                    Course Notes
                    
                    
                    Section 1 - Introduction
1 - Intro
Very quick overview of the course and intro to the author

2 - What Is Defensive Coding 
Defensive Coding is an approach to improve software and source code in terms of
  - General Quality which will reduces bugs and other issues
    - This is usually done with automated code testing
  - Making the source code comprehensible so that it is readable and understandable in a code audit
  - Making the software behaviour predicatble despite unexpected actions or inputs
The goals of Defensive Coding are
  - Clean Code which improves comprehension, simplifies maintenance and reduces bugs
  - Testable Code & Unit Tests which improves quality, confirms maintenance and reduces bugs

3 - Clean Code
Comprehensive Notes on Clean Code principles available at 
  - https://github.com/marb61a/Course-Notes/blob/master/DOTNet/CSharp/C# Developers: Learn the Art of Writing Clean Code 
  
4 - Testable Code And Unit Tests
Testable Code has many of the characteristics of clean code

5 - Predictable Code

6 - Topics
A quick overview of the topics covered in the course



                    Section 2 - Defending Your Methods Part 1
1 - Introduction
A quick introduction to what this section will cover

2 - Clean Testable And Predictable Methods
Clean Testable And Predictable Methods have the following characteristics
  - Each method has a clear single purpose
  - The method name should be a good ie identify its purpose
  - There should be focused code
  - The method should be as short in length as possible
  - You should be able to call it from an automated code test
  - There should be predictable results

3 - Example Clean Testable And Predictable Methods
A pseudocode example that is common in Windows Forms and Web Forms
  - This covers a button click event and would have 3 screens
Example Syntax
  public void button1_Click(){
    // ---- If this is a new customer then create the customer record ----
    // Determine whether or not the customer is an existing one
    // If not validate the information entered by the customer
    // If not valid then notify the user
    // If valid then open a connection
    // Set the stored procedure paramaters with the customer data and then call the save stored procedure
    
    // ---- Create the order for the customer----
    // If not validate the information entered by the customer
    // If not valid then notify the user
    // If valid then open a connection
    // Set the stored procedure paramaters with the order data and then call the save stored procedure
    
    // ---- Orders the item from inventory----
    // For each item ordered locate the item in inventory
    // If they are no longer available notify the user
    // If the items are back ordered and the customer does not wish to split orders then notify the customer
    // If the item is available decrement the quantity remaining
    // Open a connection
    // Set the stored procedure paramaters with the inventory data and then call the save stored procedure
    
    // ---- Process the payment ----
    // If using a credit card then process the credit card payment
    // If using Paypal then process the Paypal payment
    // If there is an issue then notify the user
    // Open a connection
    // Set the stored procedure paramaters with the payment data and then call the save stored procedure
    
    // ---- Send an email receipt ----
    // If the user requested a receipt, get the customer data and ensure email provided is valid
    // If not request an email address from the user
    // Open a connection
    // Set the stored procedure paramaters with the customer data and then call the save stored procedure
    // If a valid email address has been provided send a receipt
    
  }
If this code was real
  - The code would have a code smell due to several things
  - This method can perform several tasks, code in a method should be focused on one thing
  - It is also very badly named, good names help convey what the code is doing

4 - Demo Creating A Class Library Component
Example using Pseudo-code

5 - Demo Clean Testable And Predictable Methods

6 - Demo Named Argument

7 - Key Points
A quick overview of the main points covered in the section



                    Section 3 - Defending Your Methods Part 2
1 - Introduction
A quick introduction to what this section will cover

2 - Validating Mathod Parameters
Example Syntax
  // Example Code
  // A method takes in a set of inputs as method parameters, performs operations and returns a value in some cases
  public void PlaceOrder(Customer customer, Order order, Payment payment, bool allowSplitOrders, bool emailReceipt){
    cutomerRepository.Add(customer);
    orderRepository.Add(customer);
    inventoryRepository.OrderItems(order.allowSplitOrders);
    payment.ProcessPayment(payment);
    
    if(emailReceipt){
      customer.validateEmail();
      customerRepository.Update();
      emailLibrary.SendEmail(customer.EmailAddress, "Here is your receipt")
    }
  }
The first step to making a method predictable is to add guards to check incoming parameters
  - Only open the gates to valid input
  - Guards can check for null, invalid or unexpected values
  - Guard Clauses are code statemants that are written at the top of the method and validate incoming parameters
  - The number of parameters should be minimised, the fewer the better as they need validation
  - There could also be a convention for parameter ordering to give consistency

3 - Demo Validating Method Parameters

4 - Demo Method Overloading
Method overloading allows 

5 - Key Points
A quick overview of the main points covered in the section



                    Section 4 - Automated Code Testing
1 - Introduction
A quick introduction to what this section will cover

2 - Don't Have Time To Test

3 - Code First vs Test First

4 - Defining Unit Test Cases

5 - reating Unit Tests

6 - Using Test Explorer

7 - Generating Unit Tests

8 - Unit Tests And Exceptions

9 - Dependencies

10 - Summary



                    Section 5 - Defending Your Methods Part 3 Returning Predicatble Results
1 -

2 - 


                    Section 6 - Defending Your Code Constructs
1 - 

2 - 
                    
                    Section 7 - Asserts, Errors And Exceptions
1 - Introduction
A quick introduction to what this section will cover

2 - Demo: Preparing The Code Sample

3 - 

6 - Exception Handling

7 - Summary
A brief summary of what the chapter covered



                    Section 8 - Final Words
1 - Introduction
A quick introduction to what this section will cover

2 - Legacy Code
Legcay Code has several different definitions
  - Code developed with older technologies
  - Code that has been inherited from an older version of the application
  - Code that has been inherited from someone else
  - Code that is no longer under development but is only being patched
  - Code that has an excessive amount of technical debt
The code developed today will be the legacy code of tomorrow
Tips for working with existing legacy code
  - Look at each method you have to change and evaluate its assumptions eg valid or invalid input assumptions
  - Where it is possible write automated code tests, they will provide documentation of the method assumptions
  - After doing the tests, ensure that the tests pass
  - After the above then the refactoring should begin again making sure that tests still pass
  - Make the change, this again may need new tests which still need to pass
  - Although the process may seem slow repaying technical debt needs to be done
  - If it is only a bug to fix, evaluate the bug and write an automated test which will fail
  - Then fix the issue and retest which should now pass

3 - For More Information

4 - Summary
A brief summary of what the chapter covered

