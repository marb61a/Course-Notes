                    Advanced Defensive Programming Techniques
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
Brief introduction to both the course and the course author


                    Section 2 - Understanding Limitations of Traditional Defensive Code
1 - The First Law of Defensive Programming
An explanation of what defensive coding is
  - Despite implementation and requirements unexpected events occur eg Disk Full etc
  - The happennings exists as an alternative to the requirements
  - When these events happen there can be confusion on how to deal with them
  - Where possible this confusion or 'Now What' situations should be avoided
  - Defending against this should come out of the box
  - This should be done be ensuring that there is no alternative execution path
  - The instructor would prefer to produce a design which defends from outof the box rather than explicit defensive coding 
  - In this positive and negative scenarios are part of a single flow
  - Explicit defensive coding is always applicable but produce poor results
  - The first law of defensive coding says that if you haveto defend you have already lost

2 - What Follows in This Course?
A run through of what the course consists of
  - This course has a complexity escalation syllabus

3 - Traditional Defensive Techniques
There are some prerequisites
  - Understanding of basic defensive techniques
This course because it is an advanced course covers more than coding
  - It covers coding, design and analysis
A quick run through of traditional defensive techniques
  - These are where defensive design begins

4 - Defensive Design: An Experiment
A demonstration of defendive coding vs defensive design
Example Syntax
  // Defensive Coding
  // The else branch is the defensive part
  if(data.any()){
    int min = data.Min();
    ReportSuccess(min);
  } else {
    ReportFailure();
  }
  
  
  // Sequential Search Algorithm
  bool Contains(int [] ar, int search){
    for(int i = 0; i < ar.Length, i++){
      if(ar[i] == search){
        return true;
      }
    }
    return false;
  }
  
  // The alternative Quick Sequential Search Algorithm
  bool Contains(int [] ar, int search){
    int end = ar.Length -1;
    int last = ar[end];
    ar[end] = search;
    
    int index = 0;
    while(ar[index] != search){
      index = index + 1;
    }
    
    ar[end] = last;
    return index < end || last == search;
  }

5 - Called Method Cannot Defend
When there is an error there are 2 function involved 
  - The caller and the callee
  - Error always jumps out in the callee only because the the current instruction which failed resides in it
  - One possibility is that the error could be prevented if the faulty instruction was avoided
  - The can be a guard either before or after the error occurs
  - Guarding before means wrapping in an if statement and only executing if conditions are met
  - Guarding after means putting the instruction in a try catch block and handle the error when it happens
  - The invoked function has no awareness of the context in which it executes
    - This means that it does not know how to recover
  - The important conclusion from this is that a called function cannnot defend
    - It can detect an error but cannot handle the error
  - Letting the caller know what the error was breaks encapsulation
    - Also exceptions break encapsulation
    - These introduce tight coupling in to an application
  - Some control is helpful when dealing with potentially fatal failures
  - The caller knows the context so can recover from an error in its entirety
  - It is better to defend in the caller function as it is where execution error meets execution context

6 - Defining Function Domains

7 - Summary
A brief summary of the material that the section has covered



                    Section 3 - Removing Corruption by Only Creating Consistent Objects
1 - Creating Objects
Not all objects are the same and lend themselves better to different situations
The chapter will concentrate on creating objects with the emphasis on correctness and consistency
The best defense from error conditions is not to have error conditions in your hands in the first place
The course will develop a sample application from this point
  - It will be a sample college management application

2 - Creating Consistent Objects
Example Syntax
  public class Student{
    // If the name could never be empty there would be no need for defending against it being empty
    // This can be ensured by introducing a factory function for every stateful object
    private string Name {get; set;}                  
  }
In OOP every class comes with an implicit Factory function
  - It is the implict paramterless constructor
  // From the example above
  public Student(){
  
  }
  - The compiler will add these silently if not defined
  - In C# turns fields to their default values, eg Boolean to false etc

3 - Pros and Cons of Multiple Constructors
One drawback that is often mentioned is that they do not have their own names
  - This is because they are named after a class and therefore would not communicate their logic well

Example Syntax
  // Again using the student example
  using System;
  
  namespace Domain{
    public class Student{
      public string Name {get;}
      public Semester Enrolled {get; private set;}
      // This causes an issue as the flag is private and nobody can tells its value just by looking at the class
      private bool ComesFromExchange {get;}
      
      public Student(bool comesFromEXchange, string name){
        if(string.IsNullOrEmpty(name))
          throw new ArgumentException();
        
        this.ComesFromExchange = comesFromExchange;
        this.Name = name;
      }
      
      // Students must enroll in semesters in order, any attempt to jump over a semester will cause an exception
      public void Enroll(Semester semester){
        if(semester == null || semester.Predecessor != this.Enrolled)
          throw new ArgumentException();
          
        this.Enrolled = semester
      }
    }
  ]

4 - Understanding Limitations of the Constructor

5 - Promoting Constructor into Builder

6 - Variations in the Builder Implementation

7 - Summary
A brief summary of the material that the section has covered



                    Section 4 - Removing Corruption by Only Making Valid State Transitions
1 - Reaping the Benefits of Constructor Validation

2 - Defending in Property Setters

3 - Understanding Distinct Kinds of Properties

4 - Defending in Complex Mutations

5 - Function Domains Revisited

6 - When Constructor Depends on Multiple Objects

7 - Creating Objects in Small Steps

8 - Persistence and Parameterized Constructors

9 - Summary
A brief summary of the material that the section has covered



                    Section 5 - Dismissing Defensive Code by Avoiding Primitive Types
1 - The Reasons to Avoid Enumerations

2 - Alternatives to Enumerations

3 - Converting Enumeration to a Class

4 - The Reasons to Never Stringify Data

5 - Reaping the Benefits of String Encapsulation

6 - Avoiding Primitive Types Altogether

7 - Example: Modeling Money

8 - Persistence: Small-scale CQRS and DDD

9 - Demonstrating Persistence

10 - Summary
A brief summary of the material that the section has covered



                    Section 6 - Defining Function Domains as the Primary Line of Defense
1 - Introducing Guard Clauses

2 - Guarding Against Null Only

3 - Don't Guard Business Rules

4 - Removing Guards Through Design

5 - Turning Domain Rules into Rule Objects

6 - Turning Rule Objects into Active Elements

7 - Completing the Students Filter

8 - Persistence: Querying View Models

9 - Summary
A brief summary of the material that the section has covered



                    Section 7 - Building Defensive Design Instead of Writing Defensive Code
1 - Encapsulating State

2 - Keeping Related Data Together

3 - Turning Chained Ifs into the Chain of Rules

4 - Making Friends with Regular Expressions

5 - Replacing Branching with Regular Expressions

6 - Moving Expressions out to Configuration

7 - Persistence: Creating and Updating Domain Objects

8 - Summary
A brief summary of the material that the section has covered



                    Section 8 - The Principle of Working with Objects, Not with Nulls
1 - Understanding the Role of Null

2 - Why Compilers Still Rely on Null?

3 - Do Not Return Null from a Method

4 - Using Callback on Optional Content

5 - Overloading Existing APIs to Never Return Null

6 - Returning an Optional Object

7 - Implementing Custom Option Type

8 - Consuming the Option

9 - Persistence: Creating Complex Domain Objects

10 - Summary
A brief summary of the material that the section has covered



                    Section 9 - Building Rich Domain Model as an Effective Defense by Design
1 - Reconsidering Immutable Objects

2 - Turning Classes Immutable

3 - Avoiding Aliasing Bugs Altogether

4 - The Downside of Immutability

5 - Constrained Mutability with Set-once Properties

6 - Consuming Semi-mutable Objects

7 - Using Historical Model

8 - Implementing Simple Historical Model

9 - Summary
A brief summary of the material that the section has covered



                    Section 10 - Designing Alternative Workflows Instead of Defending from Errors
1 - Whatâ€™s Wrong with Status Codes?

2 - Understanding Effects of Throwing Exceptions

3 - What Exceptions Are Not Meant to Do

4 - Leave Nothing Exceptional in Exceptions

5 - Returning a Polymorphic Type Instead of an Exception

6 - Separating Positive and Negative Return Values

7 - Inventing the Either Type

8 - Consuming the Either Type

9 - Summary
A brief summary of the material that the section has covered

