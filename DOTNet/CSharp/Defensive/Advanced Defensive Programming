                    Advanced Defensive Programming Techniques
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
Brief introduction to both the course and the course author


                    Section 2 - Understanding Limitations of Traditional Defensive Code
1 - The First Law of Defensive Programming

2 - What Follows in This Course?

3 - Traditional Defensive Techniques

4 - Defensive Design: An Experiment

5 - Called Method Cannot Defend

6 - Defining Function Domains

7 - Summary
A brief summary of the material that the section has covered



                    Section 3 - Removing Corruption by Only Creating Consistent Objects
1 - Creating Objects
Not all objects are the same and lend themselves better to different situations
The chapter will concentrate on creating objects with the emphasis on correctness and consistency
The best defense from error conditions is not to have error conditions in your hands in the first place
The course will develop a sample application from this point
  - It will be a sample college management application

2 - Creating Consistent Objects

3 - Pros and Cons of Multiple Constructors

4 - Understanding Limitations of the Constructor

5 - Promoting Constructor into Builder

6 - Variations in the Builder Implementation

7 - Summary
A brief summary of the material that the section has covered



                    Section 4 - Removing Corruption by Only Making Valid State Transitions
1 - Reaping the Benefits of Constructor Validation

2 - Defending in Property Setters

3 - Understanding Distinct Kinds of Properties

4 - Defending in Complex Mutations

5 - Function Domains Revisited

6 - When Constructor Depends on Multiple Objects

7 - Creating Objects in Small Steps

8 - Persistence and Parameterized Constructors

9 - Summary
A brief summary of the material that the section has covered



                    Section 5 - Dismissing Defensive Code by Avoiding Primitive Types
1 - The Reasons to Avoid Enumerations

2 - Alternatives to Enumerations

3 - Converting Enumeration to a Class

4 - The Reasons to Never Stringify Data

5 - Reaping the Benefits of String Encapsulation

6 - Avoiding Primitive Types Altogether

7 - Example: Modeling Money

8 - Persistence: Small-scale CQRS and DDD

9 - Demonstrating Persistence

10 - Summary



                    Section 6 - Defining Function Domains as the Primary Line of Defense
1 - Introducing Guard Clauses

2 - Guarding Against Null Only

3 - Don't Guard Business Rules

4 - Removing Guards Through Design

5 - Turning Domain Rules into Rule Objects

6 - Turning Rule Objects into Active Elements

7 - Completing the Students Filter

8 - Persistence: Querying View Models

9 - Summary



                    Section 7 - Building Defensive Design Instead of Writing Defensive Code
1 - Encapsulating State

2 - Keeping Related Data Together

3 - Turning Chained Ifs into the Chain of Rules

4 - Making Friends with Regular Expressions

5 - Replacing Branching with Regular Expressions

6 - Moving Expressions out to Configuration

7 - Persistence: Creating and Updating Domain Objects

8 - Summary



                    Section 8 - The Principle of Working with Objects, Not with Nulls
1 - Understanding the Role of Null

2 - Why Compilers Still Rely on Null?

3 - Do Not Return Null from a Method

4 - Using Callback on Optional Content

5 - Overloading Existing APIs to Never Return Null

6 - Returning an Optional Object

7 - Implementing Custom Option Type

8 - Consuming the Option

9 - Persistence: Creating Complex Domain Objects

10 - Summary



                    Section 9 - Building Rich Domain Model as an Effective Defense by Design
1 - Reconsidering Immutable Objects

2 - Turning Classes Immutable

3 - Avoiding Aliasing Bugs Altogether

4 - The Downside of Immutability

5 - Constrained Mutability with Set-once Properties

6 - Consuming Semi-mutable Objects

7 - Using Historical Model

8 - Implementing Simple Historical Model

9 - Summary



                    Section 10 - Designing Alternative Workflows Instead of Defending from Errors
1 - Whatâ€™s Wrong with Status Codes?

2 - Understanding Effects of Throwing Exceptions

3 - What Exceptions Are Not Meant to Do

4 - Leave Nothing Exceptional in Exceptions

5 - Returning a Polymorphic Type Instead of an Exception

6 - Separating Positive and Negative Return Values

7 - Inventing the Either Type

8 - Consuming the Either Type

9 - Summary

