                    Advanced Defensive Programming Techniques
                    Course Notes


                    Section 1 - Course Overview
1 - Course Overview
Brief introduction to both the course and the course author


                    Section 2 - Understanding Limitations of Traditional Defensive Code
1 - The First Law of Defensive Programming

2 - What Follows in This Course?

3 - Traditional Defensive Techniques

4 - Defensive Design: An Experiment

5 - Called Method Cannot Defend

6 - Defining Function Domains

7 - Summary
A brief summary of the material that the section has covered



                    Section 3 - Removing Corruption by Only Creating Consistent Objects
1 - Creating Objects

2 - Creating Consistent Objects

3 - Pros and Cons of Multiple Constructors

4 - Understanding Limitations of the Constructor

5 - Promoting Constructor into Builder

6 - Variations in the Builder Implementation

7 - Summary
A brief summary of the material that the section has covered



                    Section 4 - Removing Corruption by Only Making Valid State Transitions
1 - Reaping the Benefits of Constructor Validation

2 - Defending in Property Setters

3 - Understanding Distinct Kinds of Properties

4 - Defending in Complex Mutations

5 - Function Domains Revisited

6 - When Constructor Depends on Multiple Objects

7 - Creating Objects in Small Steps

8 - Persistence and Parameterized Constructors

9 - Summary
A brief summary of the material that the section has covered



                    Section 5 - Dismissing Defensive Code by Avoiding Primitive Types
45m 26s
The Reasons to Avoid Enumerations
5m 33s
Alternatives to Enumerations
4m 2s
Converting Enumeration to a Class
5m 22s
The Reasons to Never Stringify Data
6m 6s
Reaping the Benefits of String Encapsulation
2m 44s
Avoiding Primitive Types Altogether
3m 14s
Example: Modeling Money
3m 35s
Persistence: Small-scale CQRS and DDD
5m 12s
Demonstrating Persistence
6m 38s
Summary
2m 55s
6
Defining Function Domains as the Primary Line of Defense
44m 1s
Introducing Guard Clauses
5m 30s
Guarding Against Null Only
6m 31s
Don't Guard Business Rules
5m 47s
Removing Guards Through Design
4m 45s
Turning Domain Rules into Rule Objects
2m 23s
Turning Rule Objects into Active Elements
5m 11s
Completing the Students Filter
4m 15s
Persistence: Querying View Models
7m 1s
Summary
2m 34s
7
Building Defensive Design Instead of Writing Defensive Code
42m 50s
Encapsulating State
7m 16s
Keeping Related Data Together
6m 16s
Turning Chained Ifs into the Chain of Rules
5m 21s
Making Friends with Regular Expressions
3m 21s
Replacing Branching with Regular Expressions
5m 38s
Moving Expressions out to Configuration
4m 26s
Persistence: Creating and Updating Domain Objects
7m 38s
Summary
2m 52s
8
The Principle of Working with Objects, Not with Nulls
46m 31s
Understanding the Role of Null
4m 14s
Why Compilers Still Rely on Null?
4m 13s
Do Not Return Null from a Method
6m 39s
Using Callback on Optional Content
3m 53s
Overloading Existing APIs to Never Return Null
4m 33s
Returning an Optional Object
4m 56s
Implementing Custom Option Type
4m 54s
Consuming the Option
6m 29s
Persistence: Creating Complex Domain Objects
4m 15s
Summary
2m 20s
9
Building Rich Domain Model as an Effective Defense by Design
43m 8s
Reconsidering Immutable Objects
6m 56s
Turning Classes Immutable
3m 24s
Avoiding Aliasing Bugs Altogether
4m 6s
The Downside of Immutability
3m 49s
Constrained Mutability with Set-once Properties
6m 19s
Consuming Semi-mutable Objects
3m 31s
Using Historical Model
4m 27s
Implementing Simple Historical Model
6m 47s
Summary
3m 44s
10
Designing Alternative Workflows Instead of Defending from Errors
46m 30s
Whatâ€™s Wrong with Status Codes?
5m 6s
Understanding Effects of Throwing Exceptions
3m 56s
What Exceptions Are Not Meant to Do
7m 1s
Leave Nothing Exceptional in Exceptions
7m 28s
Returning a Polymorphic Type Instead of an Exception
4m 42s
Separating Positive and Negative Return Values
4m 52s
Inventing the Either Type
5m 53s
Consuming the Either Type
3m 15s
Summary
4m 13s
