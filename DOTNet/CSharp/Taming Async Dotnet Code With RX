                    Taming Asynchronous .NET Code With Rx
                    Course Notes
                    
                    Section 1 - Course Overview
1 - Course Overview
A brief introduction to both the course and the instructor
The aim of the course is to have the student able to rewrite callbacks into observbles
There are some prerequisites for the course
  - The student should understand the .Net framework
  - Some familiarity with RxJS (reactive programming for javascript) 


                    Section 2 - Introducing Reactive Programming                   
1 - Introduction 
Introduction to the section and what to expect

2 - Demo:First Reactive Application
This demo scenario is when a customer asks for an active hover area in the application
  - A button will be shown if the mouse hovers for half a second in the area
Example Syntax
  // The example will show both the usual event driven method and also the reactive method
  using System;
  using System.Collections.Generic;
  using System.IO;
  using System.Linq;
  using System.Runtime.InteropServices.WindowsRuntime;
  using Windows.ApplicationModel;
  using Windows.ApplicationModel.Activation;
  using Windows.Foundation;
  using Windows.Foundation.Collections;
  using Windows.UI.Xaml;
  using Windows.UI.Xaml.Controls;
  using Windows.UI.Xaml.Controls.Primitives;
  using Windows.UI.Xaml.Data;
  using Windows.UI.Xaml.Input;
  using Windows.UI.Xaml.Media;
  using Windows.UI.Xaml.Navigation;
  
  namespace ActiveHoverAreaApp{
    // This provides application-specific behavior to supplement the default Application class.
    sealed partial class App : Application {
    
    }
  }

3 - Reactive Programming

4 - Reactive Extensions

5 - Observables And Observers

6 - Marble Diagrams

7 - Demo:Reactive Tickets Search

8 - Summary
A brief summary of the material covered in the section



                    Section 3 - Creating Sequence Of Observables                    
1 - Introduction 
Introduction to the section and what to expect

2 - Simple Observable
Simple observables are the most trivial observables in Reactive programming
  - They are usually used when you need only a single variable or constant
Example Syntax
  // The first simple observable is a sequence with no elements
    - This uses the factory method Observable.Empty;
      - It signals to its observers that its sequence is finished by invoking onCompled() on them
  // The next simple observable
    - Observable.Never;
      - This returns a sequence that never finishes
      - It returns no values or errors
  // The third in the list of simple observables
    - Observable.Throw(exception);
      - This returns a simple sequence that notifies an error
      - This is most frequently used in a Try-Catch block
  // The 4th and final simple Observable
    - Observable.Return("42");
      - This returns a sequence with only one value

3 - Observable Wrappers
After the Simple Observables the next step is to convert a data structure into an Observable
  - A lot of the time this means interacting wih non-reactive API's
  - This means there is a need to be able to wrap the results in Observables
  - If the are not wrapped they will not be able to be consumed in the Observable pipeline
  - The simplest thing to wrap is an Action which is usually a function into an Observable
    - The return value of the action is then returned into the onNext() method followed by onCompleted()
  - The next structure to be converted is a Task 
    - These days the Task Based model is often used with the key words Async and Await
    - If you have one of these API it is easier to wrap into an Observable
    - If using the older style begin() method can be wrapped in an Observable
  - If you have a data structure that can be enumerated such as IEnumerable
    - This can be turned into a sequence where every element will be pushed as an element of the Observable
    - Observables are best explained as the push based equivalent of the pull based Enumerables
      - In Enumerables the consumer is in charge, iterating over the structure at its own pace
      - In Observables however the Observer is passive by standard, it gets notified when there are new values
 - The final source is .NET events
  - An event handler can be used to generate Observables that can be transformed of combined
  - Wrapping around an event is one of the most frequent uses of Obervable Wrappers
Example Syntax
  Observable.Start(() => 42);                           // This is the action wrapper
  Task.ToObservable();                                  // Converts a task to an observable
  IEnumerable numbers ... ToObservable numbers          // Enumerables also have the ToObservable() method
  Observable.EventPattern(searchTextBox, "New Text")    // Events are converted using the Observable.EventPattern method

4 - Generator Functions

5 - Demo Creating Sequences

6 - Subjects

7 - Hot And Cold Observables

8 - Demo Reactive Tickets Command And Async

9 - Summary
A brief summary of the material covered in the section



                    Section 4 - Filtering And Controlling The Sequences
1 - Introduction
Introduction to the section and what to expect

2 - Filtering By Condition

3 - Filtering Head And Tail Elements

4 - Joining Sequences 

5 - Aggregation Operators

6 - Utility Operators

7 - Demo: Adding Search Filtering

8 - Summary
A brief summary of the material covered in the section



                    Section 5 - Simplifying Asynchronous And MultiThreading
1 - Introduction             
Introduction to the section and what to expect
                    
2 - Asynchrony In Rx

3 - Multithreading In Rx

4 - Schedulers

5 - Wrapping Up: Reactive Thinking

6 - Demo: Revisiting Reactive Tickets 

7 - Summary
A brief summary of the material covered in the section
