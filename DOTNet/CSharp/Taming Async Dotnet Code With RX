                    Taming Asynchronous .NET Code With Rx
                    Course Notes
                    
                    Section 1 - Course Overview
1 - Course Overview
A brief introduction to both the course and the instructor
The aim of the course is to have the student able to rewrite callbacks into observbles
There are some prerequisites for the course
  - The student should understand the .Net framework
  - Some familiarity with RxJS (reactive programming for javascript) 


                    Section 2 - Introducing Reactive Programming                   
1 - Introduction 
Introduction to the section and what to expect

2 - Demo:First Reactive Application
This demo scenario is when a customer asks for an active hover area in the application
  - A button will be shown if the mouse hovers for half a second in the area
Example Syntax
  // The example will show both the usual event driven method and also the reactive method
  using System;
  using System.Collections.Generic;
  using System.IO;
  using System.Linq;
  using System.Runtime.InteropServices.WindowsRuntime;
  using Windows.ApplicationModel;
  using Windows.ApplicationModel.Activation;
  using Windows.Foundation;
  using Windows.Foundation.Collections;
  using Windows.UI.Xaml;
  using Windows.UI.Xaml.Controls;
  using Windows.UI.Xaml.Controls.Primitives;
  using Windows.UI.Xaml.Data;
  using Windows.UI.Xaml.Input;
  using Windows.UI.Xaml.Media;
  using Windows.UI.Xaml.Navigation;
  
  namespace ActiveHoverAreaApp{
    // This provides application-specific behavior to supplement the default Application class.
    sealed partial class App : Application {
    
    }
  }

3 - Reactive Programming
Students may need to take the .NET reactive fundamentals course
  - It is recommended by the author that you do
  - This section will run through a quick overview of the reactive programming main points
  - Again like a lot of languages the spreadsheet example is used where a cell reacts to the change in another cell

4 - Reactive Extensions
Rx is the Microsoft Reactive library
  - It is available since 2009
  - It is not as well known as other libraries such as LINQ
  - The reactive library for .NET is called RxExtensions for .NET
  - The RX library is available for multiple languages and platforms such as Ruby, Java etc

5 - Observables And Observers
In .NET events are delegates that allows for a reaction when something happens in the object being observered
  - A more formal way of expressing this is that events are an implementation of the Observer pattern with delegates
  - Events are not first class citizens in .NET, there are some different reasons
    - Clumsy syntax such as +=
    - They are difficult to pass around
    - There is awkward chaining and error handling
    - There is no history of events
Core Interfaces
  IObservable                         IObserver
  Subscribe(IObserver<T>)             void OnNext<T>(T Value)
                                      void OnCompleted()
                                      void OnError(Exception ex)

6 - Marble Diagrams
Marbles are simple diagrams which can be used to graphically demonstrate Observables
  - Some demos of marble diagrams eg OnNext
There are some different sites with demonstrations availalable
  - http://blogs.microsoft.co.il/bnaya/2012/08/12/visual-rx-toc/
  - http://rxmarbles.com                // Javascript orientated but good for understanding principles

7 - Demo:Reactive Tickets Search
The course uses a fictitious support ticket management UWP app called Reactive Tickets
  - The app connects to a SQL Server DB through a Web API service
Example Syntax
  // This demo will show the search-as-you type feature
  // this will be demonstrated using both event and Observable sequences
  // TicketService.cs
  using NewtonSoft.Json;
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Net.Http;
  using System.Net.Http.Headers;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace RxTicketsApp{
    public class TicketService{
      public async Task<List<Ticket>> GetTicketsFromServer(){
        List<Ticket> result = new List<Ticket>();
        using(var client = new HttpClient()){
          var response = await client.GetStringAsync(App.BaseUri); // sends GET request 
          result = JsonConvert.DeserializeObject<List<Ticket>>(response);
        }
        return result;
      }
    }
  }

8 - Summary
A brief summary of the material covered in the section



                    Section 3 - Creating Sequence Of Observables                    
1 - Introduction 
Introduction to the section and what to expect

2 - Simple Observable
Simple observables are the most trivial observables in Reactive programming
  - They are usually used when you need only a single variable or constant
Example Syntax
  // The first simple observable is a sequence with no elements
    - This uses the factory method Observable.Empty;
      - It signals to its observers that its sequence is finished by invoking onCompled() on them
  // The next simple observable
    - Observable.Never;
      - This returns a sequence that never finishes
      - It returns no values or errors
  // The third in the list of simple observables
    - Observable.Throw(exception);
      - This returns a simple sequence that notifies an error
      - This is most frequently used in a Try-Catch block
  // The 4th and final simple Observable
    - Observable.Return("42");
      - This returns a sequence with only one value

3 - Observable Wrappers
After the Simple Observables the next step is to convert a data structure into an Observable
  - A lot of the time this means interacting wih non-reactive API's
  - This means there is a need to be able to wrap the results in Observables
  - If the are not wrapped they will not be able to be consumed in the Observable pipeline
  - The simplest thing to wrap is an Action which is usually a function into an Observable
    - The return value of the action is then returned into the onNext() method followed by onCompleted()
  - The next structure to be converted is a Task 
    - These days the Task Based model is often used with the key words Async and Await
    - If you have one of these API it is easier to wrap into an Observable
    - If using the older style begin() method can be wrapped in an Observable
  - If you have a data structure that can be enumerated such as IEnumerable
    - This can be turned into a sequence where every element will be pushed as an element of the Observable
    - Observables are best explained as the push based equivalent of the pull based Enumerables
      - In Enumerables the consumer is in charge, iterating over the structure at its own pace
      - In Observables however the Observer is passive by standard, it gets notified when there are new values
 - The final source is .NET events
  - An event handler can be used to generate Observables that can be transformed of combined
  - Wrapping around an event is one of the most frequent uses of Obervable Wrappers
Example Syntax
  Observable.Start(() => 42);                           // This is the action wrapper
  Task.ToObservable();                                  // Converts a task to an observable
  IEnumerable numbers ... ToObservable numbers          // Enumerables also have the ToObservable() method
  Observable.EventPattern(searchTextBox, "New Text")    // Events are converted using the Observable.EventPattern method

4 - Generator Functions
When there is no simple result or appropriate structure to wrap around Observables can be made on demand
  - This is the job of Generator functions
  - They generate new Observables for their subscribers
  - The simplest generator function is Observable.range
    - It generates a sequence of values that lie in a particular range and passes them sequentially to Observers
    - It is the push based twin of the Enumerable.range method
  - It is also very common to generate new Observables at a certain pace
    - For this there is 2 different generation functions Interval, Timer
    - Interval only asks for the time span and immediately begins pushing new values starting with zero
    - Timer also asks for the interval but provides a lamda function that will be invoked to provide new values
  - The lowest level of the generation functions are the pure ones
    - Observable.Create() and Observable.Generate()
    - Essentially create() allows you to specify a delegate that will be executed anytime a new subscription is made
      - The Observer interface of the observer that has made the subscription will be passed to a delegate
      - You can call onNext(), onError() and onComplete() as you need
      - You will have to return an IDisposable reference for the observer to be able to unsubscribe
      - Create() is as low level as it gets and can sometimes be overwhelming
    - The other pure function is Observable.Generate()
      - Instead of passing the observer directly it takes several parameters
      - An initial state, a predicate that defines where the squence should terminate, 
      - A function to apply to the current state to generate the next state
      - A function to transform the current state to the desired output
      - It is the functional equvalent of the previous generation function which was more imperativve
  - Neither Create() or Generate() have to finish

5 - Demo Creating Sequences
Demo of
  - Simple Observables, Observable Wrappers & Generation Functions
Example Syntax
  // Demo of a simple console application
  namespace M2_Demo{
    class Program{
      static void Main(string[] args){
        var sequence = GetSimpleObservable();
        sequence.Subscribe(
          x => Console.WriteLine("OnNext: {0}", x);
          ex => Console.WriteLine("OnError: {0}", ex);
          () => Console.WriteLine("OnCompleted");
        );
        console.ReadLine();
      }
      
      private static IObservable<int> GetSimpleObservable(){
        return Observable.Return(42);
      }
      
      private static IObservable<int> GetThrowObservable(){
        return Observable.Throw<int>(new ArgumentException("Error In Observable"));
      }
      
      private static IObservable<int> GetEmptyObservable(){
        return Observable.Empty<int>();
      }
      
      private static IObservable<int> GetTaskObservable(){
        return GetTask().ToObservable();
      }
      
      private static async Task<int> GetTask(){
        return 42;      
      }
      
      private static IObservable<int> GetRangeObservable(){
        return Observable.Range(2, 7);
      }
      
      private static IObservable<long> GetIntervalObservable(){
        return Observable.Interval(TimeSpan.FromMilliseconds(500));
      }
      
      private static IObservable<int> GetCreateObservable(){
        return Observable.Create<int>(obs => }
          obs.OnNext(1);
          obs.OnNext(8);
          obs.OnCompleted();
          return Disposable.Empty:
        });
      }
      
      private static IObservable<int> GetGenerateObservable(){
        return Observable.Generate(
          1,
          x => x < 5,
          x => x + 1,
          x => x
        );
      }
    }
  }

6 - Subjects
Simple observables are not going to be used that much in real applications
  - It is much easier to use subjects
  - A subject is an observer and observable at the same time
Example Syntax
  var subject = new Subject<string>();            // Subject acts as the observer
  subject.Subscribe(t => Console.WriteLine(t));
  
  subject.OnNext("a");                            // Subject pushes new values to observables
  subject.OnNext("b");
  subject.OnNext("c");
  
  var subject2 = new ReplaySubject<string>();     // There are specialised subjects that cache or replay values for 
                                                     new subscribers
There are important theoretical differences between hot and cold observables that should be known
Hot Observables
  - Emit values even if there is no observer
  - Tend to be natural sources of information eg UI events
  - Subjects are also hot observables are they can have new values injected regardless of subscribers
  - Critical informatioin eg Stock Tickers will be hot observables
Cold Observables
  - Only emit if there is an observer, there are the equivalent of lazy evaluated iterables
  - Observable wrappers around async info are always called if there is no one waiting then the task will not fire
  - Subscription to queue like structures due to the nature of queues
  - Used with on-demand sequences

7 - Hot And Cold Observables
It can be useful on occasion to convert a cold observable to a hot observable or vice versa
  - It must be remembered that cold observables have unique subscriptions
  - Each observer receives an independent sequence of data
  - It can be useful to subscribe multiple obervers to the same observable so they receive simultaneous notifications
  - To change a hot to a cold observable is merely a matter of wrapping it in a subject

8 - Demo Reactive Tickets Command And Async
Example Syntax
  // This example is about enhancing the Reactive Tickets application
  // These include adding a command queue, adding logging to these commands and adding async wrappers
  // AppCommand.cs
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;
  
  namespace RxTicketsApp.Commands{
    public abstract class AppCommand{
      public DateTime Issued {get; private set;}
      public string Issuer {get; private set;}
      
      public AppCommand(){
        this.Issued = DateTime.Now;
        this.Issuer = "Jack";
      }
    }
  }
  
  // TicketDetailCommand.cs
  using System;
  using System.Collections.Generic;
  using System.Linq;
  using System.Text;
  using System.Threading.Tasks;

9 - Summary
A brief summary of the material covered in the section



                    Section 4 - Filtering And Controlling The Sequences
1 - Introduction
Introduction to the section and what to expect

2 - Filtering By Condition

3 - Filtering Head And Tail Elements

4 - Joining Sequences 

5 - Aggregation Operators

6 - Utility Operators

7 - Demo: Adding Search Filtering

8 - Summary
A brief summary of the material covered in the section



                    Section 5 - Simplifying Asynchronous And MultiThreading
1 - Introduction             
Introduction to the section and what to expect
                    
2 - Asynchrony In Rx
Asynchronous calls are those that are called out of order
  - This means that they do not follow the sequential order that is usually present in the code
  - They immediateley return control to the caller
  - They will finish executing at some moment in the future
  - The advantage of Async is that blocking calls can be avoided
  - Async code is the most appropriate type for calls to services that lie outside the code
  - Async code relies on Callbacks which in .NET is a pointer on a delegate to be executed after the async code finishes
  - Rx makes it easy to wrap async inside Observables
  - An async call can be considered an Oservable of a single result

3 - Multithreading In Rx

4 - Schedulers

5 - Wrapping Up: Reactive Thinking

6 - Demo: Revisiting Reactive Tickets 

7 - Summary
A brief summary of the material covered in the section
