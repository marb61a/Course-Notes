                    Taming Asynchronous .NET Code With Rx
                    Course Notes
                    
                    Section 1 - Course Overview
1 - Course Overview
A brief introduction to both the course and the instructor
The aim of the course is to have the student able to rewrite callbacks into observbles
There are some prerequisites for the course
  - The student should understand the .Net framework
  - Some familiarity with RxJS (reactive programming for javascript) 


                    Section 2 - Introducing Reactive Programming                   
1 - Introduction 
Introduction to the section and what to expect

2 - Demo:First Reactive Application
This demo scenario is when a customer asks for an active hover area in the application
  - A button will be shown if the mouse hovers for half a second in the area
Example Syntax
  // The example will show both the usual event driven method and also the reactive method
  using System;
  using System.Collections.Generic;
  using System.IO;
  using System.Linq;
  using System.Runtime.InteropServices.WindowsRuntime;
  using Windows.ApplicationModel;
  using Windows.ApplicationModel.Activation;
  using Windows.Foundation;
  using Windows.Foundation.Collections;
  using Windows.UI.Xaml;
  using Windows.UI.Xaml.Controls;
  using Windows.UI.Xaml.Controls.Primitives;
  using Windows.UI.Xaml.Data;
  using Windows.UI.Xaml.Input;
  using Windows.UI.Xaml.Media;
  using Windows.UI.Xaml.Navigation;
  
  namespace ActiveHoverAreaApp{
    // This provides application-specific behavior to supplement the default Application class.
    sealed partial class App : Application {
    
    }
  }

3 - Reactive Programming
Students may need to take the .NET reactive fundamentals course
  - It is recommended by the author that you do
  - This section will run through a quick overview of the reactive programming main points
  - Again like a lot of languages the spreadsheet example is used where a cell reacts to the change in another cell

4 - Reactive Extensions
Rx is the Microsoft Reactive library
  - It is available since 2009
  - It is not as well known as other libraries such as LINQ
  - The reactive library for .NET is called RxExtensions for .NET
  - The RX library is available for multiple languages and platforms such as Ruby, Java etc

5 - Observables And Observers

6 - Marble Diagrams

7 - Demo:Reactive Tickets Search

8 - Summary
A brief summary of the material covered in the section



                    Section 3 - Creating Sequence Of Observables                    
1 - Introduction 
Introduction to the section and what to expect

2 - Simple Observable
Simple observables are the most trivial observables in Reactive programming
  - They are usually used when you need only a single variable or constant
Example Syntax
  // The first simple observable is a sequence with no elements
    - This uses the factory method Observable.Empty;
      - It signals to its observers that its sequence is finished by invoking onCompled() on them
  // The next simple observable
    - Observable.Never;
      - This returns a sequence that never finishes
      - It returns no values or errors
  // The third in the list of simple observables
    - Observable.Throw(exception);
      - This returns a simple sequence that notifies an error
      - This is most frequently used in a Try-Catch block
  // The 4th and final simple Observable
    - Observable.Return("42");
      - This returns a sequence with only one value

3 - Observable Wrappers
After the Simple Observables the next step is to convert a data structure into an Observable
  - A lot of the time this means interacting wih non-reactive API's
  - This means there is a need to be able to wrap the results in Observables
  - If the are not wrapped they will not be able to be consumed in the Observable pipeline
  - The simplest thing to wrap is an Action which is usually a function into an Observable
    - The return value of the action is then returned into the onNext() method followed by onCompleted()
  - The next structure to be converted is a Task 
    - These days the Task Based model is often used with the key words Async and Await
    - If you have one of these API it is easier to wrap into an Observable
    - If using the older style begin() method can be wrapped in an Observable
  - If you have a data structure that can be enumerated such as IEnumerable
    - This can be turned into a sequence where every element will be pushed as an element of the Observable
    - Observables are best explained as the push based equivalent of the pull based Enumerables
      - In Enumerables the consumer is in charge, iterating over the structure at its own pace
      - In Observables however the Observer is passive by standard, it gets notified when there are new values
 - The final source is .NET events
  - An event handler can be used to generate Observables that can be transformed of combined
  - Wrapping around an event is one of the most frequent uses of Obervable Wrappers
Example Syntax
  Observable.Start(() => 42);                           // This is the action wrapper
  Task.ToObservable();                                  // Converts a task to an observable
  IEnumerable numbers ... ToObservable numbers          // Enumerables also have the ToObservable() method
  Observable.EventPattern(searchTextBox, "New Text")    // Events are converted using the Observable.EventPattern method

4 - Generator Functions
When there is no simple result or appropriate structure to wrap around Observables can be made on demand
  - This is the job of Generator functions
  - They generate new Observables for their subscribers
  - The simplest generator function is Observable.range
    - It generates a sequence of values that lie in a particular range and passes them sequentially to Observers
    - It is the push based twin of the Enumerable.range method
  - It is also very common to generate new Observables at a certain pace
    - For this there is 2 different generation functions Interval, Timer
    - Interval only asks for the time span and immediately begins pushing new values starting with zero
    - Timer also asks for the interval but provides a lamda function that will be invoked to provide new values
  - The lowest level of the generation functions are the pure ones
    - Observable.Create() and Observable.Generate()
    - Essentially create() allows you to specify a delegate that will be executed anytime a new subscription is made
      - The Observer interface of the observer that has made the subscription will be passed to a delegate
      - You can call onNext(), onError() and onComplete() as you need
      - You will have to return an IDisposable reference for the observer to be able to unsubscribe
      - Create() is as low level as it gets and can sometimes be overwhelming
    - The other pure function is Observable.Generate()
      - Instead of passing the observer directly it takes several parameters
      - An initial state, a predicate that defines where the squence should terminate, 
      - A function to apply to the current state to generate the next state
      - A function to transform the current state to the desired output
      - It is the functional equvalent of the previous generation function which was more imperativve
  - Neither Create() or Generate() have to finish

5 - Demo Creating Sequences

6 - Subjects

7 - Hot And Cold Observables

8 - Demo Reactive Tickets Command And Async

9 - Summary
A brief summary of the material covered in the section



                    Section 4 - Filtering And Controlling The Sequences
1 - Introduction
Introduction to the section and what to expect

2 - Filtering By Condition

3 - Filtering Head And Tail Elements

4 - Joining Sequences 

5 - Aggregation Operators

6 - Utility Operators

7 - Demo: Adding Search Filtering

8 - Summary
A brief summary of the material covered in the section



                    Section 5 - Simplifying Asynchronous And MultiThreading
1 - Introduction             
Introduction to the section and what to expect
                    
2 - Asynchrony In Rx

3 - Multithreading In Rx

4 - Schedulers

5 - Wrapping Up: Reactive Thinking

6 - Demo: Revisiting Reactive Tickets 

7 - Summary
A brief summary of the material covered in the section
