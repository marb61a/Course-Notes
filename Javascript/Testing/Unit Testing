                    Notes from Javascript Unit Testing Course

                    Section 1 - Introduction
1 - Types Of Software Testing 
*** Differing disagreed name on tests of all types
Unit Tests -
  Test small pieces of code
  Tests run in isolation(No dependencies)
  Fast to write and maintain
  Fast to run
  Run often during development
  Written by the developer

Component Tests -
  Test entire component in isolation
  Gives a developers view of the world
  Tests are more complex and thus are harder to write
  Run slower
  Executed less often

Integration Tests
  Tests interaction between units
  Minimise or use dependencies
  Internal units or internal and external units
  Tests are even more complex and thus are harder to write and run
  Run slower
  Executed even less often

Performance Tests
  How long does something take to execute
  How much data can the system handle
  How long does the system take to respond
  Can be at any level of system
  The difficulty to run, write and maintain depends on the application
  Runtime will be dependent on many factors
  Execution time will also be dependent on many factors

Feature Tests
  Test application features
  Minimise or use dependencies
  Presents a user's view of the world
  Run Slower
  Executed with integration tests
  Difficulty to read and write the same level as integration tests.

Acceptance Tests
  A suite of integration or feature tests
  Use dependencies
  Users view of the world(Known as - User Stories)
  Can be difficult to run, write and maintain
  Run Slower
  Executed prior to release
  
 
2 - The Testing Pyramid 
Different applications will need differing testing strategies, the course makes use of conceptual models such as the 
Ice Cream Cone, Software Testing Pyramid and others, these are available at the following address
https://watirmelon.blog/2012/01/31/introducing-the-software-testing-ice-cream-cone/
A general guide to using tests in an application is
- 40% Unit Tests
- 20% Component Tests
- 20% Feature Tests
- 10% Integration Tests
- 5% E2E Tests
- 5% Manual Tests

 
3 - What You Will Learn In This Course 
A very brief overview of the curriculum for the student and what they should expect to
learn from taking the course

4 - About The Author 
A quick biography of the course author (can be skipped)

5 - How To Access Your Working Files 
Instructions on how to accesss the working files used by the author
 
 
 
                    Section 2 - Unit Testing Basics
1 - Unit Testing Terminology 
  Assertions - Functions that verify values are what you think that they are
    They form the basis for almost all testing
    You can both write your own or use a library
    Node JS standards - Throws, Type Checking, Existence 
  Synchronous - Runs all the way through without stopping
  Asynchronous - The opposite of the above
    JavaScript has single thread of execution
    To execute code at a different time, schedule using callbacks
      NodeJS uses async IO
      Browsers use events
      setTimeout\setInterval
    Avoid waste due to unnecessary polling
  Frameworks - Third Party tools that handle unit testing boilerplate
    Provides a structured way to write tests
    Gives the ability to run tests and also see the results
    Provides a set of basic assertions for use in your tests
    They provide hooks for async tests
    Provide hooks also for mocks, stubs and spies
    There are often communities which offer support
  Stubs - A stub is a function
    They return known dummy data
    They are also deterministic
  Spies - Spies build on top of the stub concept
    They offer stubs with metadata
    You are able to know how many times a function was called and the parameters
  Mock Objects - This simulates the behaviour of real & complx objects
    You will have full control of mock objects
    Used with a lot of testing frameworks
    Heavily used with unit testing
    Again deterministic
 
2 - What A JavaScript Unit Test Looks Like 
    Plunker is used for code demo
    Several pieces in a test
    Need html file to load in necessary resources
    No native assert function in client-side js testing so create your own
    
 
3 - Writing Your Own Javscript Unit Test 
Unit testing on server side is similar to testing on the browser
Test Syntax
  var assert = require('assert');
  module.exports.testsum = function(sum){
    var answer = sum(4, 5);
    assert(answer === 9, '4 + 5 != 9!');
  }
  module.exports.testConcat = function(sum){
    var answer = sum('mark', 'test');
    assert(answer === 'marktest', 'mark + test = marktest);
  }
  
You would use index.html in the bowser to test this but on server it is different
You will use node.js infrasturucture
Runner file syntax
  var sum = require('./sum);
  var testSum = require('./testsum');
  
  for(testFunc in testSum){
    testSum[testFunc](sum)[
  }

node runner.js will run the file
This shows how much easier using a framework is

4 - Assertions
Assertions form the backbone of testing
Assertions are functions
  - They do nothing if the value passed to them is expected
  - They will complain if the value is unexpected usually an error is thrown
  - They are easy to write and reuse
  - The basic assertions come with frameworks
  - NodeJS provides an assert module
  - They are used in nearly all test types
Example Syntax
  Basic Assertion
  // In some sense this will be the only assertion function you will every need
  function assert(value, description){
    if(!value){
      throw new Error(description + ' is false!!');
    }
  }
  assert(5 + 6 === 12, '5 + 6 is 11');
  
  // Reducing everything to be true or false can be cumbersome
  Convenience Assertion
  // == means assert
  function assert(actual, expected, description){
    if (actual != expected){
      throw new Error(description);
    }
  }
  assert(12, sum(5, 6), '5 + 6 is 11');
  
NodeJS Assertions
var assert = require('assert');
assert.equal, assert.notEqual(==)
assert.strictEqual, assert.notStrictEqual(===)
assert.deepequal, assert.notDeepEqual
assert.throws, assert.doesNotThrow
Example Syntax
  Assert Throws
  function assertThrows(func, description){
    try{
      func();
      throw new Error(description);
    } catch(e){
    }
  }
  
  assertThrows(function(){
    throw new Error('error');
  }, 'this throws an error');

5 - The Role Of Code Coverage 
 
6 - How JavaScript Unit Test Is Different
 
7 - JavaScript Unit Test Flow 
 
8 - Manual Unit Testing 
 
9 - JavaScript Unit Test Frameworks 
 
10 - Running Unit Tests 
 
11 - JavaScript Unit Test Environments 
 
12 - Synchronous And Asynchronous Unit Tests 
 
13 - Introduction Test Driven Development 
 
14 - Test Driven Development In Practice 


 
                    Section 3 - Coding For Testability
1 - What Is Testable Code? 
Writing testable code will make thisng easier both as a developer and as a tester
Testable Code in unit testing means that each unit should be
  - Small
    - Less code equals fewer bugs
    - Fewer Tests
    - Easier to comprehend by both yourself and others
    - Easier to test
  - Have minimal dependencies
    - Less complexity
    - Easier to isolate
    - Easier to test
  - Dependencies are constructor injected
    - Swap implementations
    - Easier to mock
    - Tell at a glance what is required
    - Easier to test
  - Program to interface
    - Write tests once
    - Many different implementations
    - Defined contract
    - Type checking without inheritance
    - Easier to test
  - Low complexity
    - Fewer bugs
    - Problems easier to spot
    - Fewer tests
    - Easier to understand
    - Easier to test
  - Minimal Hierarchy
    - Class hierarchies are harder to test
      - Worry about super classes
      - Harder and sometimes impossible to isolate
      - Greater cognitive overhead
    - Easier to test
There is also a role for proper metrics
  - Lines of code
  - Cyclomatic complexity
  - Fan In & Fan Out
  - Coupling

2 - Cyclomatic Complexity 
Is is just an integer
It refers to the number of independent paths through your code
Also the same number of unit tests that will be needed fro 100% code coverage
Developed by Thomas McCabe 1976
Cyclomatic Compexity Syntax
  function sum(a, b){
    return a + b;
  }
  As there is only one path through the code Cyclomatic Complexity = 1
 
3 - Fan-In And Fan-Out
 
4 - Coupling 
 
5 - Inheritance Or Composition? 
 
6 - Code Injection 
 
7 - Using Decorators 
 
8 - Leveraging Abstract Factories 
 
9 - Measuring Complexity 
 
10 - Getting To Testability


 
                    Section 4 - Jasmine
1 - Introduction To Jasmine 
Available at - https://jasmine.github.io
Jasmine bills itself as a Behaviour Driven Development Tool
  - Is a more specific framing of Test Driven Development (TDD)
  - You can test desired behaviour
  - Anyone can understand what is being tested
  - There is a Semi-Formal test specification like user stories
    - Use "should" in test names
    - When/then
  - Jasmine -- Testing
  - Cucumber -- Development Framework based on BDD principles

Breakes Suites down using describe
  - Tests\Specifications -- it
  - Expectations\Assertions -- expect
  - describe, it and expect form a test tree

At the describe level you can have
  - beforeEach\afterEach
  - this
  - beforeAll\afterAll
You can also temporarily not run things
  - Do not run these
    - xit
    - pending
  - Only run these
    - fit
    - fdescribe
    - f stands for focusing
Matchers
  - Expectations have matchers
  - For example expect (foo).toBe(bar);
  - Several matchers come with Jasmine
    - String
    - Existence
    - Object
    - Array
    - Custom
Jasmine comes with its own spy framwork
Spies
  - Track function invocation
  - Paramenter lists for all invocations
  - Can call through
  - Can call another function
  - Can retrun an arbitrary value
  - Can throw an Error
Mocking has in-built support in Jasmine
  Mock the clock and date
    - Synchronous setTimeOut/setInterval
    - Set Date to anything
  Asynchronous Support
    - beforeEach\afterEach
    - beforeAll\afterAll
    - it
    - default timeout is 5 seconds
    - There is an optional "Done" parameter
    - done.fail() to fail test

2 - Jasmine On The Client 
 
3 - Jasmine On The Server 
 
4 - Starting Your First Test 
 
5 - Writing Your First Test 
 
6 - Selecting Tests 
 
7 - Running Tests 
 
8 - Introduction To Basic Matchers 
 
9 - More Basic Matchers 
 
10 - Asymmetric Matchers 
 
11 - Introduction To Custom Matchers 
 
12 - Custom Matcher Error Messages 
 
13 - Custom Matcher Example - toBeVisible 
 
14 - Basic Spying
 
15 - More Spying 
 
16 - Advanced Spying 
 
17 - Setup And Teardown - Nesting 
 
18 - Setup And Teardown - Variables 
 
19 - Asynchronous Tests 



                    Section 5 - Extending Jasmine
1 - Introduction To is.js
 
2 - Integration is.js With Jasmine
 
3 - Jasmine - Matchers And Promises 
 
4 - Introduction To saywhen 
 
5 - saywhen And Captors 
 
6 - Mocking Time 
 
7 - Introduction To Mocking Ajax 
 
8 - Mocking Ajax Responses 
 
9 - Encapsulation Mocked Ajax 
 
10 - Introduction To Jasmine-jQuery Matchers 
 
11 - Introduction To Jasmine-jQuery Fixtures 
 
12 - Using Jasmine-jQuery Fixtures 
 
13 - Jasmine-jQuery Fixtures And The Dom 
 
14 - Testing With Jasmine-jQuery Fixtures 
 
15 - Other Fixture Operations 
 
16 - Event Spies 
 
17 - Introduction To Code Coverage With Istanbul 
 
18 - Manual Code Coverage Generation


 
                    Section 6 - Other JavaScript Testing Frameworks
1 - Introduction To QUnit 
 
2 - Using Qunit
 
3 - More QUnit 
 
4 - Introduction To Mocha 
 
5 - More Mocha 
 
6 - Even More Mocha 
 
7 - Introduction To Tape 
 
8 - Using Tape 
 
9 - ESLint 
 
10 - Sinon.JS And Spies 
Can be found here - http://sinonjs.org
You can install using
  - npm install sinon (This install the latest version, )
 
11 - Sinon.JS Stubs 
 
12 - Sinon.JS Mocks 
 
13 - Sinon.JS Mocking Ajax 
 
14 - Introduction To Istanbul 
 
15 - Using Istanbul 
 
16 - Introduction To Selenium WebDriver 
 
17 - Using WebDriver 
 
18 - WebDriver And GhostDriver And PhantomJS 
 


                    Section 7 - Headless And Scriptable Browsers
1 - Introduction To PhantomJS 
PhantomJS is a headless WebKit scriptable with a JavaScript API
It is available at the following url
  - http://phantomjs.org
 
2 - Using PhantomJS With Jasmine 
 
3 - Scripting PhantomJS And Waits 
 
4 - Introduction To SlimerJS 
 
5 - Using SlimerJS
SlimerJS is similar to PhantomJs, except that it runs on top of Gecko, the browser engine of Mozilla Firefox
It can be found at the following address
  - https://slimerjs.org
 
6 - Introduction To CasperJS 
 
7 - CasperJS Test API 
 
8 - Introduction To Xvfb 
 
9 - Using Xvfb 


 
                      Section 8 - Automation
1 - The Role Of Automation 
 
2 - How To Automate 
 
3 - Introduction To Karma 
 
4 - Using Karma
 
5 - Karma In The Real World 
 
6 - Karma In The Real World 
 
7 - Karma In The Real World 
 
8 - Karma And Code Coverage 
 
9 - Grunt 
 
10 - Gulp 
 
11 - Bower 
 
12 - Yeoman 
 
13 - Introduction To npm - package.json And semver 
 
14 - npm Dependencies And Scripts 
 
15 - npm Configuration Variables 
 
16 - npm And Versions And Shrinkwrap 
 


                    Section 9 - Continuous Integration
1 - What Is Continuous Integration? 
 
2 - Getting Started With Jenkins 
 
3 - Jenkins Project Setup 
 
4 - Jenkins Capturing Test Output 
 
5 - Jenkins And Checkstyle 
 
6 - Jenkins And Code Coverage 
 
7 - Jenkins And Gulp 
 
8 - Using GitHub 
Full set of notes on using Git & Github available at
  - https://github.com/marb61a/Course-Notes/blob/master/DevOps/The%20definitive%2C%20step-by-step%20guide%20to%20Git
 
9 - Introduction To Travis CI 
 
10 - Preparing Your GitHub Repo For Travis CI Integration 
 
11 - Travis CI And Headless Testing With Firefox And Xvfb 
 
12 - Travis CI Wrap-Up 
 


                    Section 10 - Wrap-Up
1 - What We Have Learned 
 
