                    The Coding Interview Bootcamp: Algorithms + Data Structures
                    Course Notes
                    
                    
                    Section 1 - Get Started Here!
1 - How to Get Help
The various resources that students can use to get their questions answered
This is mainly the question and answer section on Udemy but the instructor's twitter can be used if needed

2 - The All Important Coding Interview
Interviews and interview questions requires a specific frame of mind
There are 2 different phases to getting development jobs
  - Contact Phase
    - Referral, Contact recruiter, Submit CV etc
  - Interview Phase
    - Phone Screen, Onsite Interview, Take home assignment
    - The ability to code is the single most important part during this time
    - This is the part of a candidate that the course aims to improve

3 - Getting Better at Coding Questions
There are 3 big tools available
  - Take home assignments
  - Pair Programming at a computer, this tans to be more practical eg tools, frameworks etc 
  - Whiteboarding, which is used by a lot of larger companies
There is no quick solution, practice is the only way to improve



                    Section 2 – A Touch of Setup
1 - Don't Skip Me!

2 - Environment Setup
Cloning the repo that will be used during the course
Jest will need to be installed (Globally) for testing
  - sudo npm install -g jest
  - On Windows sudo is not needed

3 - Repo Test Setup
A quick look at the folder and file structure of the repo
  - The exercises folder is the one which concerns students
  - There are tests already written to be ran against solutions
  - Jest is a test runner which will run tests on problem solutions

4 - Link to Github Repo
The course repo
  - https://github.com/StephenGrider/AlgoCasts



                    Section 3 – String Reversal
1 - First Question! Reverse String.
The first question is to return a new string with the character order of a given string reversed

2 - String Reversal, Solution #1
Example Syntax
  // A solution to the string reversal problem
  // This is probably the easiest solution but may not be the most obvious
  // This solution might be disallowed at an interview, it maybe better to use a more complex solution
  // as it will give an interviewer a better impression of you and your abilities
  function reverse(str){
    // Splitting a string using .split() splits it into an array (Of characters in this case)
    const arr = str.split('');
    
    // The JS reverse() function works on Arrays
    arr.reverse();
    
    // Rejoin and return the string
    return arr.join('');
    
    // A more concise version of the above is
    return str.split('').reverse().join('');
  }
  
  module.exports = reverse;

3 - String Reversal, Solution #2
Example Syntax
  // A second solution to the String Reversal problem
  function reverse(str){
    // Where possible avoid writing for loops using classic syntax
    // Mistakes are easy to make eg typos or wrong tense etc
    let reversed = '';
    
    // The for-of syntax was introduced in ES2015
    // This iterates through the str iterable object 
    for(let character of str){
      reversed = character + reversed;
    }
    
    return reversed;
  }
  
  module.exports = reverse;

4 - String Reversal, Solution #3
Example Syntax
  // Another solution this time using array helper methods
  function reverse(str){
    // Reduce was added in ES5.1
    // It takes all the values in an array and condenses them down to a singular value
    // It takes 2 values, the first is a function and the second is a initialising value
    return str.split('').reduce((reversed, character) => {
      return character + reversed;
    }, '');
  }
  
  module.exports = reverse;

5 - Debugger Statements



                    Section 4 – Paldinromes
1 - Palindromes
Palindromes are words that are the same backwards and forwards
  - ABBA for example is a palindrome

2 - Palindromes, Solution #1
Example Syntax
  // The first solution to whether a given word is a palindrome
  function palindrome(str){
    const reversed = str.split('').reverse().join('');
    
    // This will produce a boolean value on whether the 2 strings are equal
    return str === reversed;
  }
  
  module.exports = palindrome;

3 - Palindromes, Alternate Solution
Example Syntax
  // An alternative solution to whether a given word is a palindrome
  function palindrome(str){
    
  }
  
  module.exports = palindrome;


                    Section 5 – Integer Reversal
1 - Reversing an Int
The challenge in this section is to take an integer and return an integer that is the reverse
  - For example 15 would be 51, 987 would be 789 etc 
  - This has a lot in common with the previous reversing example
  - This problem as a lot of tricks and is good for practice at an interview
    - When reversing 0 will disappear at the end eg 500 will become 5
    - Using negative numbers is similar eg -25 becomes -52 and -90 becomes -9
  - The end result has to be a number not a string

2 - Reversing an Int Solution
Example Syntax
  // The solution to the Int reversing
  function reverseInt(n){
    // The code is much more legible using the two statements
    const reversed  = n.toString().split('').reverse().join('');
    
    // This will return an integer value from the string, Math.sign will multiply the value by
    // 1 if a positive value and -1 if it is a negative value
    return parseInt(reversed) * Math.sign(n);
    
  }
  
  module.exports = reverseInt;


                    Section 6 – MaxChars
1 - Max Chars Problem
The solutions to this particular problem can be applied to many different string problems
The problem to be solved in this section is
  - Given a string, what is the character that is most commonly used in the string
    - For Example aaaabbbbbcccccccccc -> this would return c as the most commonly used character
    - The method for solving is to convert a string to an object and count the keys of the object to find the most common

2 - Max Chars Character Map
Example Syntax
  // An example solution to help guide the solution to the MaxChars problem
  const string = "Hello There";
  const chars = {};
  
  for(let char of string){
    // If you were just to add 1 to the values you would be left with null values
    // By using the or the value of 1 is then assigned
    chars[char] = chars[char] + 1 || 1;
  }
  
  // Another more verbose solution is 
  for(let char of string){
    if(!chars[char]){
      chars[char] = 1;
    } else {
      chars[char]++;
    }
  }
  
  chars;

3 - Max Chars Solution

4 - Max Chars Solution Continued



                   Section 7 – The Classic FizzBuzz!
1 - FizzBuzz Problem Statement

2 - Solving FizzBuzz with Style



                    Section 8 – Array Chunking
1 - Array Chunk Problem Statement

2 - Chunk Solution #1

3 - More on Chunk

4 - Chunk Solution #2

5 - Even More on Chunk!



                    Section 9 – Anagrams
1 - What Are Anagrams?
The challenge in this section is to see if 2 provided strings are anagrams of each other
  - A string in an anagram of another if it uses the same characters in the same quantity
  - Casing is not important as upper or lower case is considered the same character in this case
  - Special characters and spaces are disregarded
Example Syntax
  // Using regex to remove special characters and change to lower case
  const word = "HI THERE!!!!!!!";
  
  // This will return hithere
  word.replace(/[^\w]/g, "").toLowerCase();

There are many different ways to solve the same problem but generating character maps for each string is recommended

2 - Solving Anagrams
Example Syntax
  // The first solution to anagrams
  // Anagrams are a favourite of interviewers
  function anagrams (stringA, stringB){
    const aCharMap = buildCharMap(stringA);
    const bCharMap = buildCharMap(stringB);
    
    // Object.keys can be used to find the keys associated with an object and the length property will 
    // give the quantity of keys on each object
    if(Object.keys(aCharMap).length !== Object.keys(bCharMap).length){
      return false'
    }
    
    for(let char in charMap){
      if(aCharMap[char] !== bCharMap[char]){
        return false;
      }
    }
    
    return true;
  }
  
  // Rather than using 2 separate loops it is better practice to make helper functions
  // this logic only has to be written one time and can be used on both strings
  function buildCharMap(str){
    const charMap = {};
    
    // The clean up logic is more compact being added to the loop
    // The regex replaces anything not a character with nothing
    for(let char of str.replace(/[^\w]/g, '').toLowerCase()){
      charMap[char] = charMap[char] + 1 || 1;
    }
    
    // Make sure to put in a return statement
    return charMap;
  }
  
  module.exports = anagrams;

3 - Another Way to Tackle Anagrams



                    Section 10 – Sentence Capitalization
1 - Understanding Capitalization

2 - Capitalization Solution #1

3 - How Else Can We Capitalize?



                    Section 11 - Printing Steps
1 - The Steps Question

2 - Steps Solution #1

3 - Steps Solution #1 Continued

4 - Step Up Your Steps Game

5 - More on Steps



                    Section 12 - Two Sided Steps - Pyramids
1 - Pyramids Vs Steps

2 - Pyramid Solution #1

3 - Pyramid Solution #2



                    Section 13 - Find The Vowels
1 - Get Your Vowels

2 - Finding Vowels

3 - Another Way to Find Vowels



                    Section 14 - Enter the Matrix Spiral
1 - General Matrix Spirals

2 - Spiral Solution

3 - More on Spiral



                    Section 15 - Runtime Complexity
1 - What is Runtime Complexity?

2 - Determining Complexity

3 - More on Runtime Complexity



                    Section 16 - Runtime Complexity in Practice - Fibonacci
1 - The Fibonacci Series

2 - Fibonacci Series Iterative Solution

3 - Fibonacci Series Recursive Solution

4 - Memoi-....Mem-...Memoization!

5 - I Believe Its Memoization!



                    Section 17 - The Queue
1 - What's a Data Structure?

2 - The Queue Data Structure

3 - Implementing a Queue



                    Section 18 - Underwater Queue Weaving
1 - What's a Weave?

2 - How to Weave



                    Section 19 - Stack 'Em Up With Stacks
1 - Stack Data Structure

2 - Implementing a Stack



                    Section 20 - Two Become One
1 - Queue From Stack Question

2 - Creating a Queue From Stacks

3 - More on Queue From Stack



                    Section 21 - Linked Lists
1 - What's a Linked List?

2 - Exercise Setup

3 - Node Implementation

4 - Linked List's Constructor
04:41
Linked Lists's InsertFirst
05:11
Solving Insert First
07:04
Sizing a List
02:36
Solve for Size
05:14
Get Over Here, GetFirst!
00:55
Building GetFirst
00:56
Find Your Tail with GetLast
01:49
GetLast Implementation
03:19
Clear that List
01:18
Clear Solution
01:56
Where's My Head, RemoveFirst?
01:35
Building RemoveFirst
02:33
Bye-Bye Tail with RemoveLast
05:05
RemoveLast Implementation
06:17
A New Tail to Tell with InsertLast
03:20
Adding InsertLast
03:42
Pick Em Out with GetAt
02:54
GetAt Solution
06:17
Remove Anything with RemoveAt
06:00
RemoveAt Solution
09:46
Insert Anywhere with InsertAt
03:56
InsertAt Solution
08:25
Code Reuse in Linked Lists
04:15
List Traversal Through ForEach
02:26
Note on Generators
00:19
Brushup on Generators
20:14
Linked Lists with Iterators
04:41
-
Find the Midpoint
13:33
Midpoint of a Linked List
10:06
Midpoint Solution
03:27
-
Circular Lists?
11:40
Detecting Linked Lists Loops
07:28
Loop Solution
04:12
-
Step Back From the Tail
08:50
From Last Question
06:15
From Last Solution
02:35
-
Building a Tree
46:30
Trees Overview
08:20
Node Implementation
06:32
More on Nodes
06:05
Tree Implementation
04:14
Traverse By Breadth
08:39
Solving for Breadth-First Traversal
05:24
Depth First Traversal
04:40
Solving for Depth-First Traversal
02:36
-
Tree Width with Level Width
19:10
Level Width Declaration
12:58
Measuring Level Width
06:12
-
My Best Friend, Binary Search Trees
22:14
What's a Binary Search Tree?
07:06
Binary Search Tree Implementation
04:41
BST Insertion
04:40
Do You Contain This?
02:41
Solving Contains
03:06
-
Validating a Binary Search Tree
22:35
How to Validate a Binary Search Tree
05:25
More on Validation
04:19
Solution to Validation
12:51
-
Back to Javascript - Events
14:26
What's an Eventing System?
07:10
A Tip on Events
02:08
Events Solution
05:08
-
Sorting With BubbleSort
09:39
Sorting Algorithm Overview
05:07
BubbleSort Solution
04:32
-
Sort By Selection
09:36
How SelectionSort Works
05:22
Selection Sort Solution
04:14
-
Ack, MergeSort!
28:58
MergeSort Overview
06:20
The Merge Function
06:55
More on MergeSort
05:55
I Don't Like Recursion, But Let's Do This Anyways
09:48
-
Not Done Yet...
00:04
To Be Continued!
00:04

