                    Coercion In Javascript Course Notes
                    
                    
                    Section 1 - Primitive Types
1 - Introduction
Brief introduction to the instructor & course
The author feels that coercion could be a very useful feature of Javascript

2 - Additonal Resources
There are some additional resources recommended by the instructor
  - High Performance Javascript By Nicholas Zekas (some parts maybe outdated)
  - Javascript Patterns By Stoyan Stefanov
The Mozilla Developer Network
  - https://developer.mozilla.org/en-US/docs/Web/JavaScript
Idiomatic Javascript
  - https://github.com/rwaldron/idiomatic.js/
ECMA Standard
  - https://www.ecma-international.org/ecma-262/5.1/
There is a lot more to coercion than == (double equals) and it occurs much more often than thought
Null and undefined are coercively equal to each other
ES6 is almost a new language

3 - Primitive Types
Javascript is said to be a no-type language like a lot of other scripting languages
  - This is a false assumption in the main
The type that are listed in the JS specifications are
  - Undefined
  - String
  - Number 
  - Boolean 
  - Object
  - function
  - null
There are different intrinsic behaviours in each of these
There are two many types of conversion implicit and explicit
Not everything in JS are objects
In ES6 null will function differently than undefined especially as function parameters

4 - TypeOf
TypeOf indicates that there are types in the language
  Example Syntax
  typeof foo;                       // undefined
  typeof "foo";                     // string
  typeof 123;                       // number
  typeof true;                      // boolean
  typeof {a: 1};                    // object
  typeof function() { alert(e);};   // function
These are the return value type upto ES5 and there has been one more added in ES6
The undefined and undelared are not the same thing
Javascript has value types rather than variable types unlike some other languages
typeof null returns object

5 - Special Values NaN
NaN - Not A Number
  - Is basically an invalid number
There are 2 inifinities positive and negative
The null type has a null value
The undefined tpye has one and only value
  - Undefined is not a ketword it is an identifier
There is both a positive and negative zero
Example Syntax
  var a = "a"/2;
  
  a;            // Nan
  

6 - Special Values Negative Zero
Negative Zero examples
  var foo = 0 / -3;
  var foo === -0;       // True
  // This may not be accurate
  // For example to stringify negative zero comes out as zero
  var foo === 0;        // True
  0 === -0;             // True
  (0 / -3) === (0 / 3); // True
  foo;                  // True

Negative zero is recognised in Javascript
Negative zero is not the same as zero
Developer consoles do not behave the same as the Javascript specification
Node is also not specification compliant in this regards
Example Syntax
  // To see if something is actually negative zero
  function isNeg0(x){
    // If there is a division into 1 and there is a negative infinity then you will get a negative zero 
    return x === 0 && (1 / X) === -Infinity;
  }
  
  isNeg0(0 / -3);     // True
  isNeg0(0 / 3);      // False
There are some places where negative zero could be useful
Sometimes more information is coded than just the value eg direction movement in video games -3 to the left for example
There is a new ES6 feature Object.is()
  - This is similar to triple equals but the Object.is() may be better for testing NaN and Negative Zero
Object.is() Examples
  Object.is("foo", NaN);      // False
  Object.is(NaN, NaN);        // True
  Object.is(0, -0);           // False
  Object.is(-0, -0);          // True

7 - Special Values Quiz
A quick quiz by the instructor about the types of certain variables

8 - Natives
Javascript Natives
  - String
  - Number 
  - Boolean
  - Function
  - Object
  - Array
  - RegExp
  - Date
  - Error
The JS specifications do not describe these as Types
The author tends to think of the above as sub-types of the object-type
They are also functions which have special behaviour attached
You will usually use new in front of them
You are probably best using examples to understand
Example Syntax
  var foo = new String("foo");
  foo;
  typeof foo;
  foo instanceof String;
  foo instanceof string;
  foo = String("foo");
  typeof foo;
  foo = new Number(37);
  typeof foo;



                    Section 2 - Coercion
1 - ToString
Coercion happens from one value type to another value type
Abstract operations
  - Related to the toString() method
  - If you use the toString abstract operation on an object the object will look to see if it has a toString method
    - If it does it is then invoked
  - If you return anything other than a string from a toString() Javascript will allow
Example Syntax 
  // This happens when you stringify objects
  // This may cause issues for single value arrays as you wolud be left with a value with no information
  []                -> ""
  [1, 2, 3]         -> "1, 2, 3"
  [null, undefined] -> ","
  [[], [], [], []]  -> ",,,"
  [,,,,]            -> ",,,"          // Trailing comma is ignored!!!!
  
  {}                -> "[object Object]"
  {a: 2}            -> "[object Object]"

Function stringification is non standard and depends on implementation
  - You maybe better avoiding this

2 - ToNumber
Takes any value and makes it into a number
Example Syntax
  ""            0       // The instructor does not like empty string going to 0
  "0"           0
  "-0"          -0
  " 009 "       9       // Whitespace and 0's are stripped out
  "3.14159"     3.14159
  "0."          0
  ".0"          0
  "."           NaN
  "0xaf"        175
Primitive values tend to be much more reasonable in behaviour than object
The instructor feels that the first entry has had such a bad effect on coercion that if resolved would fix many issues
that are present in coercion
All languages should ask what to do with corner cases
Example Syntax
  false         0
  true          1 
  null          0
  undefined     NaN
The instructor reckons that instead of resolving false and true to numbers like other languages and instead of that
resolved to NaN that might fix some issues
Example Syntax
  ToNumber(object) : ToPrimitive(number)
    - The first function that the ToPrimitive calls in valueOf()
      - This then falls back to toSting()
Example Syntax
  [""]          0
  ["0"]         0
  ["-0"]        0
  [null]        0
  [undefined]   0
  [1,2,3]       NaN
  [[[[]]]]      0

3 - ToBoolean
The ToBoolean abstraction operation is much more straightforward
Example Syntax
  // The following rules only apply to genuine ToBoolean operations as JS has
  // operations which look like they are performing ToBoolean but are not
  // Truthy means that if a legitimate ToBoolean operation is done on a value it will become the true value
  // Falsy means that if a legitimate ToBoolean operation is done on a value it will become the false value
  Falsy                 Truthy
  ""                    "foo"
  0, +0, -0             23
  null                  {a:1} 
  NaN                   [1,3]
  false                 true
  undefined             function(){}
                        ...



                    Section 3 - Implicit vs Explicit Coercion
1 - Explicit Coercion Strings & Numbers
There is not a direct way to call toPrimitive() or toNumber()
Operations in ther languages such as casting are explicit coercions
Example Syntax
  // Explicit Coercion, this is sometimes called conversion in JS
  // It is used a lot but still has a bad reputation
  var foo = "123";
  // This indicates using base10
  // Some say parseInt is a coercion
  var baz = parseInt(foo, 10);
  baz;                            //123
  
  // This is similar to type casting in other languages
  // This is an explicit coercion
  baz Number(foo);
  baz;                            //123
  
  baz = +foo;                     //Explicit?
  baz;                            //123
  
  baz = 456;
  foo = baz.toString();
  foo;                            //"456"
  
  foo = String(baz);
  foo;                            //"456"
  
The terms explict and implicit are subjective to the developer involved
  - Be consistent in the approach do not mix and match
JavaScript uses behind the scenes boxing of primitives
  - It is not explicitly coercion but part of that family

2 - Explicit Coercion Booleans
Example Syntax
  var foo = "123";
  var baz = Boolean(foo);
  baz:                              // true
  
  // Most developers use this rather than the Boolean function which in according to instructor 
  // should not be the situation
  baz = !!foo;
  baz;                              // true
  
  // Explicitly implicit
  // This is idiomatic code from languages such as Java
  // Instructor recommends against using this
  baz = foo ? true : false;
  baz;                              // true
  
  // Advanced programmers don't use the parentheses as you can drop them on constructor calls 
  // This example takes advantage of operator precedence
  var now = +new Date();
  // now = Date.now(); -- ES5 only
  
  var foo = "foo";
  // ~N -> -(N + 1)
  if(~foo.indexOf("f")){
    alert("Found it");
  }

3 - Implicit Coercion Strings & Numbers 
This happens as a side effect of some operation
The instructor disagrees with the notion that implicit coercion is always evil
Example Syntax
  var foo = "123"
  // Minus only works on arithmetic so the string is converted to a number implicitly
  var baz = foo - 0;
  baz;                            // 123
  
  // When both sides are strings both are implicitly coerced to numbers as minus only works on math
  baz = foo - "0";
  baz;                            // 123
  
  // Dividing by 1 and multiplying by 1 also causes coercion and is sometimes used in other languages
  baz = foo/1;
  baz;                            // 123
  
  // There are 2 different ways of using the plus sign, if both sides are numbers then numerical addition 
  // takes place but if one is a string the the plus sign refers string concatenation
  baz = 456;
  foo = baz + ""
  foo;                            // "456"
  
  foo = baz - "";
  foo;                            // 456
There is no performance hit from using explicit coercion rather than implicit

4 - Implicit Coercion Booleans 
Example Syntax
  var foo = "123";
  // This forces a to boolean coercion
  if (foo){                       // Yup
    alert("Sure.");
  }
  
  foo = 0;
  if (foo){                       // Nope
    alert("Right.");
  }
  // The instructor says this is one of the worst line of code in JS
  // In this case both sides are turned into numbers and compared
  // Don't ever do a double equals where either side can be true or false
  if (foo == false){              // Yup
    alert("Yeah.");
  }
  
  var baz = foo || "foo";
  baz;                            // "foo"

5 - Double Equals Issues
Continuation of the previous section
  - Some of the logic operators eg && and || are very similar to using a ternary operator
Example Syntax
  var foo = "123";
  // When a string is compared to a number then it is changed to a number as is the boolean
  // the boolean will be 1 and the number is 123 which are not equal
  if(foo == true){                // Nope
    alert('WAT!!');
  }
  
  foo = [];
  if(foo){                        // Nope
    alert('Sure');
  }
  if(foo == false){               // Yup
    alert('WAT!!');
  }

6 - Implicit Coercion The Bad Parts
Example Syntax
  // A list of what are in the instructors opinion the worst offenders
  "0" == null;                    // false
  "0" == undefined;               // false
  // This is argued as a gotcha by the instructor as there is little reason for it being true
  "0" == false;                   // true
  "0" == NaN;                     // false
  "0" == 0;                       // true
  "0" == ""                       // false
  
  false == null;                  // false
  false == undefined;             // false
  false == NaN;                   // false
  // This is used in a lot of other languages but the instructor disagrees with using it in JS
  false == 0;                     // true
  false == "";                    // true
  false == [];                    // true
  false == {};                    // false
  
  "" == null;                     // false
  "" == undefined;                // false
  "" == NaN;                      // false
  "" == 0;                        // true
  "" == [];                       // true
  "" == {};                       // false
  
  0 == null;                      // false
  0 == undefined;                 // false
  0 == NaN;                       // false
  0 == [];                        // true
  0 == {};                        // false 

Again never use the double equals with boolean
  - == true or == false
The instructor recommends asking yourself a couple of questions
  - Can either value be true or false
  - Can either value ever be [], "" or 0
Coercion is a way to help hide away details of implementation

7 - Implicit Coercion The Safe Parts
Example Syntax
  42 == "43";                     // false
  "foo" == 42;                    // false
  "true" == true;                 // false
  
  42 == "42";                     // true
  "foo" == [ "foo" ]              // true

// Demonstrating primitive to native and back coercion
  // This involves wrapping the primitive like boxing in other languages
  // this is an implicit coercion
  var foo = "123";
  foo.length;                     // 3
  
  foo.charAt(2);                  // 3

  foo = new String("123");
  var baz = foo + "";
  typeof baz;                     // String

8 - Double Vs Triple Equals
== vs ===
Example Syntax
  == - checks value
  === - checks value and type
  - The instructor is of the opinion that this is incorrect as the spec as the double equals checks the type too
The instructor recommends that the best way to think about the differences is
  == - Allows coercion
  === - Disallows coercion
  - Also they behave identically when types match
Example Syntax
  var foo = [];
  var baz = "";
  if(foo == baz){                 // yup
    alert("Doh");
  }
  if(foo === baz){                // nope
    alert("Phew");
  }
  
  foo = 0;
  if(foo == ""){                 // yup
    alert("Aargh");
  }
  if(foo === ""){                // nope
    alert("Phew");
  }
The instructor has a hitlist of examples that he thinks that JS should change
  Number("") === 0;
  Number(false) === 0;
  Number(true) === 1;
  Number(null) === 0;
  
  String([]) === "";
  String([null]) === "";
  String([undefined]) === "";

9 - Helpful Implicit Coercion
Where coercion may be helpful
Example Syntax
  var foo = "3";
  if(foo === 3 || foo === "3"){   // Yup
    alert("Thanks, but...");
  }
  
  // The instructor recockons that this is a better solution than above
  if(foo == 3){                   // Yup
    alert("Thats Nicer");
  }
  
  if(typeof foo === "string"){    // Yup
    alert("typeof always retruns a string");
  }

  Example Syntax for null and undefined
  var foo;
  if(foo == null){                // Yup
    alert("Thanks!");
  }
  
  foo = null;
  if(foo == null){                // Yup
    alert("Thanks again");
  }
  
  foo = false;
  if(foo == null){                // Nope
    alert("Phew");
  }

Proper concise code that is well written presents fewer options for errors
  - Concise is not always better

10 - Coercion Resources And Surprises
                    
                    
