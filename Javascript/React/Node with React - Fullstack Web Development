                    Node with React: Fullstack Web Development
                    Course Notes

The application from this course is deployed on Heroku at
  - https://fullstackreactnode.herokuapp.com
The GitHub repository for the source code is located at
  - https://github.com/marb61a/fullstack_node_react


                    
                    Section 1 – Course Overview - Start Here!
1 - How to Get Help
A brief intro to the course and the run through of the resources used in the course
  - Use Node.js version 8.1.x and above
The course is an advanced course
  - There may be issues so it is recommended to use the various links in the resource documents

2 - Course Resources Document
A text document with a direct link to the resources used in the course

3 - [Optional] Prettier Setup
An instruction guide to using Prettier for code formatting
  - https://github.com/prettier/prettier
  - This is optional but recommended by the course instructor
  - A quick demo of the effect prettier has on code

4 - App Overview
The course will cover the creation of a single app
  - It will be a larger application with a number of features
  - It will have both a front and backend to it

5 - App User Flow Walkthrough
App is essentially a feedback collection application
The application steps are
  - User signs up via Google OAuth
  - They pay for email credits via Stripe
  - User creates a new campaign
  - User enters a list of emails to send surveys to
  - We send the email to the list 
  - Recipients click on link in the email to provide feedback
  - Tabulate the feedback
  - User can see a report of all survey responses

6 - Tech Stack
A discussion on the various types of technology that will be used in the course
  - React
  - Redux
  - Redux Form
  - PassportJS
  - MongoDB -- The database (no-sql)
  - Stripe -- To handle payments
  - E-mail service

7 - App Mockups
Some static mockups of the example application and the workflow 



                    Section 2 – Server Side Architecture
1 - Application Architecture
The first discussion on how the various technologies will work together
  - Although there are a lot of educational material available on the individual technologies there is little 
  available on how the various pieces work together
  - This is the aim of the course, at the end you should understand how the pieces work together
In the course sample application
  - Whenever a user navigates to the application
  - We will send them back a HTML document and some JS files containing a React application
  - The application will use MongoDB for storing data eg surveys etc
  - The React part of the application will never talk directly to the MongoDB database
    - We will instead put an Express API in between
    - The Express API and React will use HTTP requests to communicate

2 - Relationship Between Node and Express
There is a comprehensive set of notes on Node available at
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/NodeJS/Learning NodeJs
Generating a new npm project
  - mkdir project
  - cd project
  - npm init
The first dependency to be installed is Express
  - npm install --save express                                // --save adds the entry to the package.json file
Some definitions of Node & Express are given in the interests of clarity
  - Node is a Javascript runtime which is used to execute code outside of the browser
    - Javascript was traditionally browser only
  - Express is a library that runs in the Node runtime, it has helpers to make dealing with HTTP easier
    - There is an indepth explanation of how Express works
    - The notes link above has detailed explanations on Express

3 - Generating Express Apps
The instructor uses Atom but any code editor will do
  - The package-lock.json only appears for people using Node version 5 and higher
We create a new file called index.js
  - The convention in React is to use index.js as an entry point into the app
  - We will create a new express app with our first route handler
Example Syntax
  // There will be some tutorials on Javascript module in the course
  // We will use common.js for modules which is supported by Node
  // Common.js is a system for sharing code through modules on node
  // Node does not have support for ES2015 modules
  const express = require("express");
  const app = express();
  
  app.get('/', (req, res) => {
    res.send({hi: 'there'});
  });

app.listen(5000);                  // You may need to use process.env.PORT, process.env.IP depending on your environment
To run the application
  node index.js                    // This is on the c9 cloud IDE so may differ 

4 - Express Route Handlers
An examination of the code from the previous section
  - Anybody familiar with express can skip

5 - Heroku Deployment Checklist
This is how to handle deployment
  - It will be deployed to the Heroku platform located at
    - https://www.heroku.com/
  - Heroku has a free tier available which is great for testing apps
There is a checklist that needs to be gone through
  - Dynamic Port Binding
    - This is because Heroku tells the app what port to use so it needs to listed
  - Specify Node Environment
    - Heroku will need to know which version of Node to use
    - This is added to the package.json file
    "engines": {
      "node": "8.1.1",
      "npm": "5.0.3"
    }
  - Specify start script
    - This will instruct Heroku on what command to run to start the server
    "scripts": {
      "start": "node index.js"
    }
  - Create a .gitignore file
    - Heroku will include dependencies so that we do not have to
    - Just add node_modules to the .gitignore file and save

6 - Installing the Heroku CLI
The checklist from the previous video will be used on every Node.js deployment to Heroku
  - The diagram is available on Github and is recommended to have a copy
The course will use local git repositories rather than remote like github
  - However I use a cloud ide so GitHub is more convenient
  - Installing Heroku will differ on each platform/OS 
  - Heroku is installed by default on each vm on the Cloud9 platform
  - To check if heroku is installed at the cli prompt -> heroku -v

7 - Verifying Heroku Deployment
To get started with deploying you must first login from the prompt in your project
  - heroku login
  - This will prompt you for both the email address and password you use for heroku
Then is the creation of a new application
  - heroku create 
  - This generates 2 separate links
    - The first is the browser url, the name is randomly generated
    - The second is a deployment target git repository
      - This needs to be added to heroku using -> git remote add heroku 
      - It may say remote already exists which is perfectly fine
Then is the push to heroku
  - git push heroku master
To automatically open a browser window with the browser url
  - heroku open

8 - Followup Deployments
After the initial deployment there will of course need to be more deployments
  - In practice this is relatively straight forward
  - You will need to ensure that changes in files are saved
  - The command git status shows what files have changed
  - Then commit the files using git commit -m "mesage"
  - Then run git push heroku master as before
You can rename the site using
  - heroku apps:rename new-app-name



                    Section 3 – Authentication with Google OAuth
1 - Intro to Google OAuth
The OAuth material will be difficult
  - This is the most challenging pasrt of the course
  - There are a lot of skills which will transfer to other projects
  - The student should learn a lot of skills
  - The goal is to have a button which allows a user to sign up for the site using Google or other sites sign in
  - Email and password signup and login is decreasing in popularity and is considered a legacy technology
  - OAuth is recommended by the course instructor to use for apps
    - Users may sign up quicker for services using OAuth
  - There are several different steps associated with setting up OAuth

2 - The OAuth Flow
Walking through the flow of the OAuth process flow
  - User clicks on the login button
    - This will direct to a url looking like address/auth/google
  - A server forwards the request to Google
    - This uses a url looking like google.com/auth?appid=123
  - Google then asks the user if they grant permission
  - The user is then expected to grant permission
    - This uses a url looking like address/auth/google/callback?code=456
  - Put the user on hold and take the code from the url
  - Send a request to google with the code included
  - Get the user details and create a new record in the database
  - Set the user id in a cookie for this user
  - User is now Logged In

3 - Overview of Passport JS
Passport is a library which will help with the authentication flow
  - It will take care of a couple of steps and will make life a ittle easier
  - Passport will help reduce boilerplate
  - There are a couple of common complaints about Passport
    - Passport requires reaching in to specific flow points, this can affect how understood the process is
    - The second complaint is about how misuderstood the structure is, there are actually at least 2 libraries
      - passport -- core library of general helpers for handling auth in Express
      - passport-strategy -- library of helpers for handling authentication using a specific method eg Google 
  - The example app will only use Google as sign in provider
  
4 - Passport Setup
Using NPM to install both the base Passport module but also the Google OAuth strategy
  // Using 20 means that it uses OAuth2.0
  - npm install -- save passport passport-google-oauth20
Initially everything will be in the index.js file but that will be refactored
The passport and google strategy modules will need to be available in index.js
  - const passport = require('passport');
  - const GoogleStrategy = require("passport-google-oauth20").Strategy; 
There will need to be a new instance of GoogleStrategy to make use of it
  - It is added into passport.use in order to basically tell passport a new strategy is available
  - passport.use(new GoogleStrategy());

5 - Enabling Google OAuth API
** Process has been slightly changed and looks slightly different too
To go to the Google OAuth API
  - https://console.developers.google.com
  - You must have a Google account (free so easy to signup for)
  - You will need to create a new project
  - You should append dev to the project name as there will be a second one needed later in the course
  - Creating the project does not instantly create it but rather starts the process
  - After creation the Google OAuth API will need to be enabled
    - To signup for the OAuth API you must use the Google+ API
  - After this then the API credential must be created
    - Click on create credentials to get started
  - The client id and the client secret are the tokens that are needed

6 - Securing API Keys
ClientID - This token can be shared with the public
ClientSecret - This token should not be seen by anybody
  - Be careful not to push secret keys to Github
  - Add a config folder and a keys file to hold sensitive information
  - Ensure that the keys file is added to the .gigignore file

7 - Google Strategy Options
Ensure that the D in ID is uppercase
The keys will now need to be imported into the index.js file
Any file with a .js does not need the ending passed in
  - const keys = require("./config/keys");
Add them to the Google Strategy
  - clientID: keys.googleClientID,
  - clientSecret: keys.googleClientSecret,
  - callbackURL: 'auth/google/callback'

8 - Testing OAuth

9 - Authorized Redirect URI's

10 - OAuth Callbacks

11 - Access and Refresh Tokens

12 - Nodemon Setup



                    Section 4 – Adding MongoDB
1 - Server Structure Refactor

2 - The Theory of Authentication

3 - Signing In Users with OAuth

4 - Introduction to MongoDB

5 - MongoDB Setup

6 - Connecting Mongoose to Mongo

7 - Breather and Review

8 - Mongoose Model Classes

9 - Saving Model Instances

10 - Mongoose Queries

11 - Passport Callbacks

12 - Encoding Users

13 - Deserialize User

14 - Enabling Cookies

15 - Testing Authentication

16 - Logging Out Users

17 - [Optional] A Deeper Dive



                    Section 5 – Dev vs Prod Environments
1 - Dev vs Prod Keys

2 - Generating Production Resources

3 - Determining Environment

4 - Version Control Scheme

5 - Heroku Env Variables

6 - Fixing Heroku Proxy Issues



                    Section 6 – Moving to the Client Side
1 - React App Generation

2 - A Separate Front End Server

3 - Running the Client and Server

4 - Routing Stumbling Block

5 - The Beauty of Create React App's Proxy

6 - [Optional] Why This Architecture?



                    Section 7 – Developing the Client Side
1 - Async/Await Syntax

2 - Refactoring with Async/Await

3 - Front End Tech

4 - Client React Setup

5 - Installing Root Modules

6 - Troubleshooting NPM

7 - Redux Review and Setup

8 - The Auth Reducer

9 - Finishing Reducer Setup

10 - Why We Care About Auth

11 - React Router Setup

12 - Route Configuration

13 - Always Visible Components

14 - Always Visible Components

15 - Materialize CSS

16 - Webpack with CSS

17 - Header Design

18 - Current User API

19 - Additional Proxy Rules

20 - Basics of Redux Thunk

21 - Refactoring the App

22 - Testing FetchUser

23 - Refactoring to Async/Await

24 - AuthReducer Return Values

25 - Accessing State in the Header

26 - Header Content

27 - Redirecting a User on Auth

28 - Redirect on Logout

29 - Landing Component

30  Link Tags



                    Section 8 – Handling Payments
1 - Client Side Billing

2 - Billing Considerations

3 - Stripe Billing Process

4 - Exploring the Stripe API

5 - Stripe API Keys

6 - Env Variables with React

7 - The Payments Component

8 - Stripe Tokens

9 - Payment Fixes

10 - Reusing Action Types

11 - Positing the Stripe Token

12 - Post Request Handlers

13 - Creating Charges

14 - BodyParser Middleware

15 - Creating a Charge Object

16 - Finalizing a Charge

17 - Adding Credits to a User

18 - Requiring Authentication

19 - Route-Specific Middlewares

20 - Displaying Credit Quantity

21 - Updating Credits



                    Section 9 – Back End to Front End Routing in Production
1 - Express with Create-React-App in Production

2 - Routing in Production

3 - Deployment Options

4 - Adding in a Heroku Build Step

5 - Testing Deployment



                    Section 10 – Mongoose for Survey Creation
1 - Survey Overview

2 - Server Routes

3 - Survey Model

4 - Model Deficiencies

5 - Limitations of Subdocument Collections

6 - Setting up SubDocs

7 - Relationship Fields

8 - Survey Creation Route Handler

9 - Verifying Minimum Credits

10 -Creating Surveys

11 - Creating Subdoc Collections

12 - Oops! A Little Tweak

13 - Creating Mailers

14 - Identifying Unique Users

15 - Sendgrid Setup

16 - Mailer Setup

17 - Mailer in Use

18 - Mailer Constructor

19 - Boilerplate for Sending Emails

20 - More Mailer Properties

21 - Sending SendGrid Emails

22 - Testing Email Sending

23 - Improving the Email Template

24 - Polish in the Route Handler

25 - Verifying Sendgrid Click Tracking

26 - Feedback for User Feedback



                    Section 11 - Back to the Client!
1 - Client Side Survey Creation

2 - Material Icons

3 - Navigation with the Link Tag

4 - SurveyNew Form

5 - Purpose of Redux Form

6 - Redux Form Setup

7 - The ReduxForm Helper

8 - Redux Form in Practice

9 - Custom Field Components

10 - Wiring up Custom Fields

11 - DRY'ing Up Fields

12 - Fields from Config

13 - Styling the Form

14 - Form Validation

15 - Showing Validation Errors

16 - Generalizing Field Validation

17 - Validating Emails

18 - Displaying Invalid Emails

19 - Toggling Visibility?

20 - Advancing From SurveyForm

21 - Retreat to the Form

22 - Persisting Form Values

23 - Refactoring Form Fields

24 - Finalizing Review Fields

25 - Outstanding Form Work

26 - Dumping Form Values

27 - Fixing Property Names

28 - Posting to Surveys

29 - Redirect on Submit



                    Section 12 - Handling Webhook Data
1 - Feedback with Webhooks

2 - Webhooks in Development

3 - LocalTunnel Setup

4 - Testing Webhooks

5 - LocalTunnel Crash Fix

6 - Finalizing Webhook Setup

7 - Encoding Survey Data

8 - Dirty Data from Webhooks

9 - Processing Pipeline

10 - Parsing the Route

11 - Code Cleanup

12 - Unique Events

13 - Lodash Chain Helper

14 - Bad Mongoose Queries

15 - Finding the Exact Survey

16 - Updating Records

17 - Executing Queries

18 - Testing the Query

19 - Odds n' Ends Around Surveys

20 - Mongoose Tips



                    Section 12 - The Home Stretch!
1 - Fetching a List of Surveys

2 - Whitelisting Model Fields

3 - Testing Surveys Endpoint

4 - Wiring Surveys Up to Redux

5 - Wiring React to Redux

6 - Rendering a List of Surveys

7 - Reversing the Survey List

8 - Expanding the App
