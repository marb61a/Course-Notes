                    Node with React: Fullstack Web Development
                    Course Notes
                    
                    
                    Section 1 – Course Overview - Start Here!
1 - How to Get Help
A brief intro to the course and the run through of the resources used in the course
  - Use Node.js version 8.1.x and above
The course is an advanced course
  - There may be issues so it is recommended to use the various links in the resource documents

2 - Course Resources Document
A text document with a direct link to the resources used in the course

3 - [Optional] Prettier Setup
An instruction guide to using Prettier for code formatting
  - https://github.com/prettier/prettier
  - This is optional but recommended by the course instructor
  - A quick demo of the effect prettier has on code

4 - App Overview
The course will cover the creation of a single app
  - It will be a larger application with a number of features
  - It will have both a front and backend to it

5 - App User Flow Walkthrough
App is essentially a feedback collection application
The application steps are
  - User signs up via Google OAuth
  - They pay for email credits via Stripe
  - User creates a new campaign
  - User enters a list of emails to send surveys to
  - We send the email to the list 
  - Recipients click on link in the email to provide feedback
  - Tabulate the feedback
  - User can see a report of all survey responses

6 - Tech Stack
A discussion on the various types of technology theat will be used in the course
  - React
  - Redux
  - Redux Form
  - PassportJS
  - MongoDB -- The database (no-sql)
  - Stripe -- To handle payments
  - E-mail service

7 - App Mockups



                    Section 2 – Server Side Architecture
1 - Application Architecture
The first discussion on how the various technologies will work together
  - Although there are a lot of educational material available on the individual technologies there is little 
  available on how the various pieces work together
  - This is the aim of the course, at the end you should understand how the pieces work together
In the coure sample application
  - Whenever a user navigates to the application
  - We will send them back a HTML document and some JS files containing a React application
  - The application will use MongoDB for storing data eg surveys etc
  - The React part of the application will never talk directly to the MongoDB database
    - We will instead put an Express API in between
    - The Express API and React will use HTTP requests to communicate

2 - Relationship Between Node and Express
There is a comprehensive set of notes on Node available at
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/NodeJS/Learning NodeJs
Generating a new npm project
  - mkdir project
  - cd project
  - npm init
The first dependency to be installed is Express
  - npm install --save express                                // --save adds the entry to the package.json file
Some definitions of Node & Express are given in the interests of clarity
  - Node is a Javascript runtime which is used to execute code outside of the browser
    - Javascript was traditionally browser only
  - Express is a library that runs in the Node runtime, it has helpers to make dealing with HTTP easier
    - There is an indepth explanation of how Express works
    - The notes link above has detailed explanations on Express

3 - Generating Express Apps
The instructor uses Atom but any code editor will do
  - The package-lock.json only appears for people using Node version 5 and higher
We create a new file called index.js
  - The convention in React is to use index.js as an entry point into the app
  - We will create a new express app with our first route handler
Example Syntax
  // There will be some tutorials on Javascript module in the course
  // We will use common.js for modules which is supported by Node
  // Common.js is a system for sharing code through modules on node
  // Node does not have support for ES2015 modules
  const express = require("express");
  const app = express();
  
  app.get('/', (req, res) => {
    res.send({hi: 'there'});
  });

app.listen(5000);                  // You may need to use process.env.PORT, process.env.IP depending on your environment

4 - Express Route Handlers
An examination of the code from the previous section
  - Anybody familiar with express can skip

5 - Heroku Deployment Checklist
This is how to handle deployment
  - It will be deployed to the Heroku platform located at
    - https://www.heroku.com/
  - Heroku has a free tier available which is great for testing apps
There is a checklist that needs to be gone through
  - Dynamic Port Binding
    - This is because Heroku tells the app what port to use so it needs to listed
  - Specify Node Environment
    - Heroku will need to know which version of Node to use
    - This is added to the package.json file
    "engines": {
      "node": "8.1.1",
      "npm": "5.0.3"
    }
  - Specify start script
    - This will instruct Heroku on what command to run to start the server
    "scripts": {
      "start": "node index.js"
    }
  - Create a .gitignore file
    - Heroku will include dependencies so that we do not have to

6 - Installing the Heroku CLI
The checklist from the previous video will be used on every Node.js deployment to Heroku
  - The diagram is available on Github and is recommended to have a copy
The course will use local git repositories rather than remote like github

7 - Verifying Heroku Deployment

8 - Followup Deployments



                    Section 3 – Authentication with Google OAuth
1 - Intro to Google OAuth

2 - The OAuth Flow

3 - Overview of Passport JS

4 - Passport Setup

5 - Enabling Google OAuth API

6 - Securing API Keys

7 - Google Strategy Options

8 - Testing OAuth

9 - Authorized Redirect URI's

10 - OAuth Callbacks

11 - Access and Refresh Tokens

12 - Nodemon Setup



                    Section 4 – Adding MongoDB
1 - Server Structure Refactor

2 - The Theory of Authentication

3 - Signing In Users with OAuth

4 - Introduction to MongoDB

5 - MongoDB Setup

6 - Connecting Mongoose to Mongo

7 - Breather and Review

8 - Mongoose Model Classes

9 - Saving Model Instances

10 - Mongoose Queries

11 - Passport Callbacks

12 - Encoding Users

13 - Deserialize User

14 - Enabling Cookies

15 - Testing Authentication

16 - Logging Out Users

17 - [Optional] A Deeper Dive



                    Section 5 – Dev vs Prod Environments
1 - Dev vs Prod Keys

2 - Generating Production Resources

3 - Determining Environment

4 - Version Control Scheme

5 - Heroku Env Variables

6 - Fixing Heroku Proxy Issues



                    Section 6 – Moving to the Client Side
1 - React App Generation

2 - A Separate Front End Server

3 - Running the Client and Server

4 - Routing Stumbling Block

5 - The Beauty of Create React App's Proxy

6 - [Optional] Why This Architecture?



                    Section 7 – Developing the Client Side
1 - Async/Await Syntax

2 - Refactoring with Async/Await

3 - Front End Tech

4 - Client React Setup

5 - Installing Root Modules

6 - Troubleshooting NPM

7 - Redux Review and Setup

8 - The Auth Reducer

9 - Finishing Reducer Setup

10 - Why We Care About Auth

11 - React Router Setup

12 - Route Configuration

13 - Always Visible Components

14 - Always Visible Components

15 - Materialize CSS

16 - Webpack with CSS

17 - Header Design

18 - Current User API

19 - Additional Proxy Rules

20 - Basics of Redux Thunk

21 - Refactoring the App

22 - Testing FetchUser

23 - Refactoring to Async/Await

24 - AuthReducer Return Values

25 - Accessing State in the Header

26 - Header Content

27 - Redirecting a User on Auth

28 - Redirect on Logout

29 - Landing Component

30  Link Tags



                    Section 8 – Handling Payments
1 - Client Side Billing

2 - Billing Considerations

3 - Stripe Billing Process

4 - Exploring the Stripe API

5 - Stripe API Keys

6 - Env Variables with React

7 - The Payments Component

8 - Stripe Tokens

9 - Payment Fixes

10 - Reusing Action Types

11 - Positing the Stripe Token

12 - Post Request Handlers

13 - Creating Charges
05:19
BodyParser Middleware
06:42
Creating a Charge Object
06:32
Finalizing a Charge
04:40
Adding Credits to a User
07:27
Requiring Authentication
06:46
Route-Specific Middlewares
11:39
Displaying Credit Quantity
04:18
Updating Credits
05:18
–
Back End to Front End Routing in Production
50:36
Express with Create-React-App in Production
12:20
Routing in Production
08:09
Deployment Options
10:08
Adding in a Heroku Build Step
16:10
Testing Deployment
03:49
–
Mongoose for Survey Creation
03:18:40
Survey Overview
08:00
Server Routes
05:24
Survey Model
07:07
Model Deficiencies
05:56
Limitations of Subdocument Collections
07:52
Setting up SubDocs
04:49
Relationship Fields
05:03
Survey Creation Route Handler
07:15
Verifying Minimum Credits
06:24
Creating Surveys
09:06
Creating Subdoc Collections
08:48
Oops! A Little Tweak
00:23
Creating Mailers
07:18
Identifying Unique Users
14:29
Sendgrid Setup
08:21
Mailer Setup
09:39
Mailer in Use
11:01
Mailer Constructor
08:31
Boilerplate for Sending Emails
09:29
More Mailer Properties
05:57
Sending SendGrid Emails
06:16
Testing Email Sending
09:20
Improving the Email Template
08:58
Polish in the Route Handler
09:52
Verifying Sendgrid Click Tracking
02:09
Feedback for User Feedback
11:13
-
Back to the Client!
03:55:01
Client Side Survey Creation
05:01
Material Icons
08:58
Navigation with the Link Tag
02:20
SurveyNew Form
06:55
Purpose of Redux Form
11:16
Redux Form Setup
12:20
The ReduxForm Helper
07:07
Redux Form in Practice
10:22
Custom Field Components
08:56
Wiring up Custom Fields
05:46
DRY'ing Up Fields
05:16
Fields from Config
07:35
Styling the Form
07:19
Form Validation
06:25
Showing Validation Errors
08:31
Generalizing Field Validation
09:09
Validating Emails
08:35
Displaying Invalid Emails
13:07
Toggling Visibility?
11:55
Advancing From SurveyForm
11:28
Retreat to the Form
05:20
Persisting Form Values
11:26
Refactoring Form Fields
09:55
Finalizing Review Fields
05:26
Outstanding Form Work
10:50
Dumping Form Values
07:09
Fixing Property Names
02:53
Posting to Surveys
04:40
Redirect on Submit
09:01
-
Handling Webhook Data
02:18:10
Feedback with Webhooks
02:30
Webhooks in Development
09:08
LocalTunnel Setup
06:27
Testing Webhooks
05:16
LocalTunnel Crash Fix
00:43
Finalizing Webhook Setup
06:47
Encoding Survey Data
07:57
Dirty Data from Webhooks
07:15
Processing Pipeline
08:18
Parsing the Route
07:55
Code Cleanup
05:30
Unique Events
05:14
Lodash Chain Helper
10:50
Bad Mongoose Queries
09:09
Finding the Exact Survey
13:48
Updating Records
09:33
Executing Queries
09:25
Testing the Query
02:18
Odds n' Ends Around Surveys
04:01
Mongoose Tips
06:06
-
The Home Stretch!
57:29
Fetching a List of Surveys
09:09
Whitelisting Model Fields
10:00
Testing Surveys Endpoint
02:11
Wiring Surveys Up to Redux
06:00
Wiring React to Redux
06:52
Rendering a List of Surveys
08:12
Reversing the Survey List
02:21
Expanding the App
12:44
