                    Node with React: Fullstack Web Development
                    Course Notes
                    
                    
                    Section 1 – Course Overview - Start Here!
1 - How to Get Help
A brief intro to the course and the run through of the resources used in the course
  - Use Node.js version 8.1.x and above
The course is an advanced course
  - There may be issues so it is recommended to use the various links in the resource documents

2 - Course Resources Document
A text document with a direct link to the resources used in the course

3 - [Optional] Prettier Setup
An instruction guide to using Prettier for code formatting
  - https://github.com/prettier/prettier
  - This is optional but recommended by the course instructor
  - A quick demo of the effect prettier has on code

4 - App Overview
The course will cover the creation of a single app
  - It will be a larger application with a number of features
  - It will have both a front and backend to it

5 - App User Flow Walkthrough
App is essentially a feedback collection application
The application steps are
  - User signs up via Google OAuth
  - They pay for email credits via Stripe
  - User creates a new campaign
  - User enters a list of emails to send surveys to
  - We send the email to the list 
  - Recipients click on link in the email to provide feedback
  - Tabulate the feedback
  - User can see a report of all survey responses

6 - Tech Stack
A discussion on the various types of technology that will be used in the course
  - React
  - Redux
  - Redux Form
  - PassportJS
  - MongoDB -- The database (no-sql)
  - Stripe -- To handle payments
  - E-mail service

7 - App Mockups
Some static mockups of the example application and the workflow 



                    Section 2 – Server Side Architecture
1 - Application Architecture
The first discussion on how the various technologies will work together
  - Although there are a lot of educational material available on the individual technologies there is little 
  available on how the various pieces work together
  - This is the aim of the course, at the end you should understand how the pieces work together
In the course sample application
  - Whenever a user navigates to the application
  - We will send them back a HTML document and some JS files containing a React application
  - The application will use MongoDB for storing data eg surveys etc
  - The React part of the application will never talk directly to the MongoDB database
    - We will instead put an Express API in between
    - The Express API and React will use HTTP requests to communicate

2 - Relationship Between Node and Express
There is a comprehensive set of notes on Node available at
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/NodeJS/Learning NodeJs
Generating a new npm project
  - mkdir project
  - cd project
  - npm init
The first dependency to be installed is Express
  - npm install --save express                                // --save adds the entry to the package.json file
Some definitions of Node & Express are given in the interests of clarity
  - Node is a Javascript runtime which is used to execute code outside of the browser
    - Javascript was traditionally browser only
  - Express is a library that runs in the Node runtime, it has helpers to make dealing with HTTP easier
    - There is an indepth explanation of how Express works
    - The notes link above has detailed explanations on Express

3 - Generating Express Apps
The instructor uses Atom but any code editor will do
  - The package-lock.json only appears for people using Node version 5 and higher
We create a new file called index.js
  - The convention in React is to use index.js as an entry point into the app
  - We will create a new express app with our first route handler
Example Syntax
  // There will be some tutorials on Javascript module in the course
  // We will use common.js for modules which is supported by Node
  // Common.js is a system for sharing code through modules on node
  // Node does not have support for ES2015 modules
  const express = require("express");
  const app = express();
  
  app.get('/', (req, res) => {
    res.send({hi: 'there'});
  });

app.listen(5000);                  // You may need to use process.env.PORT, process.env.IP depending on your environment
To run the application
  node index.js                    // This is on the c9 cloud IDE so may differ 

4 - Express Route Handlers
An examination of the code from the previous section
  - Anybody familiar with express can skip

5 - Heroku Deployment Checklist
This is how to handle deployment
  - It will be deployed to the Heroku platform located at
    - https://www.heroku.com/
  - Heroku has a free tier available which is great for testing apps
There is a checklist that needs to be gone through
  - Dynamic Port Binding
    - This is because Heroku tells the app what port to use so it needs to listed
  - Specify Node Environment
    - Heroku will need to know which version of Node to use
    - This is added to the package.json file
    "engines": {
      "node": "8.1.1",
      "npm": "5.0.3"
    }
  - Specify start script
    - This will instruct Heroku on what command to run to start the server
    "scripts": {
      "start": "node index.js"
    }
  - Create a .gitignore file
    - Heroku will include dependencies so that we do not have to

6 - Installing the Heroku CLI
The checklist from the previous video will be used on every Node.js deployment to Heroku
  - The diagram is available on Github and is recommended to have a copy
The course will use local git repositories rather than remote like github

7 - Verifying Heroku Deployment

8 - Followup Deployments



                    Section 3 – Authentication with Google OAuth
1 - Intro to Google OAuth

2 - The OAuth Flow

3 - Overview of Passport JS

4 - Passport Setup

5 - Enabling Google OAuth API

6 - Securing API Keys

7 - Google Strategy Options

8 - Testing OAuth

9 - Authorized Redirect URI's

10 - OAuth Callbacks

11 - Access and Refresh Tokens

12 - Nodemon Setup



                    Section 4 – Adding MongoDB
1 - Server Structure Refactor

2 - The Theory of Authentication

3 - Signing In Users with OAuth

4 - Introduction to MongoDB

5 - MongoDB Setup

6 - Connecting Mongoose to Mongo

7 - Breather and Review

8 - Mongoose Model Classes

9 - Saving Model Instances

10 - Mongoose Queries

11 - Passport Callbacks

12 - Encoding Users

13 - Deserialize User

14 - Enabling Cookies

15 - Testing Authentication

16 - Logging Out Users

17 - [Optional] A Deeper Dive



                    Section 5 – Dev vs Prod Environments
1 - Dev vs Prod Keys

2 - Generating Production Resources

3 - Determining Environment

4 - Version Control Scheme

5 - Heroku Env Variables

6 - Fixing Heroku Proxy Issues



                    Section 6 – Moving to the Client Side
1 - React App Generation

2 - A Separate Front End Server

3 - Running the Client and Server

4 - Routing Stumbling Block

5 - The Beauty of Create React App's Proxy

6 - [Optional] Why This Architecture?



                    Section 7 – Developing the Client Side
1 - Async/Await Syntax

2 - Refactoring with Async/Await

3 - Front End Tech

4 - Client React Setup

5 - Installing Root Modules

6 - Troubleshooting NPM

7 - Redux Review and Setup

8 - The Auth Reducer

9 - Finishing Reducer Setup

10 - Why We Care About Auth

11 - React Router Setup

12 - Route Configuration

13 - Always Visible Components

14 - Always Visible Components

15 - Materialize CSS

16 - Webpack with CSS

17 - Header Design

18 - Current User API

19 - Additional Proxy Rules

20 - Basics of Redux Thunk

21 - Refactoring the App

22 - Testing FetchUser

23 - Refactoring to Async/Await

24 - AuthReducer Return Values

25 - Accessing State in the Header

26 - Header Content

27 - Redirecting a User on Auth

28 - Redirect on Logout

29 - Landing Component

30  Link Tags



                    Section 8 – Handling Payments
1 - Client Side Billing

2 - Billing Considerations

3 - Stripe Billing Process

4 - Exploring the Stripe API

5 - Stripe API Keys

6 - Env Variables with React

7 - The Payments Component

8 - Stripe Tokens

9 - Payment Fixes

10 - Reusing Action Types

11 - Positing the Stripe Token

12 - Post Request Handlers

13 - Creating Charges

14 - BodyParser Middleware

15 - Creating a Charge Object

16 - Finalizing a Charge

17 - Adding Credits to a User

18 - Requiring Authentication

19 - Route-Specific Middlewares

20 - Displaying Credit Quantity

21 - Updating Credits



                    Section 9 – Back End to Front End Routing in Production
1 - Express with Create-React-App in Production

2 - Routing in Production

3 - Deployment Options

4 - Adding in a Heroku Build Step

5 - Testing Deployment



                    Section 10 – Mongoose for Survey Creation
1 - Survey Overview

2 - Server Routes

3 - Survey Model

4 - Model Deficiencies

5 - Limitations of Subdocument Collections

6 - Setting up SubDocs

7 - Relationship Fields

8 - Survey Creation Route Handler

9 - Verifying Minimum Credits

10 -Creating Surveys

11 - Creating Subdoc Collections

12 - Oops! A Little Tweak

13 - Creating Mailers

14 - Identifying Unique Users

15 - Sendgrid Setup

16 - Mailer Setup

17 - Mailer in Use

18 - Mailer Constructor

19 - Boilerplate for Sending Emails

20 - More Mailer Properties

21 - Sending SendGrid Emails

22 - Testing Email Sending

23 - Improving the Email Template

24 - Polish in the Route Handler

25 - Verifying Sendgrid Click Tracking

26 - Feedback for User Feedback



                    Section 11 - Back to the Client!
1 - Client Side Survey Creation

2 - Material Icons

3 - Navigation with the Link Tag

4 - SurveyNew Form

5 - Purpose of Redux Form

6 - Redux Form Setup

7 - The ReduxForm Helper

8 - Redux Form in Practice

9 - Custom Field Components

10 - Wiring up Custom Fields

11 - DRY'ing Up Fields

12 - Fields from Config

13 - Styling the Form

14 - Form Validation

15 - Showing Validation Errors

16 - Generalizing Field Validation

17 - Validating Emails

18 - Displaying Invalid Emails

19 - Toggling Visibility?

20 - Advancing From SurveyForm

21 - Retreat to the Form

22 - Persisting Form Values

23 - Refactoring Form Fields

24 - Finalizing Review Fields

25 - Outstanding Form Work

26 - Dumping Form Values

27 - Fixing Property Names

28 - Posting to Surveys

29 - Redirect on Submit



                    Section 12 - Handling Webhook Data
1 - Feedback with Webhooks

2 - Webhooks in Development

3 - LocalTunnel Setup

4 - Testing Webhooks

5 - LocalTunnel Crash Fix
00:43
Finalizing Webhook Setup
06:47
Encoding Survey Data
07:57
Dirty Data from Webhooks
07:15
Processing Pipeline
08:18
Parsing the Route
07:55
Code Cleanup
05:30
Unique Events
05:14
Lodash Chain Helper
10:50
Bad Mongoose Queries
09:09
Finding the Exact Survey
13:48
Updating Records
09:33
Executing Queries
09:25
Testing the Query
02:18
Odds n' Ends Around Surveys
04:01
Mongoose Tips



                    Section 12 - The Home Stretch!
1 - Fetching a List of Surveys

2 - Whitelisting Model Fields

3 - Testing Surveys Endpoint
02:11
Wiring Surveys Up to Redux
06:00
Wiring React to Redux
06:52
Rendering a List of Surveys
08:12
Reversing the Survey List
02:21
Expanding the App
12:44
