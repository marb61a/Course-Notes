                    Node with React: Fullstack Web Development
                    Course Notes

The application from this course is deployed on Heroku at
  - https://fullstackreactnode.herokuapp.com
The GitHub repository for the source code is located at
  - https://github.com/marb61a/fullstack_node_react


                    
                    Section 1 – Course Overview - Start Here!
1 - How to Get Help
A brief intro to the course and the run through of the resources used in the course
  - Use Node.js version 8.1.x and above
The course is an advanced course
  - There may be issues so it is recommended to use the various links in the resource documents

2 - Course Resources Document
A text document with a direct link to the resources used in the course

3 - [Optional] Prettier Setup
An instruction guide to using Prettier for code formatting
  - https://github.com/prettier/prettier
  - This is optional but recommended by the course instructor
  - A quick demo of the effect prettier has on code

4 - App Overview
The course will cover the creation of a single app
  - It will be a larger application with a number of features
  - It will have both a front and backend to it

5 - App User Flow Walkthrough
App is essentially a feedback collection application
The application steps are
  - User signs up via Google OAuth
  - They pay for email credits via Stripe
  - User creates a new campaign
  - User enters a list of emails to send surveys to
  - We send the email to the list 
  - Recipients click on link in the email to provide feedback
  - Tabulate the feedback
  - User can see a report of all survey responses

6 - Tech Stack
A discussion on the various types of technology that will be used in the course
  - React
  - Redux
  - Redux Form
  - PassportJS
  - MongoDB -- The database (no-sql)
  - Stripe -- To handle payments
  - E-mail service

7 - App Mockups
Some static mockups of the example application and the workflow 



                    Section 2 – Server Side Architecture
1 - Application Architecture
The first discussion on how the various technologies will work together
  - Although there are a lot of educational material available on the individual technologies there is little 
  available on how the various pieces work together
  - This is the aim of the course, at the end you should understand how the pieces work together
In the course sample application
  - Whenever a user navigates to the application
  - We will send them back a HTML document and some JS files containing a React application
  - The application will use MongoDB for storing data eg surveys etc
  - The React part of the application will never talk directly to the MongoDB database
    - We will instead put an Express API in between
    - The Express API and React will use HTTP requests to communicate

2 - Relationship Between Node and Express
There is a comprehensive set of notes on Node available at
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/NodeJS/Learning NodeJs
Generating a new npm project
  - mkdir project
  - cd project
  - npm init
The first dependency to be installed is Express
  - npm install --save express                                // --save adds the entry to the package.json file
Some definitions of Node & Express are given in the interests of clarity
  - Node is a Javascript runtime which is used to execute code outside of the browser
    - Javascript was traditionally browser only
  - Express is a library that runs in the Node runtime, it has helpers to make dealing with HTTP easier
    - There is an indepth explanation of how Express works
    - The notes link above has detailed explanations on Express

3 - Generating Express Apps
The instructor uses Atom but any code editor will do
  - The package-lock.json only appears for people using Node version 5 and higher
We create a new file called index.js
  - The convention in React is to use index.js as an entry point into the app
  - We will create a new express app with our first route handler
Example Syntax
  // There will be some tutorials on Javascript module in the course
  // We will use common.js for modules which is supported by Node
  // Common.js is a system for sharing code through modules on node
  // Node does not have support for ES2015 modules
  const express = require("express");
  const app = express();
  
  app.get('/', (req, res) => {
    res.send({hi: 'there'});
  });

app.listen(5000);                  // You may need to use process.env.PORT, process.env.IP depending on your environment
To run the application
  node index.js                    // This is on the c9 cloud IDE so may differ 

4 - Express Route Handlers
An examination of the code from the previous section
  - Anybody familiar with express can skip

5 - Heroku Deployment Checklist
This is how to handle deployment
  - It will be deployed to the Heroku platform located at
    - https://www.heroku.com/
  - Heroku has a free tier available which is great for testing apps
There is a checklist that needs to be gone through
  - Dynamic Port Binding
    - This is because Heroku tells the app what port to use so it needs to listed
  - Specify Node Environment
    - Heroku will need to know which version of Node to use
    - This is added to the package.json file
    "engines": {
      "node": "8.1.1",
      "npm": "5.0.3"
    }
  - Specify start script
    - This will instruct Heroku on what command to run to start the server
    "scripts": {
      "start": "node index.js"
    }
  - Create a .gitignore file
    - Heroku will include dependencies so that we do not have to
    - Just add node_modules to the .gitignore file and save

6 - Installing the Heroku CLI
The checklist from the previous video will be used on every Node.js deployment to Heroku
  - The diagram is available on Github and is recommended to have a copy
The course will use local git repositories rather than remote like github
  - However I use a cloud ide so GitHub is more convenient
  - Installing Heroku will differ on each platform/OS 
  - Heroku is installed by default on each vm on the Cloud9 platform
  - To check if heroku is installed at the cli prompt -> heroku -v

7 - Verifying Heroku Deployment
To get started with deploying you must first login from the prompt in your project
  - heroku login
  - This will prompt you for both the email address and password you use for heroku
Then is the creation of a new application
  - heroku create 
  - This generates 2 separate links
    - The first is the browser url, the name is randomly generated
    - The second is a deployment target git repository
      - This needs to be added to heroku using -> git remote add heroku 
      - It may say remote already exists which is perfectly fine
Then is the push to heroku
  - git push heroku master
To automatically open a browser window with the browser url
  - heroku open

8 - Followup Deployments
After the initial deployment there will of course need to be more deployments
  - In practice this is relatively straight forward
  - You will need to ensure that changes in files are saved
  - The command git status shows what files have changed
  - Then commit the files using git commit -m "mesage"
  - Then run git push heroku master as before
You can rename the site using
  - heroku apps:rename new-app-name



                    Section 3 – Authentication with Google OAuth
1 - Intro to Google OAuth
The OAuth material will be difficult
  - This is the most challenging pasrt of the course
  - There are a lot of skills which will transfer to other projects
  - The student should learn a lot of skills
  - The goal is to have a button which allows a user to sign up for the site using Google or other sites sign in
  - Email and password signup and login is decreasing in popularity and is considered a legacy technology
  - OAuth is recommended by the course instructor to use for apps
    - Users may sign up quicker for services using OAuth
  - There are several different steps associated with setting up OAuth

2 - The OAuth Flow
Walking through the flow of the OAuth process flow
  - User clicks on the login button
    - This will direct to a url looking like address/auth/google
  - A server forwards the request to Google
    - This uses a url looking like google.com/auth?appid=123
  - Google then asks the user if they grant permission
  - The user is then expected to grant permission
    - This uses a url looking like address/auth/google/callback?code=456
  - Put the user on hold and take the code from the url
  - Send a request to google with the code included
  - Get the user details and create a new record in the database
  - Set the user id in a cookie for this user
  - User is now Logged In

3 - Overview of Passport JS
Passport is a library which will help with the authentication flow
  - It will take care of a couple of steps and will make life a ittle easier
  - Passport will help reduce boilerplate
  - There are a couple of common complaints about Passport
    - Passport requires reaching in to specific flow points, this can affect how understood the process is
    - The second complaint is about how misuderstood the structure is, there are actually at least 2 libraries
      - passport -- core library of general helpers for handling auth in Express
      - passport-strategy -- library of helpers for handling authentication using a specific method eg Google 
  - The example app will only use Google as sign in provider
  
4 - Passport Setup
Using NPM to install both the base Passport module but also the Google OAuth strategy
  // Using 20 means that it uses OAuth2.0
  - npm install -- save passport passport-google-oauth20
Initially everything will be in the index.js file but that will be refactored
The passport and google strategy modules will need to be available in index.js
  - const passport = require('passport');
  - const GoogleStrategy = require("passport-google-oauth20").Strategy; 
There will need to be a new instance of GoogleStrategy to make use of it
  - It is added into passport.use in order to basically tell passport a new strategy is available
  - passport.use(new GoogleStrategy());

5 - Enabling Google OAuth API
** Process has been slightly changed and looks slightly different too
To go to the Google OAuth API
  - https://console.developers.google.com
  - You must have a Google account (free so easy to signup for)
  - You will need to create a new project
  - You should append dev to the project name as there will be a second one needed later in the course
  - Creating the project does not instantly create it but rather starts the process
  - After creation the Google OAuth API will need to be enabled
    - To signup for the OAuth API you must use the Google+ API
  - After this then the API credential must be created
    - Click on create credentials to get started
  - The client id and the client secret are the tokens that are needed

6 - Securing API Keys
ClientID - This token can be shared with the public
ClientSecret - This token should not be seen by anybody
  - Be careful not to push secret keys to Github
  - Add a config folder and a keys file to hold sensitive information
  - Ensure that the keys file is added to the .gigignore file

7 - Google Strategy Options
Ensure that the D in ID is uppercase
The keys will now need to be imported into the index.js file
Any file with a .js does not need the ending passed in
  - const keys = require("./config/keys");
Add them to the Google Strategy
  - clientID: keys.googleClientID,
  - clientSecret: keys.googleClientSecret,
  - callbackURL: 'auth/google/callback'
After the keys and url have been added to GoggleStrategy then there is a callback function added
  - This will only have console.log at this point

8 - Testing OAuth
In this section the will need to a be a route handler to ensure users are puuled into the OAuth flow
  - Instead of the second argument being a function the flow will go to passport
    - This will use passport.authenticate with two arguments 
    - A string google and an object with 2 parameters (email, profile) in a scope array 
    - The string google is used an the internal id of the passport strategy and will call it when used
    - Scopes will be the permissions eg access to email etc
    - Uri mismatches can occur during the OAuth setup and can be helpful in understanding what is happenning under the hood

9 - Authorized Redirect URI's
Disecting a mismatch URI string
  - The code needed from google is asked for using response_type=code
  - The scopes defined in the sorce code are seen
  - The clientID is also part of the returned message
  - The redirect URI is the address that a user is redirected to from Google and is part of the error message
  - Redirect URI can be a security concern, redirecting users to malicious sites
  - Google tracks valid URL's users can be redirected to
  - There will need to be change to the redirect url in the google developer console

10 - OAuth Callbacks
When running the application there will be a /GET error for the redirect url
  - This is because the route handler has not been setup yet
  - Like previous route setup the second parameter in app.use is not a function
  - There is no need to pass a scope object in this route just the passport.authenticate

11 - Access and Refresh Tokens
Covering more information on the access token being logged out
  - The callback function will uses the user information returned from Google
  - This information will be used to create a new record in the database
  - To better understand what is going on behind the scenes a few parameters are logged out to the console
    - accessToken, refreshToken, profile
  - The terminal will show the user identification information in text form
  - The access token is a token that allows for certain actions to be performed
  - The refresh token is used to refresh the access token
    - Access tokens have automatic expiration
This is where the Passport part of the application ends

12 - Nodemon Setup
To avoid the need for constantly stopping and restarting the server
  - Adding the nodemon package will stop this need
  - npm --save nodemon
To use nodemon on the application it is necessary to add on to the package.json script section
  - "dev": "nodemon index.js"
  - At the prompt type npm run dev and it will now run automatically



                    Section 4 – Adding MongoDB
1 - Server Structure Refactor
Refactoring the Passport & Strategy code out to separate files
  - Express does not really have a conventiion on project structure
  - Add a routes folder and a routesAuth.js file which will hold the route handlers
    - Because these are both related to authentication they can go in the same file
  - Then add a services directory to hold the Passport service
  - The various requirements and paths need to be adjusted as necessary
  - The new files will have to be required where necessary

2 - The Theory of Authentication
A quick discussion on the theory of how authentication works
  - Some other points are about why there is such concern about authentication
  - There is a discussion on HTTP
    - A set of notes on HTTP & HTTP2 is available at
      - https://github.com/marb61a/Course-Notes/blob/master/General Development/HTTP2 Fundamentals

3 - Signing In Users with OAuth
Using the OAuth flow to show how a user logs in
Firstly is a discussion on the email & password login process
There is a full tutorial on the OAuth process at
  - https://www.tutorialspoint.com/oauth2.0/

4 - Introduction to MongoDB
A quick discussion on the NoSQL database MongoDB
There are notes on MongoDB available at
  - https://github.com/marb61a/Course-Notes/edit/master/General Development/Databases/MongoDB/The Complete Developers Guide to MongoDB

5 - MongoDB Setup
Setting up MongoDB for the project
  - The project will not use a local version of MongoDB
  - It will use a cloud service provider called MLab
    - https://mlab.com
    - There is a free tier available for projects
  - A quick run though of the process of creating a new database
    - Click the create new button
    - Choose the free option
    - Select the region nearest
    - Choose a name for the database
    - The default versio of MongoDB can be left unchanged
  - Click on the database just created to go to that databases dashboard
    - At this point there will not be any collections
    - You will also be asked to create a user account
      - This is a database and not an account for app users to access the database
    - Go to the users tab and add a database user
    - Add password and username & create
      - Ensure read-only is unchecked

6 - Connecting Mongoose to Mongo
Installing Mongoose
  - It maybe better to kill a running server while installing NPM packages
  - npm install --save mongoose
In the index.js file we can begin to wire up mongoose
  - Firstly mongoose will need to be required
  - Next is then to connect to MongoDb using mongoose.connect()
    - This will have the address of the Mongo instance just created
    - Be careful not to accidentally commit this to GitHub
  - Add the URI to the keys config file
  - Require the keys file and connect using the correct name of the mongo URI
When restarting the server there maybe warnings of deprecation
  - This is an internal mongoose issue
  - These issues will need to be resolved by Mongoose developers

7 - Breather and Review
A quick review of what has been covered this far in the section

8 - Mongoose Model Classes
At this point we now need to create a model class using Mongoose
  - This will allow us to create a new collection of records inside the database
Add a new folder called models which will hold all models needed
  - Add a file called User.js to hold the User model class
    - First you need to require the Mongoose library
    - Pull the Schema property from Mongoose
      - The following 2 lines are exactly the same
      - const Schema = mongoose.Schema;
      - The version below uses syntax called destructuring which will be used throughout the course
      - const { Schema } = mongoose;
    - Mongoose needs to know all the properties of records being
    - These must be defined ahead of time using the schema object
    - The schema for the user initially contains googleId of type string
    - To create a model which can be used use mongoose.model and a collection name and the userSchema
    - Mongoose will not overwrite a collection but will add if it does not exist
    - You can add properties to models as and when needed
    - The file will also need to be required in index.js in order to be used

9 - Saving Model Instances
Where are we going to create a new user
  - In passport.js servie file the callback function is passed a user profile which contains the user google id needed
  - Require will not be used in the passport file to import the model file
    - Sometimes using mongoose in a test environment models will call models multiple times
    - This causes confusion within Mongoose
  - Instead in passport file the mongoose library will be required
    - Then assign a const User to the mongoose.model('users')
  - Add a new User with the property googleId of profile.id 
  - Ensure the user model is required in index.js prior to services/passport
    - This will cause an error as Passport will be trying to use something before it is available

10 - Mongoose Queries
At the moment a user can have multiple versions of their GoogleID
  - This will need to be changed by checking to see if the profile exists
  - If the user exists then skip creation, if not then create the user
  - This will be done using the User.findOne() method which will search the collection using predefined criteria
  - This query is an asynchronus action which returns a promise
    - The course will not cover Promises heavily but instead use ES2017 syntax
    - The Promis example being used here will be refactored
  - A .then() method is added which will take an arrow function
  - The arrow function has a value called existingUser passed to it
  - Use the existingUser with an if else statement
    - This will check to see if the user already exists and skips or creates depending on the answer
  - Move the existing new User logic into the else statement

11 - Passport Callbacks
Continuing on from the previous section
  - If the user already exists then we will call the done function
  - done() will take two different arguments
    - The first is an null object and then existingUser
  - done() is an asynchronous operation and should not be called until it is clear that the user is on the database already
  - This is resolved by chaining a then function to the user add function in the else statement
  - The then() function will take in a user and pass it to done which has arguments of null and user just saved 

12 - Encoding Users

13 - Deserialize User

14 - Enabling Cookies

15 - Testing Authentication

16 - Logging Out Users

17 - [Optional] A Deeper Dive



                    Section 5 – Dev vs Prod Environments
1 - Dev vs Prod Keys

2 - Generating Production Resources

3 - Determining Environment

4 - Version Control Scheme

5 - Heroku Env Variables

6 - Fixing Heroku Proxy Issues



                    Section 6 – Moving to the Client Side
1 - React App Generation

2 - A Separate Front End Server

3 - Running the Client and Server

4 - Routing Stumbling Block

5 - The Beauty of Create React App's Proxy

6 - [Optional] Why This Architecture?



                    Section 7 – Developing the Client Side
1 - Async/Await Syntax

2 - Refactoring with Async/Await

3 - Front End Tech

4 - Client React Setup

5 - Installing Root Modules

6 - Troubleshooting NPM

7 - Redux Review and Setup

8 - The Auth Reducer

9 - Finishing Reducer Setup

10 - Why We Care About Auth

11 - React Router Setup

12 - Route Configuration

13 - Always Visible Components

14 - Always Visible Components

15 - Materialize CSS

16 - Webpack with CSS

17 - Header Design

18 - Current User API

19 - Additional Proxy Rules

20 - Basics of Redux Thunk

21 - Refactoring the App

22 - Testing FetchUser

23 - Refactoring to Async/Await

24 - AuthReducer Return Values

25 - Accessing State in the Header

26 - Header Content

27 - Redirecting a User on Auth

28 - Redirect on Logout

29 - Landing Component

30  Link Tags



                    Section 8 – Handling Payments
1 - Client Side Billing

2 - Billing Considerations

3 - Stripe Billing Process

4 - Exploring the Stripe API

5 - Stripe API Keys

6 - Env Variables with React

7 - The Payments Component

8 - Stripe Tokens

9 - Payment Fixes

10 - Reusing Action Types

11 - Positing the Stripe Token

12 - Post Request Handlers

13 - Creating Charges

14 - BodyParser Middleware

15 - Creating a Charge Object

16 - Finalizing a Charge

17 - Adding Credits to a User

18 - Requiring Authentication

19 - Route-Specific Middlewares

20 - Displaying Credit Quantity

21 - Updating Credits



                    Section 9 – Back End to Front End Routing in Production
1 - Express with Create-React-App in Production

2 - Routing in Production

3 - Deployment Options

4 - Adding in a Heroku Build Step

5 - Testing Deployment



                    Section 10 – Mongoose for Survey Creation
1 - Survey Overview

2 - Server Routes

3 - Survey Model

4 - Model Deficiencies

5 - Limitations of Subdocument Collections

6 - Setting up SubDocs

7 - Relationship Fields

8 - Survey Creation Route Handler

9 - Verifying Minimum Credits

10 -Creating Surveys

11 - Creating Subdoc Collections

12 - Oops! A Little Tweak

13 - Creating Mailers

14 - Identifying Unique Users

15 - Sendgrid Setup

16 - Mailer Setup

17 - Mailer in Use

18 - Mailer Constructor

19 - Boilerplate for Sending Emails

20 - More Mailer Properties

21 - Sending SendGrid Emails

22 - Testing Email Sending

23 - Improving the Email Template

24 - Polish in the Route Handler

25 - Verifying Sendgrid Click Tracking

26 - Feedback for User Feedback



                    Section 11 - Back to the Client!
1 - Client Side Survey Creation

2 - Material Icons

3 - Navigation with the Link Tag

4 - SurveyNew Form

5 - Purpose of Redux Form

6 - Redux Form Setup

7 - The ReduxForm Helper

8 - Redux Form in Practice

9 - Custom Field Components

10 - Wiring up Custom Fields

11 - DRY'ing Up Fields

12 - Fields from Config

13 - Styling the Form

14 - Form Validation

15 - Showing Validation Errors

16 - Generalizing Field Validation

17 - Validating Emails

18 - Displaying Invalid Emails

19 - Toggling Visibility?

20 - Advancing From SurveyForm

21 - Retreat to the Form

22 - Persisting Form Values

23 - Refactoring Form Fields

24 - Finalizing Review Fields

25 - Outstanding Form Work

26 - Dumping Form Values

27 - Fixing Property Names

28 - Posting to Surveys

29 - Redirect on Submit



                    Section 12 - Handling Webhook Data
1 - Feedback with Webhooks

2 - Webhooks in Development

3 - LocalTunnel Setup

4 - Testing Webhooks

5 - LocalTunnel Crash Fix

6 - Finalizing Webhook Setup

7 - Encoding Survey Data

8 - Dirty Data from Webhooks

9 - Processing Pipeline

10 - Parsing the Route

11 - Code Cleanup

12 - Unique Events

13 - Lodash Chain Helper

14 - Bad Mongoose Queries

15 - Finding the Exact Survey

16 - Updating Records

17 - Executing Queries

18 - Testing the Query

19 - Odds n' Ends Around Surveys

20 - Mongoose Tips



                    Section 12 - The Home Stretch!
1 - Fetching a List of Surveys

2 - Whitelisting Model Fields

3 - Testing Surveys Endpoint

4 - Wiring Surveys Up to Redux

5 - Wiring React to Redux

6 - Rendering a List of Surveys

7 - Reversing the Survey List

8 - Expanding the App
