                    Advanced State Management in React Applications (Redux, MobX, sagas, etc.)
                    Course Notes


1 - 
Introduction to the instructor
In order to understand state the course will take a tour of different approaches to managing state
In order to understand more the course will start right from the ground up
State management can become very complex very quickly
  - The React timer component that is usually the start of React training will be where understanding state will begin
There is also a quick overview of the syllabus
Redux will be taught seperately which the instructor recommends as the best approach
  - Redux is not tied to React in any way
  - React takes some of its ideas from the elm language
  - Redux-Saga will also be looked at
  - A thunk is a way to defer an action
Mobx which is a different approach than Redux for state management
  - Mobx has an approach which is similar to object oriented
State management is not a solved problem
Not too much focus on a given library will be give because
  - Libraries will come and go and may not be useful in 6 or 12 months time
The goal of the course is how to think conceptually about the patterns
  - Patterns and approaches tend to stick around longer than libraries
  - By the end you should be able to apply concepts to new frameworks
The course will cover 9 different sections
  - It is not necessarily only React based
  - The main goal of React is to take application state and turn it into DOM nodes
    - The React design team have their own thoughts on React and state management
      - One of the key ideas is DRY -- Don't Repeat Yourself
        - Figure out the absolute minimal implementation of state your app needs and then compute the rest on-demand
      - The example used is Full Name, if you have first and last name you do not want to have to set the full name 
        state manually
      - This approach will save a lot of bugs as the amount of mistakes made are more limited
      - The best way to become good at state management is to manage as little state as possible
   - React is all about one way data flow down the component hierarchy
    - It may not be immediately clear which component should own a state
      - This part can be very confusing for newcomers
What is State
  - Is it passed from parents as Props, if so it probably isnt state
  - Does it remain unchaged over time, if so it probably isn't state
  - Can you compute it based on any other state or props in your component, if so it probably isn't state
Props v State
  - Props are not necessarily state but are usually parent state
  - This that can change with user input are things we have to worry about
  - State is created in the component and stays in the component, it can be passed to children as props
Example Syntax
  // To demonstrate state and props
  class Counter extends Component {
    state = { count: 0 }
    render(){
      const { count } = this.state;
      return(
        <div>
          <h2>This is my state: { count }. </h2>
          <DoubleCount count={count} />
        </div>
      )
    }
  }
  
  class DoubleCount extends Component {
    render(){
      const { count } = this.props;
      return(
        <p>
          This is my prop: { count }.
        </p>
      )
    }
  }
  
There are many different kinds of state
  - All state is not created equal
  - Model Data -- The nouns in your application
  - View/UI State -- Are these nouns in ascending or descending order
  - Session State -- Is the user logged in
  - Communication -- Are we in the process of fetching the nouns from the server
  - Location -- Where are we in the application, which nouns are we looking at

It might in some instances prefer to think about state relative to time
  - Long lasting state -- This will likely be the data in yuor application
  - Ephemeral State - This will be things that get wiped away such as a user input box when enter is pressed

In app development you should ask yourself
  - Does an input field need the same kind of state management as model data
  - There may not be a proper answer, it will depend on the app and there are benefits and costs to each
  - There is no silver bullet available to all of this

An uncomfortably close look at React component state
  - This starts with a simple React component
  
Exercise 
  - The first exercise is to wire up a sample exercise which will get button counters working

2 -
Example Syntax
  // Exercise 1 solution
  // The main idea of the challenge is to get the basic state working 
  // Counter.js
  import React, { Component } from 'react';
  
  export default class Counter extends Component{
          // This can be eliminated using the arrow function
          constructor(){
            super();
            this.state = {
              // This will give the component some state
              count: 0
            };
          }  
    
    state = {
      count: 0
    }
    
    // Using modern versions of babel we can use the arrow function will help avoid using bind
    // This will define it on the instance and the arrow function will bind it to the instance
    handleIncrement = () => {
      this.setState({
        count: this.state.count + 1
      })
    }
    
    handleDecrement = () => {
      this.setState({
        count: this.state.count - 1
      })
    }
    
    reset = () => {
      this.setState({
        count: 0
      })
    }
    
    render(){
      // Using ES6 destructuring
      const { count } = this.state;
    
      return(
        <section className="Counter">
          <h1>Count: {count}</h1>
          <button onClick={this.handleIncrement} className="full-width">Increment</button>
          <button onClick={this.handleDecrement} className="full-width">Decrement</button>
          <button onClick={this.handleReset} className="full-width">Reset</button>
        </section>
      );
    }
  } 

Example Syntax
  // Quiz examples
  class Counter extends Component{
    constructor(){
      this.state = {
        counter: 0
      }
    }
    
    render(){}
  }
  
  In a function the following is added, what will be displayed
  this.setState({count: this.state.count + 1});
  this.setState({count: this.state.count + 1});
  this.setState({count: this.state.count + 1});
  
  // The answer is 0 as this.setState is nearly always asynchronous
  // This is becauses React is trying to avoid unnecessary re-renders
  console.log(this.state.count);

  // What will be displayed in this eaxmple
  export default class Counter extends Component{
    constructor(){
      super();
      this.state = {
        count: 0
      }
      this.increment = this.increment.bind(this);
    } 
    
    increment(){
    // The answer is 1 as the effect is having a queue of state changes
    // React will then batch them up and efficiently make that change
      this.setState({count: this.state.count + 1});
      this.setState({count: this.state.count + 1});
      this.setState({count: this.state.count + 1});
    }
    
    render(){
      return(
        <section>
          <h1>Count: {this.state.count}</h1>
          <button onClick={this.increment}>Increment</button>
        </section>
      );
    }
  }

There is a bit more to this.setState()
  - You can pass in items other than objects
  - A function can also be passed in as the argument in stead of the object
  - It also can take a callback as a second argument
Example Syntax
  // Passing in a function
  // This will return 3
   increment(){
      this.setState((state) => {return {count: state.count + 1}});
      this.setState((state) => {return {count: state.count + 1}});
      this.setState((state) => {return {count: state.count + 1}});
    }
  
  - A function will run though each item
  - The more useful feature of this is that it gives more programmatic control
  
Example Syntax
  // The same as above but with more programmatic logic
  export default class Counter extends Component{
    constructor(){}
    
    increment(){
      this.setState(state => {
        if(state.count >=  5) return;
        return {count: state.count + 1 };
      });
    }
    
    render(){
      return(
        <section>
          <h1>Count: {this.state.count}</h1>
          <button onClick={this.increment}>Increment</button>
        </section>
      );
    }
  }

Example Syntax
  // Using a callback as a second parameter 
  export default class Counter extends Component{
    constructor(){}
    
    increment(){
      this.setState(
        {count: this.state.count + 1 },
        // This can be useful when storing state into localStorage for example
        () => { console.log(this.state); }
      );
    }
    
    render(){ }
  }

Patterns & Anti-Patterns
  - State should be considered as private data
  - Working with state is more dangerous than working with props
    - This is because props have propTypes where are state doesn't
    - This can be mitigated by passing state in as props
  - If something is not used in the render method is should not be state
  - Do not use this.state for derivations of props
    - Instead derive computed properties from the props themselves
Example Syntax
  // Deriving props rather than using derivations of props
  // Don't go too far in deriving the state, instead pull it out into a method
  class User extends Component{
    // This only a method on the components class that will get the full name based on the 2 parts of state
    get fullName(){
      const { firstName, lastName } = this.props;
      return firstName + ' ' + lastName;
    }
    
    render(){
      return (
        <h1>{this.fullName}</h1>
      );
    }
  }

It is not necessary to shove everything into the render method
  - You can and should break things out into helper methods
  
Example Syntax
  // Simplified render method
  class UserList extends Component {
    renderUserProfile(user){
      return(
        <UserProfile 
          key={user.id}
          photograph={user.mugshot}
          onLayoff={handleLayoff}
        />
      );
    }
    renderUserProfile(){
      const { users } = this.props;
      
      return(
        <section>
          <VeryImportantUserControls />
            { users.map(this.renderUserProfile) }
          <SomeSpecialFooter />
        </section>
      );
    }
  }

As a developer you will read more than you write
  - The most important person is future you as you will not remember code several months down the road

Don't use state for things that you will not render
Example Syntax
  // This should be broken out into 
  class TweetStream extends Component {
    constructor(){
      super();
      this.state = {
        tweets: [],
        tweetChecker: setInterval(() => {
        // There is no need for this to be stored on the state
          Api.getAll('/api/tweets').then(newTweets => {
            const { tweets } = this.state;
            this.setState({ tweets: [ ...tweets, newTweets ]});
          })
        }, 10000);
      }
    }
    
    componentWillUnmount(){
      clearInterval(this.state.tweetChecker);
    }
    
    render(){// Do some stuff with tweets}
  }

When possible use sensible defaults eg if an API returns an array then the default state should be an array
There is also a demo of the course app which contains some challenges which will be done during the course

3 -
Solving the challenges with the course app
  - The course app is small but has many of the challenges that larger apps face
Example Syntax
  // Firstly a default state will need to be set
  state = {
    items: defaultState
  }
  
  // The next challenge is to get items from state
  render(){
    // Using ES6 destructuring syntax to get items
    const { items } = this.state
  }
  
  // Each of the items has a boolean value for whether the items are packed or not
  // In this example this will filter through each item on every render which would not be 
  // practical in production apps
  const unpackedItems = items.filter(item => !item.packed);
  const packedItems = items.filter(item => item.packed);
  
  // They now need to be passed to the component
  return(
    <div>
      <Items title="Unpacked Items" items={unpackedItems} />
      <Items title="packedItems" items={packedItems} />
    </div>
  );

At this point the items should be rendering to the page


4 -

5 - 

6 -

7 -

8 -

9 - 

10 -

11 -

12 -

13 -

14 - 
