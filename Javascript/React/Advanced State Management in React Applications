                    Advanced State Management in React Applications (Redux, MobX, sagas, etc.)
                    Course Notes


1 - 
Introduction to the instructor
In order to understand state the course will take a tour of different approaches to managing state
In order to understand more the course will start right from the ground up
State management can become very complex very quickly
  - The React timer component that is usually the start of React training will be where understanding state will begin
There is also a quick overview of the syllabus
Redux will be taught seperately which the instructor recommends as the best approach
  - Redux is not tied to React in any way
  - React takes some of its ideas from the elm language
  - Redux-Saga will also be looked at
  - A thunk is a way to defer an action
Mobx which is a different approach than Redux for state management
  - Mobx has an approach which is similar to object oriented
State management is not a solved problem
Not too much focus on a given library will be give because
  - Libraries will come and go and may not be useful in 6 or 12 months time
The goal of the course is how to think conceptually about the patterns
  - Patterns and approaches tend to stick around longer than libraries
  - By the end you should be able to apply concepts to new frameworks
The course will cover 9 different sections
  - It is not necessarily only React based
  - The main goal of React is to take application state and turn it into DOM nodes
    - The React design team have their own thoughts on React and state management
      - One of the key ideas is DRY -- Don't Repeat Yourself
        - Figure out the absolute minimal implementation of state your app needs and then compute the rest on-demand
      - The example used is Full Name, if you have first and last name you do not want to have to set the full name 
        state manually
      - This approach will save a lot of bugs as the amount of mistakes made are more limited
      - The best way to become good at state management is to manage as little state as possible
   - React is all about one way data flow down the component hierarchy
    - It may not be immediately clear which component should own a state
      - This part can be very confusing for newcomers
What is State
  - Is it passed from parents as Props, if so it probably isnt state
  - Does it remain unchaged over time, if so it probably isn't state
  - Can you compute it based on any other state or props in your component, if so it probably isn't state
Props v State
  - Props are not necessarily state but are usually parent state
  - This that can change with user input are things we have to worry about
  - State is created in the component and stays in the component, it can be passed to children as props
Example Syntax
  // To demonstrate state and props
  class Counter extends Component {
    state = { count: 0 }
    render(){
      const { count } = this.state;
      return(
        <div>
          <h2>This is my state: { count }. </h2>
          <DoubleCount count={count} />
        </div>
      )
    }
  }
  
  class DoubleCount extends Component {
    render(){
      const { count } = this.props;
      return(
        <p>
          This is my prop: { count }.
        </p>
      )
    }
  }
  
There are many different kinds of state
  - All state is not created equal
  - Model Data -- The nouns in your application
  - View/UI State -- Are these nouns in ascending or descending order
  - Session State -- Is the user logged in
  - Communication -- Are we in the process of fetching the nouns from the server
  - Location -- Where are we in the application, which nouns are we looking at

It might in some instances prefer to think about state relative to time
  - Long lasting state -- This will likely be the data in yuor application
  - Ephemeral State - This will be things that get wiped away such as a user input box when enter is pressed

In app development you should ask yourself
  - Does an input field need the same kind of state management as model data
  - There may not be a proper answer, it will depend on the app and there are benefits and costs to each
  - There is no silver bullet available to all of this

An uncomfortably close look at React component state
  - This starts with a simple React component
  
Exercise 
  - The first exercise is to wire up a sample exercise which will get button counters working

2 -
Example Syntax
  // Exercise 1 solution
  // Counter.js
  import React, { Component } from 'react';
  
  export default class Counter extends Component{
    render(){
      return(
        <section className="Counter">
          <h1>Count: {0}</h1>
          <button onClick={() => {}} className="full-width">Increment</button>
          <button onClick={() => {}} className="full-width">Decrement</button>
          <button onClick={() => {}} className="full-width">Reset</button>
        </section>
      );
    }
  } 


3 -

4 -

5 - 

6 -

7 -

8 -

9 - 

10 -

11 -

12 -

13 -

14 - 
