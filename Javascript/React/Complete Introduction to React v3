                    Complete Introduction to React v3
                    Course Notes


                    Section 1 - Introduction
1 - Introduction
Introduction to React course and the agenda. 
  - This is the third version of the course
  - Ensure that you are on the correct version of the course repo
  - There are differences from the first 2 courses covering things like linting and testing etc
A brief bio of the instructor and a quick overview of the syllabus
Mostly you will not use React by itself it will use tools which increase the complexity
  - These are not compulsory eg Using Flow instead of Typescript
Ensure that Node is installed, above 4 is recommended
To get started will need to clone the start repo of the course
  - https://github.com/btholt/complete-intro-to-react/tree/start
A quick run through of the cloned repo
The instructor uses Sublime but it is not compulsory
The dependencies are locked to certain versions to avoid compatability issues

2 - Yarn Dependency Manager
The yarn package manager will be used in the course
Npm has issues which is why Yarn is used
  - Yarn is an npm client
Npm is non-deterministic which can cause deployment issues

3 - Simple React Components
Create a new file in the project created from the cloned GitHub repo
React has 2 different parts to the library
  - Top-level which is the same across the different versions of React
    - It contains the lifecycle methods, create components
  - Between React and what is being rendered too is a glue layer
    - This translates React components to DOM nodes, Native UI elements etc
Example Syntax
  // index.html file
  // The course instructor recommends using Emmet which is a plugin to improve workflow
  // It is available here - https://emmet.io
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>App name</title>
    </head>
    <body>
      <div id="app"></div>
      
      // This pulls in react pre-bundling
      <script src="node_modules/react/dist/react.js"></script>
      <script src="node_modules/react-dom/dist/react-dom.js"></script>
      <script>
        const MyTitle = function(){{
          return(
            React.createElement('div', null, 
              React.createElement('h1', null, "This is my second component")
            )
          )
        }      
      
        const MyFirstComponent = function(){
          return React.createElement('div', null
            React.createElement('h1', null, "This is my first component")
          )
        }
        
        ReactDOM.render(
          React.createElement(MyFirstComponent),
          // Tells where to render which is the div of id 'app'
          document.getElementById("app")
        )
      </script>
    </body>
  </html>

4 - React Paradigm
Being able to create components from components gives the opportunity for powerful patterns
This also allows for reusable components
This differs from Angular or Rails & Django on other languages
MVC may not make sense for interfaces
  - This is why they are put together for components
React component encapsulation helps with debugging
React can be more verbose than Angular but is easier to maintain

5 - Factories & Props
Again using the example code from above
  - It can be verbose writing createElement over and over again
  - There are a lot of React developers that do not know what createElement is
  - This is because they do not have to write it
  - JSX transpiles to createElement calls
  - You do not have to use JSX in apps
    - One example is to set the createElement as a const and use that
    - There are packages like createFactory and react-dom-helpers
Example Syntax
  <script>
    const ce = React.createElement();
    
    const MyTitle = function(props){
    // This needs to be done this way rather than passing in arguments, React actually hooks 
    // into these properties so it knows when to rerender
    // props are synonymous to attributes in html
      return(
        ce('div', null,
          ce('h1', null, {style: {color: props.color}}, props.title)
        )
      )
    }
    
    const MyFirstComponent = function(){
      return ce('div', { id: 'my-first-component '}, 
        ce(MyTitle, {title: 'Game Of Thrones', color: 'YellowGreen'});
        ce(MyTitle, {title: 'Stranger Things', color: 'GreenYellow'});
        ce(MyTitle, {title: 'Rick And Morty', color: 'LimeGreen'});
        ce(MyTitle, {title: 'Silicon Valley', color: 'peru'});
      ) 
    }
  </script>



                    Section 2 -Tools
1 - Prettier
The section starts with creating a new directory and file to put the code from the previous section
  - mkdir js -> ClientApp.jsx
  - The code will then be removed from the script tags
The instructor highly recommends the Prettier tool
  - https://prettier.io
  - It is a code formatting tool which is used by many developers
  - It can clear up some of the issues that occur in code formatting
Example Syntax
  // Using the Yarn package manager
  - yarn global add prettier
  // To check which version is installed
  - prettier -v
  // The syntax for using prettier is, the write option must be used otherwise the file will not be changed
  - prettier options --write file-name
Prettier can be used with most of the available IDE's
  - If looking at the available options ensure that parser is set to flow not babylon
  - Also the options chosen can be added to package.json eg "format": "prettier options" 
    - This can then be ran with - yarn format

2 - ESLint
Git branches will be available to ensure that all students are at the same point
  - To see which git branches are available -- git remote -vv
  - This can be done with each brnch throughout the course
  - Instructor notes are for Sublime Text
There may be a Yarn Global -add
  - This maybe caused by using nvm to install node
  - Instructor recommends using npm to install globals
Prettier will not recognize syntax faults
  - It will not work unless syntax is correct
To open the teminal in Sublime editor
  - ctrl + ~
The instructor recommends using ESLint
  - The course will use the AirBnB config with Prettier which again is recommended as a combination
Example Syntax
  // Creating the .eslintrc.json file which should be in the project root folder
  // This is where the ESLint configuration rules exist
  {
    // In this case the ordering is important
    "Extends": [
      "airbnb",
      // Prettier invalidates some of the ESlint rules so is pulled in her
      "prettier",
      "prettier/react"
    ],
    "plugins": [
      "prettier"
    ],
    "parserOptions": }
      "ecmaVersion": 2016,
      "sourceType": "module",
      "ecmaFeatures": {
        "jsx": true
      }
    },
    "env": {
      "es6": true,
      "browser": true,
      "node": true
    }
  }

ESLint will need to be installed
  - Due to the Yarn issue it maybe better to use the npm intall
  - npm install -g eslint

At the command prompt
  - eslint **/*.{js,jsx} --quiet
  - This will run the rules defined in the .eslintrc.json file
  - This command can be added to a lint script in the package.json file
  - Quiet is added so there is no failing on warnings

3 - ESLint and SublimeText
Enabling sublime-linter
  - This is a tool is the Sublime text editor
  - It will hightlight code which has an issue
  - This will generate warnings which can be used to improve code quality
  - Anonymous functions will be flagged, they are easier to track on the stack when named if debugging

4 - Webpack and Babel
These can be complicated to use but are very configurable
  - At webpack's most basic it is a packager
  - There are extensive notes on using Webpack at the following url
    - https://github.com/marb61a/Course-Notes/blob/master/Javascript/NodeJS/Webpack 2:The Complete Developer's Guide
  - Then there is Babel which is what actually takes the JSX and outputs JS
    - It works also on ES6 as browsers still do not support features like generators 

5 - Configuring webpack
Example Syntax
  // Reusing the ClientApp.jsx file
  // These modules are static rather than the dynamic common.js approach using require
  // This static approach is good for debugging and code analysis as well as tree shaking unused code
  import React from 'react';
  import { render } from 'react-dom';
  
  // index.html file
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>svideo</title>
    </head>
    <body>
      <div id="app"></div>
      // This is where the budle.js generated by webpack is listed
      // The previously listed script tags can be removed as webpack is already adding them
      <script src="public/bundle.js"></script>
    </body>
  </html>

Although webpack is a complex technology it does not have to be intimidating
  - It can also be fine tuned from the cli

6 - Configuring Babel
Creating a new file in the project root
  .babelrc
Example Syntax
  // .babelrc file
  {
    "presets": [
      "react",
      ["env", {
        "targets": {
          // This targets the latest 2 versions of a browser eg 57 and 58 of Chrome and wiil evolve with new releases
          // This uses a package called compatTable which it reads from
          "browsers": "last 2 versions"
        }
      }]
    ]
  }

7 - Setting Up webpack.config.js File

8 - Running webpack from npm



                    Section 3 - React
1 - JSX

2 - Starting a Web App

3 - Setting up devServer



                    Section 4 - Routing, Props, & State Management
1 - React Router

2 - HashRouter

3 - BrowserRouter

4 - Loading JSON Data

5 - Making a ShowCard Component

6 - PropTypes

7 - Using the Spread Operator in JSX

8 - Key Prop

9 - styled-components

10 - One-Way Data Flow

11 - Q&A: Key and styled-components

12 - Managing State

13 - transform-class-properties

14 - Filtering

15 - Q&A: Nested Arrays, ES6, & More



                    Section 5 -Testing React
1 - Snapshot Testing with Jest

2 - Configuring & Running Jest

3 - Shallow Testing with Enzyme

4 - Testing the Number of ShowCards

5 - Testing the Search Field

6 - Thoughts on Testing

7 - Test Coverage with Istanbul



                    Section 6 - Hot Module Replacement
1 - Introducing Hot Module Replacement
Hot Module Replacement (HMR)
  - This technology works really well with React
  - The way React apps are constructed lends itself to this technology very well
  - Other technologies have problems with detangling to be able to do this
  - Is similar to CSS Live Reload but goes a step further
  - Webpack sees the graph of what is connected to what in an application
  - By understanding the dependency structure of the app, Webpack can replace modules while running

2 - Setting up HMR



                    Section 7 - Flow
1 - Introducing Flow

2 - Setting up Flow

3 - Applying Flow

4 - Defining flow-typed

5 - Fixing flow-typed Definitions



                    Section 8 - Data in React
1 - URL Parameters

2 - Sharing State & Updating the Search Component

3 - Finishing the Details Component

4 - Creating a Header Component

5 - Conditional Display Logic Part 1

6- Conditional Display Logic Part 2

7 - React Lifecycle Methods

8 - componentDidMount() & AJAX Requests

9 - Showcard Link

10 - Wrapper and Q&A

11 - React Development Tools

12 - React Performance Tools

13 - Q&A: Defining Components, & More



                    Section 9 - Redux
1 - Introducing Redux

2 - Setting up Redux

3 - Connect Redux to React

4 - Landing Interact with Store

5 - Dispatching Actions to Redux

6 - Redux Review

7 - Search Submit Event

8 - Using Redux in the Search Component

9 - Using Redux in the Header Component

10 - Q&A: Objects and Props, Dispatch, & More

11 - Q&A: Recap

12 - Refactor Redux for Flow

13 - Refactor Reducers

14 - Redux DevTools

15 - Q&A: Coding Issue, State, & More



                    Section 10 - Async Redux
1 - Middleware & Thunks

2 - Setting Up Middleware & Thunks in Redux

3 - Async Functions

4 - Adding Async Actions to the Details Component

5 - Q&A: Async with Redux



                    Section 11 - Testing Redux
1 - Updating Snapshot
12:39:00 - 12:45:19
Updating Snapshot
Demonstrating that with the introduction of Redux, Brian shows that most of the existing tests in the application fail because Redux is injected into the components. Brian explains how to use “unwrapped” components in the tests that are free of the Redux dependency. Then Brian updates the snapshot to include the new Header component implementation.
Dispatching Actions
12:45:20 - 12:55:27
Dispatching Actions
Next Brian updates the tests to utilize the Redux store and actions. He wraps the Search component in a Provider so it can have access to the store. He also updates the setting of the search term, so it dispatches a Redux action. - https://github.com/btholt/complete-intro-to-react/tree/fem-24
Testing Reducers
12:55:28 - 13:04:05
Testing Reducers
Brian creates a reducers.spec.js file for testing the reducers. Since the Redux developer tools can write the test for you, Brian demonstrates how easy it is to write a test for reducers by creating a couple of tests for the reducers using the Redux developer tools. Brian takes questions from students.
Testing actionCreators
13:04:06 - 13:10:59
Testing actionCreators
By first creating new spec called actionCreators.spec.js, Brian demonstrates how to test actionCreators with snapshots. - https://github.com/btholt/complete-intro-to-react/tree/v3-25
Testing Thunk
13:11:00 - 13:24:12
Testing Thunk
Since handling asynchronous behavior and mock out AJAX requests to test thunks is difficult, Brian introduces moxios, which is a helper for axios in testing. - https://github.com/btholt/complete-intro-to-react/tree/v3-26
Q&A: Tests and Databases
13:24:13 - 13:25:16
Q&A: Tests and Databases
Brian answers questions from students about tests and reading data from databases.
Universal Rendering

Why Use Universal Rendering?
13:25:17 - 13:30:41
Why Use Universal Rendering?
Since the application relies heavily on JavaScript for rendering, the site cannot be seen without JavaScript turned on to view the application. Brian discusses how Universal Rendering can solve this problem making the application more versatile and accessible.
Separating the Client and Server Code
13:30:42 - 13:34:01
Separating the Client and Server Code
For Universal Rendering to work, the application must run both on the server-side and client-side. Brian spends a few minutes separating the client and server aspects of the application with the core logic of the application now residing in an App.jsx file.
Implementing Server-Side Rendering
13:34:02 - 13:46:08
Implementing Server-Side Rendering
To compile the server-side code to CommonJS modules, Brian updates the .babelrc configuration file and then adds the server logic. Brian introduces Express and implements the server-side rendering of the application.
Running the Node Server
13:46:09 - 13:58:03
Running the Node Server
Brian starts the Node web server to run the application showing that the application can render without JavaScript enabled in the browser. Brian takes questions from students. - https://github.com/btholt/complete-intro-to-react/tree/v3-27
Fixing HMR
13:58:04 - 14:05:56
Fixing HMR
With server-side rendering functional, Brian notes that the hot module reload is not working. To address this problem, Brian edits the webpack config to look for the webpack middleware instead of the dev server. Then to make the server work as well, Brian runs the NODE_ENV=server node server.js. Then Brian modifies the dev command in package.json to use the server instead of webpack-dev-server. - https://github.com/btholt/complete-intro-to-react/tree/v3-28
Webpack Code-Splitting and Async Routing

Code Splitting with Webpack
14:05:57 - 14:08:26
Code Splitting with Webpack
Brian introduces a feature of Webpack called code splitting, which gives developers the ability to separate application code into multiple bundles. As a user navigates the application, additional bundles are loaded on-demand.
Async Routing
14:08:27 - 14:17:44
Async Routing
Brian sets up an async route, which is a higher-order component that displays a loading state until a component is completely loaded. Once the targeted component is loaded, the AsyncRoute will remove the loading state and display the component.
Setting Up Import
14:17:45 - 14:19:35
Setting Up Import
To enable Babel, Webpack, and Node to all understand the import(…) syntax, Brian includes a few more plugins in babelrc: one plugin for Babel to understand import at all and a plugin to transform Webpack to know to split.
Creating a Landing Bundle
14:19:36 - 14:27:07
Creating a Landing Bundle
Brian demonstrates how the Landing bundle is only loaded when the user navigates to the Landing page.
Creating Search and Details Bundles
14:27:08 - 14:35:47
Creating Search and Details Bundles
Brian finishes creating the Search and Details code bundles. Brian takes questions from students. - https://github.com/btholt/complete-intro-to-react/tree/v3-29
Building for Production
14:35:48 - 14:51:51
Building for Production
Brian demonstrates how to build the application for production by using the Webpack “-p” flag as well as the Webpack UglifyJs Plugin. To showcase the file savings, Brian compares the production files size with the original application size. - https://github.com/btholt/complete-intro-to-react/tree/v3-30
Preact
14:51:52 - 15:00:29
Preact
Brian introduces Preact, which is a near-drop-in replacement for React with a much smaller footprint. Preact can achieve this smaller size by eliminating some legacy browser support and turning over more work to the browser native APIs. Brian refactors the application to use Preact and compares the size of production to the version that used React. - https://github.com/btholt/complete-intro-to-react/tree/v3-31
Wrapping Up Introduction to React v3

Final Q&A and Wrapping Up
Final Q&A and Wrapping Up
