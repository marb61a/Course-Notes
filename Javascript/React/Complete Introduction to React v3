                    Complete Introduction to React v3
                    Course Notes


                    Section 1 - Introduction
1 - Introduction
Introduction to React course and the agenda. 
  - This is the third version of the course
  - Ensure that you are on the correct version of the course repo
  - There are differences from the first 2 courses covering things like linting and testing etc
A brief bio of the instructor and a quick overview of the syllabus
Mostly you will not use React by itself it will use tools which increase the complexity
  - These are not compulsory eg Using Flow instead of Typescript
Ensure that Node is installed, above 4 is recommended
To get started will need to clone the start repo of the course
  - https://github.com/btholt/complete-intro-to-react/tree/start
A quick run through of the cloned repo
The instructor uses Sublime but it is not compulsory
The dependencies are locked to certain versions to avoid compatability issues

2 - Yarn Dependency Manager
The yarn package manager will be used in the course
Npm has issues which is why Yarn is used
  - Yarn is an npm client
Npm is non-deterministic which can cause deployment issues

3 - Simple React Components
Create a new file in the project created from the cloned GitHub repo
React has 2 different parts to the library
  - Top-level which is the same across the different versions of React
    - It contains the lifecycle methods, create components
  - Between React and what is being rendered too is a glue layer
    - This translates React components to DOM nodes, Native UI elements etc
Example Syntax
  // index.html file
  // The course instructor recommends using Emmet which is a plugin to improve workflow
  // It is available here - https://emmet.io
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>App name</title>
    </head>
    <body>
      <div id="app"></div>
      
      // This pulls in react pre-bundling
      <script src="node_modules/react/dist/react.js"></script>
      <script src="node_modules/react-dom/dist/react-dom.js"></script>
      <script>
        const MyTitle = function(){{
          return(
            React.createElement('div', null, 
              React.createElement('h1', null, "This is my second component")
            )
          )
        }      
      
        const MyFirstComponent = function(){
          return React.createElement('div', null
            React.createElement('h1', null, "This is my first component")
          )
        }
        
        ReactDOM.render(
          React.createElement(MyFirstComponent),
          // Tells where to render which is the div of id 'app'
          document.getElementById("app")
        )
      </script>
    </body>
  </html>

4 - React Paradigm
Being able to create components from components gives the opportunity for powerful patterns
This also allows for reusable components
This differs from Angular or Rails & Django on other languages
MVC may not make sense for interfaces
  - This is why they are put together for components
React component encapsulation helps with debugging
React can be more verbose than Angular but is easier to maintain

5 - Factories & Props
Again using the example code from above
  - It can be verbose writing createElement over and over again
  - There are a lot of React developers that do not know what createElement is
  - This is because they do not have to write it
  - JSX transpiles to createElement calls
  - You do not have to use JSX in apps
    - One example is to set the createElement as a const and use that
    - There are packages like createFactory and react-dom-helpers
Example Syntax
  <script>
    const ce = React.createElement();
    
    const MyTitle = function(props){
    // This needs to be done this way rather than passing in arguments, React actually hooks 
    // into these properties so it knows when to rerender
    // props are synonymous to attributes in html
      return(
        ce('div', null,
          ce('h1', null, {style: {color: props.color}}, props.title)
        )
      )
    }
    
    const MyFirstComponent = function(){
      return ce('div', { id: 'my-first-component '}, 
        ce(MyTitle, {title: 'Game Of Thrones', color: 'YellowGreen'});
        ce(MyTitle, {title: 'Stranger Things', color: 'GreenYellow'});
        ce(MyTitle, {title: 'Rick And Morty', color: 'LimeGreen'});
        ce(MyTitle, {title: 'Silicon Valley', color: 'peru'});
      ) 
    }
  </script>



                    Section 2 -Tools
1 - Prettier
The section starts with creating a new directory and file to put the code from the previous section
  - mkdir js -> ClientApp.jsx
  - The code will then be removed from the script tags
The instructor highly recommends the Prettier tool
  - https://prettier.io
  - It is a code formatting tool which is used by many developers
  - It can clear up some of the issues that occur in code formatting
Example Syntax
  // Using the Yarn package manager
  - yarn global add prettier
  // To check which version is installed
  - prettier -v
  // The syntax for using prettier is, the write option must be used otherwise the file will not be changed
  - prettier options --write file-name
Prettier can be used with most of the available IDE's
  - If looking at the available options ensure that parser is set to flow not babylon
  - Also the options chosen can be added to package.json eg "format": "prettier options" 
    - This can then be ran with - yarn format

2 - ESLint
Git branches will be available to ensure that all students are at the same point
  - To see which git branches are available -- git remote -vv
  - This can be done with each brnch throughout the course
  - Instructor notes are for Sublime Text
There may be a Yarn Global -add
  - This maybe caused by using nvm to install node
  - Instructor recommends using npm to install globals
Prettier will not recognize syntax faults
  - It will not work unless syntax is correct
To open the teminal in Sublime editor
  - ctrl + ~
The instructor recommends using ESLint
  - The course will use the AirBnB config with Prettier which again is recommended as a combination
Example Syntax
  // Creating the .eslintrc.json file which should be in the project root folder
  // This is where the ESLint configuration rules exist
  {
    // In this case the ordering is important
    "Extends": [
      "airbnb",
      // Prettier invalidates some of the ESlint rules so is pulled in her
      "prettier",
      "prettier/react"
    ],
    "plugins": [
      "prettier"
    ],
    "parserOptions": }
      "ecmaVersion": 2016,
      "sourceType": "module",
      "ecmaFeatures": {
        "jsx": true
      }
    },
    "env": {
      "es6": true,
      "browser": true,
      "node": true
    }
  }

ESLint will need to be installed
  - Due to the Yarn issue it maybe better to use the npm intall
  - npm install -g eslint

At the command prompt
  - eslint **/*.{js,jsx} --quiet
  - This will run the rules defined in the .eslintrc.json file
  - This command can be added to a lint script in the package.json file
  - Quiet is added so there is no failing on warnings

3 - ESLint and SublimeText
Enabling sublime-linter
  - This is a tool is the Sublime text editor
  - It will hightlight code which has an issue
  - This will generate warnings which can be used to improve code quality
  - Anonymous functions will be flagged, they are easier to track on the stack when named if debugging

4 - Webpack and Babel
These can be complicated to use but are very configurable
  - At webpack's most basic it is a packager
  - There are extensive notes on using Webpack at the following url
    - https://github.com/marb61a/Course-Notes/blob/master/Javascript/NodeJS/Webpack 2:The Complete Developer's Guide
  - Then there is Babel which is what actually takes the JSX and outputs JS
    - It works also on ES6 as browsers still do not support features like generators 

5 - Configuring webpack
Example Syntax
  // Reusing the ClientApp.jsx file
  // These modules are static rather than the dynamic common.js approach using require
  // This static approach is good for debugging and code analysis as well as tree shaking unused code
  import React from 'react';
  import { render } from 'react-dom';
  
  // index.html file
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8">
      <title>svideo</title>
    </head>
    <body>
      <div id="app"></div>
      // This is where the budle.js generated by webpack is listed
      // The previously listed script tags can be removed as webpack is already adding them
      <script src="public/bundle.js"></script>
    </body>
  </html>

Although webpack is a complex technology it does not have to be intimidating
  - It can also be fine tuned from the cli

6 - Configuring Babel
Creating a new file in the project root
  .babelrc
Example Syntax
  // .babelrc file
  {
    // Presets are groups of plugins
    "presets": [
      "react",
      ["env", {
        "targets": {
          // This targets the latest 2 versions of a browser eg 57 and 58 of Chrome and wiil evolve with new releases
          // This uses a package called compatTable which it reads from
          "browsers": "last 2 versions"
        },
        // This helps deal with edge cases and code size, there is scope for it to cause trouble so it can be set to false
        // the course instructor has not had a problem using true
        "loose": true,
        // This tells babel not to transpile the modules, it was needed in Webpack 1 but not 2
        "modules": false
      }]
    ]
  }

7 - Setting Up webpack.config.js File
This can be done from the command line
Example Syntax
  // Create a file called webpack.config.js
  // This is because Node does not support ES6 modules and therefore uses the common.js approach
  const path = require ('path');
  
  module.exports = {
    context: __dirname,
    entry: "./js/ClientApp.jsx",
    // Source maps are for when transpiling from source code to evaluated code, if surce maps are not available
    // when finding errors they will be shown in bundled code which is not of any use, if source maps are available
    // you will be able to see pre-transpiled code
    devtool: "cheap-eval-source-map",
    output: {
      // Path will resolve relative pathnames
      path: path.join(__dirname, 'public'),
      filename: "bundle.js"
    },
    resolve: {
      // This will check to see files exist in the the order of the extensions
      extensions['.js', '.jsx', '.json']
    },
    stats: {
      colors: true,
      reasons: true,
      chunks: true
    },
    module: {
      // This specifies the rules Webpack will use for module loaders
      rules: [
        {
          test: /\.jsx?$/,
          loader: 'babel-loader'
        }
      ]
    }
  }

To run webpack
  - At the command line webpack
  - Adding tools has helped but adds complexity
  - Source maps will double the size of code

8 - Running webpack from npm



                    Section 3 - React
1 - JSX

2 - Starting a Web App

3 - Setting up devServer



                    Section 4 - Routing, Props, & State Management
1 - React Router

2 - HashRouter

3 - BrowserRouter

4 - Loading JSON Data

5 - Making a ShowCard Component

6 - PropTypes

7 - Using the Spread Operator in JSX

8 - Key Prop

9 - styled-components

10 - One-Way Data Flow

11 - Q&A: Key and styled-components

12 - Managing State

13 - transform-class-properties

14 - Filtering

15 - Q&A: Nested Arrays, ES6, & More



                    Section 5 -Testing React
1 - Snapshot Testing with Jest

2 - Configuring & Running Jest

3 - Shallow Testing with Enzyme

4 - Testing the Number of ShowCards

5 - Testing the Search Field

6 - Thoughts on Testing

7 - Test Coverage with Istanbul



                    Section 6 - Hot Module Replacement
1 - Introducing Hot Module Replacement
Hot Module Replacement (HMR)
  - This technology works really well with React
  - The way React apps are constructed lends itself to this technology very well
  - Other technologies have problems with detangling to be able to do this
  - Is similar to CSS Live Reload but goes a step further
  - Webpack sees the graph of what is connected to what in an application
  - By understanding the dependency structure of the app, Webpack can replace modules while running

2 - Setting up HMR



                    Section 7 - Flow
1 - Introducing Flow

2 - Setting up Flow

3 - Applying Flow

4 - Defining flow-typed

5 - Fixing flow-typed Definitions



                    Section 8 - Data in React
1 - URL Parameters

2 - Sharing State & Updating the Search Component

3 - Finishing the Details Component

4 - Creating a Header Component

5 - Conditional Display Logic Part 1

6- Conditional Display Logic Part 2

7 - React Lifecycle Methods

8 - componentDidMount() & AJAX Requests

9 - Showcard Link

10 - Wrapper and Q&A

11 - React Development Tools

12 - React Performance Tools

13 - Q&A: Defining Components, & More



                    Section 9 - Redux
1 - Introducing Redux

2 - Setting up Redux

3 - Connect Redux to React

4 - Landing Interact with Store

5 - Dispatching Actions to Redux

6 - Redux Review

7 - Search Submit Event

8 - Using Redux in the Search Component

9 - Using Redux in the Header Component

10 - Q&A: Objects and Props, Dispatch, & More

11 - Q&A: Recap

12 - Refactor Redux for Flow

13 - Refactor Reducers

14 - Redux DevTools

15 - Q&A: Coding Issue, State, & More



                    Section 10 - Async Redux
1 - Middleware & Thunks

2 - Setting Up Middleware & Thunks in Redux

3 - Async Functions

4 - Adding Async Actions to the Details Component

5 - Q&A: Async with Redux



                    Section 11 - Testing Redux
1 - Updating Snapshot

2 - Dispatching Actions

3 - Testing Reducers

4 - Testing actionCreators

5 - Testing Thunk

6 - Q&A: Tests and Databases



                    Section 12 - Universal Rendering
1 - Why Use Universal Rendering?

2 - Separating the Client and Server Code

3 - Implementing Server-Side Rendering

4 - Running the Node Server

5 - Fixing HMR



                    Section 13 - Webpack Code-Splitting and Async Routing
1 - Code Splitting with Webpack

2 - Async Routing

3 - Setting Up Import

4 - Creating a Landing Bundle

5 - Creating Search and Details Bundles

6 - Building for Production

7 - Preact



                    Section 14 - Wrapping Up Introduction to React v3
1 - Final Q&A and Wrapping Up
Final Q&A and Wrapping Up
