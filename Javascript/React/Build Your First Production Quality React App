                    Build Your First Production Quality React App
                    Course Notes
The Repo for the course app is available at
  - https://github.com/marb61a/react_todos

                    
1 - Bootstrap A React Application Through The CLI With Create React App
Start by installing the Create React App cli globally
  - npm install -g create-react-app
To create a react project
  - create-react-app .    // This will create an app in the directory you are in which you may not want
This creates a boilerplate app with some npm commands already installed
  - npm start             // Starts the server
  - npm run build         // Bundles the app into static files
  - npm test              // Starts the test runner
  - npm run eject         // Removes this tool, copies dependencies, config files and scripts into app directory. 
                          // This is permanent! so be very careful
The first run message will tell you to edit
  - src/App.js
  - You will also get a not optimised message
Changing the appintro class to say "Hello World"
  - This change is automatically rebuilt
    - This is good for pointing out mistakes as well as improving development time
The entry point for the app is index.js
Use a separate tab to run an initial npm test which will pass if the component is rendering properly
  - These too will reload and run tests added
A single command has set up an entire React Application!!!!

2 - Render A React UI with JSX
The instructor recommends mocking a static version of components you wish to use to make your app with
Remember to use className instead of class as that is a reserved key word is JS
  - Adding new form to accept adding new todos
    - Input type is text
  - Added another div element with unordered list
  - Added some basic css for the input, ul & li elements - App.css
    - You can remove  the bullet points form li elements with a CSS directive
        - list-style-type: none;

3 - Render A React UI Based on Initial State
At this moment the output being rendered is static
  - In order for todos to be rendered dynamically the components must be given state
  - We start by adding a constructor to the app component class
    - Constructors are added using constructor (){}
    - Added at the top of the class
    - Super is use to ensure that the constructor for the class being extended is called
  - Define state for the component
    - this.state = {}
    - The state object will contain whatever data structures our component needs to render properly
    - An array is added each will represent a todo
  - Saving at this stage will not make a visual change as there has be no updating of the render
  - Example uses React Devtools which is an add on for chrome browser and is available from the store
Updating the component to render based on the state rather than the static todos
  - Add this.state.todos to the render method
    - Use curly braces to separate the javascript from the surrounding JSX
  - Use the map() function to return todos
    - Extensive notes on map are available at the following
      - https://github.com/marb61a/Course-Notes/blob/master/Javascript/ES6/ES6 The Complete Developer's Guide
  - The app output will look pretty much the same but this time the output is coming from state
  - There will be warnings about each child in an array or iterator needing a key property
    - This will be fixed by adding a key property to the li and the value to todo.id
  - Adding checked={todo.isComplete} to the li to provide a state for the checkbox
    - This will cause an error as you will need an onChange() handler when using a checked property
    - The quick way of fixing is to change checked to defaultChecked

4 - Synchronize React UI And State With Controlled Components
In React a rendered view should be a function of application state
  - This means that changes in state should be reflected in the view
    - The view and state should be in sync
  - This is also true for changes that come from user input
    - Added currentTodo to the constructor and the state to the input field
    - In order for input to be captured there needs to be an event handler added to the text input field
    - This is then assigned to the currentTodo property
      - A handleInputChange method is added to the app.js to accomplish this
      - The value of the text input will be gotten using evt.target.value
      - New to React people may use this.state.currentTodo to reassign the evt.target.value but this is not correct
      - The setState method of the component is used to pass in a new value (In this case an object)
      - In order for the setState method to update the state there are a couple of things needed
        - Reference it in the constructor and bind it to this 
        - The second task is to set it as the handler for the onChange event
      - If working correctly text entered will be shown as part of state in devtools react section

5 - Create A Stateless Functional Component For An Input Form
Placing the todo form in it's own component
  - Added a new directory and file to the src folder
    -> src -> component -> todo -> TodoForm.js
  - New component will just be a function
  - As it is exported it will need to be imported into the app.js file
    - You will use {TodoForm} as this is the name
  - There will be errors as in react when we need to pass data into a component that is a stateless function component
    it will need to be passed down through props
    - The props will be input into the function
      - It will replace this.state & this 
  - The props will need to be added back to the form which has been added to the app.js page

6 - Refactor React Components To Be Stateless Functional Components
Changing the TodoList in to its own component from being rendered in the main app component
  - A new file will need to be added to the components todo directory -- TodoList.js
  - Again this will be a stateless functional component
  - A new file index.js is created which will hold all imports and export them again
    - This will clean up imports as it will come from a single source
  - Add an instance of the TodoList to ensure that it shows
  - Remove the TodoList from the app.js markup and move it to the TodoList file
    - This will again cause an undefined error
    - Again this.state changes to props
    - A todos attribute will need to be added to app.js to allow the TodoList to be seen
Creating a separate component for an individual todo list item
  - Add a new TodoItem.js file to the components/todo directory
  - Move the li from TodoList to TodoItem
    - Again the todo will need to changed to props in order to be seen
    - Uses the spread operator to get properties rather than todo.id etc
    - Moving the key property to TodoList from TodoItem as there will be a problem iterating

7 - Validate Component Input With Prop Types In React
*****  React.PropTypes is deprecated since React 15.5.0
        -  npm module prop-types
        - To ignore warnings from React about this 
          - Add the following to the line before propTypes // eslint-disable-next-line
React has a method for validating input
  - PropTypes
To use propTypes in a component
  - Call the component and its propTypes property (will be an object)
    - keys should match property names
    // Its important to note that when referencing PropTypes off of React to pick the type for
    // our property that there is an uppercase P at the beginning, where as its lower when defining the object
  - currentTodo: React.PropTypes.string,
  - handleInputChange: React.Proptypes.func
  - To insure that the property is passed in use isRequired()
    - This can be used anywhere if a component needs certain properties
  - Adding PropTypes to TodoList
    -todos:  React.PropTypes.array.isRequired 
  - Adding PropTypes to TodoItem
    - It receives an entire object so there are going to be several properties
    - name: React.PropTypes.string.isRequired
    - isComplete: React.PropTypes.bool
    - id: React.PropTypes.number.isRequired

8 - Add Data To A List Without Mutations
The existing todos have been statically added 
  - This will have to be changed so that new todos can be added dynamically
  - The example will use a helper function to take care of this
    - create-react-app comes with the testing framework Jest built in so the example will be done in TDD format
      - New folder src -> lib
        - New files src -> lib -> todoHelpers.js & todohelpers.test.js
  - npm test starts up jest
    - More information on Jest available at -- https://facebook.github.io/jest/
  - Initial run will fail as each example must contain at least one test
    - Sample test code is added
      - Test will basically have existing todos add a new one and see if the result matches expected
      - Test will have 2 main sections
        - arrange which is where variables etc is called
        - act where the code we are testing is called
  - Next test fail as addTodo has not been defined in the todoHelpers file
  - After adding a blank addTodo function to the helpers file and then exporting it
    - Test fails again but this time because it is expecing array rather than undefined
  - Add list, item as inputs to the function, list will be the needed array and item the object we want to pass in
    - Test passes
  - As list is an array there are array methods such as push() etc available
  - A second test is added to test that the existing todo array should not be mutated
    - Second test fails as the array is mutated
    - Using list.push mutates the existing array
  - Change the array method to concat rather than push 
  - The will add a new item into a new array
    - The second test passes
    - Refactor to use spread operator and the tests still pass

9 - Update React Application State From Form Input
As of now there is no way to submit new todos in the application
  - This is where we will wire up a form for submitting the new todos
  - Add import of todoHelpers to app.js to import addTodo function
  - Add handleSubmit() function to app.js
  - Ensure that you add the handleSubmit property to the todoForm
  - Add the handleSubmit to the todoForm (make sure to use props rather than this!!)
  - Ensure that you add the onSubmit as a propType & it is required
  - The handleSubmit function in add.js
    - It will take an evt 
    - Use preventDefault to prevent the form from submitting the form through a GET
      - This would refresh the page
    - Add a const newTodo which will have a name of currentTodo and a false isComplete value
  - Add a function that will generate a random number for ID's in todoHelpers
    - export const generateId = () => Math.floor(Math.random()*100000);
  - Use the generated id as a key in the handleSubmit function
    - You will then need to add the todo to list of existing todos
    - Then use the updated todos to update the application state
      - This.set state which will take in an object
      - todos: updatedTodos
      - Clear the form input then by setting currentTodos to an empty string
    - You will need to bind the onSubmit mthod in the same way that was done for handleInputChange
      - this.handleSubmit = this.handleSubmit.bind(this);

10 - Prevent Empty Form Values With Conditional Submit Handlers
At present there is nothing in the application to prevent empty values being submitted
  - Even just pressing return will generate nameless todos
  - This means there is a need for form validation
  - At present because we are updating the current todo we know if it is valid before the form is submitted
    - This works to our advantage and avoids the need for conditional code
  - Add a handleEmptySubmit function to the app.js file
    - Remember again to prevent the default behaviour 
    - Add setState and an error message to the state
  - Create a new constant submitHandler in the render method before return
    - const submitHandler = this.state.currentTodo ? this.handleSubmit : this.handleEmptySubmit;
  - Change the handleSubmit value in the todoForm from handleSubmit to submitHandler
  - You will then need to add handleEmptySubmit to the proptypes to ensure correct bindings
  - Inside todoApp div and above the todoForm you will need to enseure that the error message will be shown
    - {this.state.errorMessage && <span className='error'> {this.state.errorMessage} </span> }
  - Edit the error class in the app.css file to make it more prominent
  - Update the setState using errorMessage to use an empty string
    - We need to do this as it will remove the warning message from the app

11 - Use ES2016 Property Initializer Syntax In ES6 Classes
In the app.js component we are using the constructor to define the applications initial state
  - The custom methods are also bound to this using bind
    - This ensures that the methods have correct context when reading state or calling setState for updates
  - These statements are redundant and are easily forgotten
    - Create-react-app ships with appropriate configuration to allow for property initializer syntax
  - Converting the constructor code to property initializers will be the task of the video
    - Start by grabbing the entire initial state object and putting it above the instructor
    - Remove the this from this.state
      - state is now an instance property of the class
    - If you initialise the custom methods as properties then there is no need for binding
      - handleSubmit(evt) becomes handleSubmit = (evt) => {} as it becomes a fat arrow function
      - When these are done the bind statements can be removed
      - The only thing that the constructor should have at this stage is a call to super
    - You will get a warning as the constructor is not doing anything and can be removed

12 - Update Data In A List Without Mutations
In order to update the isComplete status on a todo there are a couple of things that need to be done
  - The todo has to be retrieved from an array of existing todos
  - The second is to toggle the isComplete property on the todo and the list updated
  - There is also a need to avoid mutating the existing object
The instructor has added a list of unit tests which need to be ran
The section will use only 1 of the set of added tests at first
  - In the Jest testing framework you are able to skip tests
  - Add .skip after the test keyword in the helpersSpec file
  - findById will need to be imported
    - Add a findById empty(for the moment) function to the helper file 
      - add list and id as inputs to the findById function
      - Use the built in find method
      - Take in an item from the list and compare the id is equal
        - export const findById = (id, list) => list.find(item => item.id === id);
  - Removed the skip from the toggleTodo should toggle the isComplete prop of a todo test
    - This will just change the isComplete flag from false to true
    - Add toggleTodo to imports
    - Add the toogleTodo export function to the helpers file
      - It takes in a single argument which represents a todo object
        - The spread operator is used to represent todo properties
        - The isComplete is the overwritten by the direct opposite !isComplete
          - export const toggleTodo = (todo) => ({...todo, isComplete: !todo.isComplete });
  - Unskipped the toggleTodo should not mutate the original todo test
    - Ensuring that what we get back from toggleTodo is not a reference to the same todo
  - Unskipping the updateTodo should update an item by id test
    - Takes in a list of todos
    - An updated to do where th isComlete is changed to true
    - We expect to get our list back with the update reflected
    - import updateTodo from the helpers file
  - Unskipping the final test updateTodo should not mutate the original array test
    - This is done to make sure the previous test has not changed the existing array

13 - Pass Data To Event Handlers With Partial Function Application
Handling marking todos as complete in the app
  - findByid, toggleTodo and updatedTodo need to be added to imports in the app.js file
  - Adding a handleToggle function to app.js
    - This is an arrow function which takes the id as an argument
    - For the state updates from this method to actually happen we need to pass it down as a prop to the todoItem component
    - todoItem is a child of todoList
    - Add the handleToggle to the TodoList as part of the render metod in the JSX
    - In the todoList component add props.handleToggle to the todoItem
    - In the TodoItem component the handleToggle will be the onChange event handler
      - This causes an issue as handleToggle will receive an event object by default
      - We need to define an inline function here which calls props.handleToggle
        - We are doing this because we need to pass data into our handler that isn't an event object
        - This is something that happens a lot in React components that deal with collections of data
      - This gets passed in the id from the todo which is todo.id
      - This also means that the defaultChecked property can be changed to checked
    - To do some refactoring
      - We can remove the inline function and assign it to a variable prior to the return
        - This means that we can call the variable in the onChange method
        - We can then go a stage further by removing the function altogether and using bind
          - null will be the first argument as we do not want to reset the context
          - Having the ability to partially apply a function through bind is very useful 
          - This will be used in multiple places in the program so wrapping it in a utility function will help even more
      - Add a new file -> lib -> utils.js
        - also add -> lib -> utils.test.js
      - The test file will import the partial created in the utils file
        - There is also a simple function which takes in 2 numbers and returns their sum
        - The test partially applies the add function with the first value 1
        - Then the inc function is called with 2 and the return value is expected to be 3
      - In the utils file export a constant called partial
        - The error in the test will now be undefined as inc is not being returned yet
        - The first argument is fn representing a function, the second being the rest operator
          - it will be ...args as it will take the rest of a comma separated list of arguments and put them in an array
        - Then call bind on the function and add null to avoid a change of context
        - The arguments from args need to be passed into bind but bind takes arguments as a comma separated list
        - This time we will use the spread operator which looks the exact same as it has the 3 dots
        - A second test is added and takes as 3 arguments and the test passes
          - This means that we can partial apply a function with as many arguments as we want and call it
        - We need to import the util file into the TodoItem file to make use of partial
          - we use partial to remove bind

14. Create a Pipe Function to Enable Function Composition
Looking at the handleToggle method in the app.js file
  - The constants todo and toggled only exist to be passed along to the next line and never used again
  - It would be good practice to get rid of these intermediate values as they are only there until the next line runs
  - This could be resolved very easily by nesting the variable but the code would get messy
  - Ths instructor recommends using a pipe utility
    - This will allow us to take the results of one function and pass it in to the next one
  - The first step is to add some tests to the utils test file to ensure that the pipe utility is working properly
    - Two new functions are added increment & double
      - they take a number in and either double or increment it
    - The two tests ensure that each can be passed to the other and the expected values returned
  - You will also need to add pipe to the import alongside partial
  - Add the export const pipe to the utils function
    - The arguments for pipe are 2 functions f and g
    - This will need to return a function
      - (f, g) => () => {}
    - You will need to use the rest operator as an argument in the returned function
  - Adding a third test to the test file
    - This will be a test to check that the pipe works with more 2 functions
    - On first run this test will fail as it expects 9 but returns 4
    - This is because the existing pipe utility is not working properly and only the first two methods
      passed into the test are assessed and then stopped
  - The existing pipe utility is renamed and in now not exported
  - This is replaced with a new pipe function
    - This new pipe utility will be the one to be exported
    - This will now take in an amount of functions of variable length rather than 2 like previously
    - This takes an array of functions and returns a function
    - The way to do it is to use reduce which uses the old pipe function
      - By using reduce without an initial value, it will take the first 2 items in the functions array
        pass them to _pipe, pipe them together and return a function
      - It will take this value and the next one and do the same as above
      - This goes on for as long as needed
    - At this point all tests pass
  - You will need to import pipe & partial into app.js
  - At this point you will update the handleToggle method
    - You can eliminate some of the code by then using the imported pipe method
    - updateTodo has two arguments so will need to be applied partially
    - updatedTodos can be updated to take in the getUpdatedTodos with id and this.state.todos as arguments
  -

15. Remove Items from a List without Mutations


16. Build a Link Component to Navigate to Routes in React


17. Use React Context to Manage Application State Through Routes


18. Filter Data on Property Values


19. Keep Application State in Sync with Browser History


20. Load Data From a Server with fetch


21. Save Data to the Server with fetch


22. Show Temporary Messages in a React Application


23. Update data on the Server with fetch


24 - Delete Data On The Server With fetch
