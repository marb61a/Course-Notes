                    Redux Once And For All
                    Course Notes

Part 1
The course leans heavily to hands on coding rather than theory
  - There will be brief theoretical explanations of subjects and then hands on
  - There will also be do it yourself exercises and the solutions explained subsequently
  - The instructor recommends using either pair or group coding

Redux
  - This is a state management library
  - It helps ease the complexity of managing state in the application
  - React managing state can be troublesome
    - This can be because of the chain of components which may need props passing multiple levels
  - At its core Redux is only a store
    - A store is similar to a model in the MVC architecture style
    - There is however only 1 store in redux which holds the application state
    - This is a Javascript object
  - Unidirectional data flow is where data flows from parent to child components
    - If any change is made to the state it flows down to the child components
  - Redux expands on this by having a single store which is accessible by all container components
  - Dont be confused by the academic terms used around Redux
  - Stores are immutable (read only)
    - The only part of the application that can change the store state is the store itself
    - It does this by providing a dispatch mechanism
      - Any component that has access to the store can send actions to the store
      - Dispatching actions is just a way of sending meassages
      - After receiving these messages the store can decide whether to change its internal state
      - The store also provides subscription mechanisms so that components can be notified of any changes
  - The store provides 3 API
    - A way for container components to get the state
    - A way for the components to subscribe to state changes
    - It can send messages on whether it will update its internal state or not
  - The example of interacting with your bank account is used to explain Redux
  - Reducer functions are where Redux gets its name
    - Reducer functions are difficult for beginners
    - It is just a way of creating a function that updates or summarises a value
    - It is the same as a reduce operator eg array.reduce
    - Reduce is the most powerful operator in the instructors opinion as it can do everything map etc can do 
    - Reducers like a reduce operator always has access to two values 

Create an Example App
  - Create a new react app using create-react-app
    - It must be installed -> npm install -g create-react-app
  - There are dozens of react bolierplate apps available
  - To create a new barebones example application
    - This works across all platforms
    - create a new folder
    - cd into the new directory
    - create-react-app redux-bank
      - This will create a sample app called redux-bank
    - cd into the redux bank folder and type npm start to start the sample application
      - There will be a default app running on port 3000
      - There will also be basic folders & files created 
      - The app.js file holds the logo etc of the barebones application
  - Because the course is a Redux focused course the components etc will not be handcoded in the course
The link for the sourcecode for the completed example app is available at
  - https://github.com/cassiozen/redux-o4a-bankapp
Example Syntax
  import React, { Component, PropTypes} from 'React';
  import logo from './logo.svg';
  import './App.css';
  
  class App extends Component{
    handleDeposit = () => {
      this.props.onDeposit(this.amount.value);
      this.amount.value = '';
    }
    
    handleWithdraw = (){
      his.props.onWithdraw(this.amount.value);
      this.amount.value = '';
    }
    
    render(){
      return(
        <div>
          <header className="header">
            <img src={logo} width="150" alt="Redux Bank" /><br /> Redux Bank
          </header>
          <br />
          <h1>
            Your balance is ${(this.props.balance).toFixed(2)}
          </h1>
          <div className="atm">
            <input type="text" placeholder="Enter Amount" ref={input => this.amount = input} />
            <br />
            <button onClick={this.handleWithdraw}>Withdraw</button>
            <button onClick={this.handleDeposit}>Deposit</button>
          </div>
          <div className="info">
            <strong>Additional Information</strong>
            <div className="info--visible">
              <p><strong>Your Account Manager</strong>C. F. Frost</p>
              <p><strong>Pre-Approved Credit Limit</strong>$500,000.00</p>
            </div>
          </div>
        </div>
      );
    }
  }
  
  App.propTypes = {
    balance: PropTypes.number,
    onDeposit: PropTypes.func,
    onWithdraw: PropTypes.func
  }



Part 2
Continuing using the example form the previous section
Example Syntax
  - npm install -s redux
    - This will install redux and add the save the entry to the package.json file
// Adding a BankReducer.js file in the src directory
// This application will have only 1 reducer file, larger react based apps will have more
// A reducer is a function that receives state and a dispatched action
  export default(state, action) ={
    // An action is a simple JS object, usually with a type key but could be something else eg name
    // It usually looks something like {type: 'create_account'}
    if(action.type === create_account){
      // This will be the new application state
      return {balance: 0}
    } else if(action.type === deposit){
      // This will use the previous state and update it
      return {balance: state.balance + action.amount}
    } else if (action.type === withdraw){
      return {balance: state.balance - action.amount}
    }    
  }
In larger Redux applications using multiple if else statements for actions may not be practical
  - Instead in that type of application switch is used instead
 // Switch version of the above 
 switch(action.type){
  case create_account:
    return {balance: 0}
  case deposit:
    // To ensure that amount returns a numerical value, it is wrapped in parseFloat
    // State values are immutable
    return {balance: state.balance + parseFloat(action.amount)}
  case withdraw:
    return {balance: state.balance - parseFloat(action.amount)}
  default:
    return state;
 }

To create a store in React you will need to import createStore
Example Syntax
  // Creating a store (there can be more than one in an application)
  // Also the reducer function from  above wiil need to be imported as it is a parameter in the store
  const bankStore = createStore(bankReducer);

Its a good idea to separate Redux from presentational components
Example Syntax
  class AppContainer extends Component {
    // The lifecycle method ensures that the action is dispatched and the store initiated
    componentWillMount(){
      bankStore.dispatch({
        type: 'create_account'
      });
      bankStore.subscribe(() => {
        // This is rarely used to force a component to rerender, it is rarely used because it is not needed much
        this.forceUpdate()
      })
    }
    
    deposit = (amount) => {
      bankStore.dispatch({
        type: 'deposit', amount
      })  
    }
    
    withdraw = (amount) => {
      bankStore.dispatch({
        type: 'withdraw', amount
      })  
    }
    
    render(){
      // This will interact with the store & getState is method provided by Redux
      const storeState = bankStore.getState();
      return(
        <App 
          balance={storeState.balance}
          onDeposit={this.deposit}
          onWithdraw={this.withdraw}
        />
      )
    }
  }
  
  export default AppContainer;
When looking at app dispatch behaviour using logging rather than console.log
It good practice for presentational components not to know about Redux

The above application is fragile
  - Retyping code, redundacy etc will compromise the app durability
Example Syntax
  // Changing the sample application code to be more like redux
  // The INIT action is automatically called by Redux, this mens that there is an initiation action created automatically
    - This means that we can get rid of the create_account dispatch
    - The create_account case from the switch statement will also be removed
  // bankReducer.js
    // The state makes use of ES6  default parameters
    // where the state is undefined is initialises it with a default value
    export default(state = {balance: 0}, action) => {
      switch(action.type){
        case deposit:
          return {balance: state.balance + parseFloat(action.amount)}
        case withdraw:
          return {balance: state.balance - parseFloat(action.amount)}
        default:
          return state;
      }
    }

    // App.js file
    class AppContainer extends Component{
      // This changes from componentWillMount as the state already is initiated
      // this is also the correct way of performing this
      componentDidMount(){
        // In real world applications there is a need to unsubscribe as if there were many different
        // subscriptions there would be a memory leak
        bankStore.subscribe(() => {
          this.forceUpdate();
        })
      }
    }
 
To avoid potential errors due to mistypes etc which may cause silent failures which are very hard to see and debug
  - Redux uses Action Creators
  - An Action Creator is simply a file which generates objects to avoid manual typing when a dispatch is needed
  - In a larger real world application Action Creators would go into their own folders
Example Syntax
  // bankActions.js Action Creator file
  // In JS const values normally use uppercase, using const to replace having to repeatedly type
  // string is good practice as it gets rid of the risk of mistypes
  export const DEPOSIT = 'deposit';
  export const WITHDRAW = 'withdraw';
  
  export const deposit = (amount) => {
    return{type: DEPOSIT, amount}
  }
  
  export const withdraw = (amount) => {
    return{type: WITHDRAW, amount}
  }

Install React-Redux
  - npm install react-redux
  - You will need to import this into your files
    - import { connect } from 'react-redux';
    - Using connect will help avoid having to use containers
    - Connect takes 2 methods mapStateToProps() & mapDispatchToProps

Example Syntax
  // App.js file
  mapStateToProps = (state) => {
    return{
      balance: state.balance
    }
  }
  
  mapDispatchToProps = (dispatch) => {
    return {
      onDeposit: amount => dispatch(deposit(amount)),
      onWithdraw: amount => dispatch(withdraw(amount))
    }
  }
  
  // You will then pass these into connect and the components that you want inject this into
  // You can delete the app container component as this now does that functionality and exports to other components
  export default connect(mapStateToProps, mapDispatchToProps)(app)


Part 3
Reusing the code prior to adding the react-redux connect function
  - Demonstrating immutability
  - The app component is a presentational component which means that it renders markup but is not aware of how data arrives
    - It only expects the data to arrive as props
    - The majority of components will be similiar to this
  - The app container component also renders the props (the balance etc )
  - A run through of what the course has covered this far
  - The connect() function is a curried function
    - A curried function returns a function therefore there are two sets of parentheses
    - Curried functions like other items in React are from functional programming
  - Context is a React mechanism which makes any object available to any component in the hierarchy
    - This is done directly without props
    - You are not supposed to do use this directly
Example Syntax
  // Continuing the Bank Application index.js
  import React from 'react';
  import ReactDom from 'react-dom';
  import { createStore } from 'redux';
  import { provider } from 'react-redux';
  import App from './App';
  import './index.css';
  
  const bankStore = createStore(bankReducer);
  
  ReactDom.render(
    <App />,
    document.getElementByID('root');
  )
  
  

Part 4



Part 5
