                    GraphQL with React: The Complete Developers Guide
                    Course Notes
                    
                    
                    Section 1 - Why GraphQL?
1 - Introduction
Introduction to the course & author
Brief overview of the course agenda
Understanding what problem you are trying to solve helps understand GraphQL
Instructor recommends using Balsamiq for mockup diagrams

2 - Links to Completed Code
A link is provided to the course author github repository
  - https://github.com/StephenGrider/GraphQLCasts



                    Section 2 – A REST-ful Routing Primer
1 - Review of REST-ful Routing
GraphQL and Relay was built to solve a very specific set of problems
Understanding REST and its issues will allow for a better understanding of why GraphQL was developed
REST-ful routing - A set of conventions used in Web Development for manipulating data hosted on a server
They are common rules around HTTP requests and the URL's that are used to send them to, that is used for creating, reading, updating
or deleting data sitting on a server
The most frequently used actions in REST-ful routing are
  - GET - Creates
  - POST - Fetches\Reads
  - PUT - Updates
  - DELETE - Deletes

2 - Shortcomings of RESTful Routing
When nesting URL's REST-ful routing relations can start to break down
Example uses Facebook diagram with 6 users
  - Each user will have
    - Name
    - Profile Image
    - Company Name
    - Position
  - If modelling the data for a database it will be difficult to get a list of all companies and positions
  - Trying to get REST-ful url's for the friends and companies is tough
  - The volume of HTTP requests would be very large
  - Have specific endpoint for a lot of companies can be very painful
  - Other options will break REST-ful conventions
  - REST-ful routing can run into issues when using highly relational data
  - There can also be issues with over-serving data


                    Section 3 – On To GraphQL
1 - What is GraphQL?
REST falls short is some areas
  - URL schemas in heavily nested relationships
  - Too many HTTP requests in heavily nested data
  - Over fetching of data 
  - Solutions to these can be found but maybe time-consuming
GraphQL will provide solutions to these issues
The graph here is a data structure
  - It contains nodes and relationships(called edges)
  - This wont affect how data is stored in the example
You can query the graph using the GraphQL query language
Example Syntax
  // In the example the query is to go from a user to a friend's company's name
  query{
    user(id:"23"){
      friends{
        company{
          name
        }
      }
    }
  }

2 - Working with GraphQL
The example will use 
  - Express JS and GraphQL Server which is the hooked up to a datastore
  - Loadup the prebuilt app into the browser and use it to make some test queries
  - Grapiql is built as a sample app by the GraphQL team
Example Syntax
  - mkdir users
  - cd users
  - npm init  // Accept defaults
  - npm install --save express express-graphql graphql lodash
    - express-graphql is a compatability layer for connecting Express and GraphQl
  - create server.js file
  
  // server.js syntax
  const express = require('express');
  const app = express();
  
  app.listen(4000, () => {
    console.log('listening');
  })

3 - Registering GraphQL with Express
Figuring out how to make express & graphql work well together
When adding in GraphQL you will get an additional step inside the Express server
  - GraphQL will be just one discreet component of the app
Example Syntax
  // server.js syntax
  const express = require('express');
  const expressGraphQL = require('express-graphql');  
  const app = express();
  
  app.use('/graphql', expressGraphQL({
    // graphiql is a tool for development which allows queires to be made against development server
    graphiql: true
  }));
  
  app.listen(4000, () => {
    console.log('listening');
  })

4 - GraphQL Schemas
Error message shows that middleware must have a schema
app.use() is where middleware is wired up in express
The schema will tell GraphQl about the data we are working with and the relationships

5 - Writing a GraphQL Schema
Example Syntax
Some of the syntax may look odd at the beginning but it will become very familiar
Schemas do look the same in most applications
  // schema.js inside the schema folder
  const graphql = require('graphql');
  const {
    GraphQLObjectType,
    GraphQLString,
    GraphQLInt
  } = graphql;
  const UserType = new GraphQLObjectType({
    name: 'User',
    fields : {
      id: {type: GraphQLString},
      firstName: {type: GraphQlString},
      age: {type: GraphQLInt}
    }
  });

6 - Root Queries
Contunuing on from the previous example
A root query is something which allows us to jump in to the graph of data
Example Syntax
  const graphql = require('graphql');
  const {
    GraphQLObjectType,
    GraphQLString,
    GraphQLInt
  } = graphql;
  const UserType = new GraphQLObjectType({
    name: 'User',
    fields : {
      id: {type: GraphQLString},
      firstName: {type: GraphQlString},
      age: {type: GraphQLInt}
    }
  });
  const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields : {
      user: {
        type: UserType,
        args: {id: {type: GraphQlString}},
        resolve(parentValue, args){
        
        }
      }
    }
  });

7 - Resolving with Data
Continuing the previous example
Example Syntax
  const graphql = require('graphql');
  const_ = require('lodash');
  const {
    GraphQLObjectType,
    GraphQLString,
    GraphQLInt,
    GraphQLSchema
  } = graphql;
  
  const users = [
    {id: '23', firstName: 'Bill', age: 20},
    {id: '47', firstName: 'Samantha', age: 21}
  ]
  
  const UserType = new GraphQLObjectType({
    name: 'User',
    fields : {
      id: {type: GraphQLString},
      firstName: {type: GraphQlString},
      age: {type: GraphQLInt}
    }
  });
  
  const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields : {
      user: {
        type: UserType,
        args: {id: {type: GraphQlString}},
        resolve(parentValue, args){
          return _.find(users, {id: args.id});
        }
      }
    }
  });
  
  module.exports = new GraphQLSchema({
    query: RootQuery
  });
  
  // In the server.js file the schema needs to be imported
  const express = require('express');
  const expressGraphQL = require('express-graphql');  
  const schema = require('./schema');
  
  const app = express();
  
  app.use('/graphql', expressGraphQL({
    schema,
    graphiql: true
  }));

8 - The GraphiQL Tool
Grapiql is provided by the graphql-express tool
Quick overview of the GraphiQL environment
More information is available here
  - https://medium.com/the-graphqlhub/graphiql-graphql-s-killer-app-9896242b2125
The most difficult part of GraphQL is writing the schema
  - This accounts for about 50% of the difficulty
  - The second most difficult part is writing queries
Example Syntax
  // Query example
  // Although the code may look like Javascript it is very definitely not JS
  // To run the query on GraphiQL press the play button
  // The elements in the query are changeable
  {
    // If the user does not exist null is returned
    // If no user is provided there will be an error
    user(id: "23"){
      id,
      firstName,
      age
    }
  }

9 - A Realistic Data Source

10 - Async Resolve Functions

11 - Nodemon Hookup

12 - Company Definitions



                    Section 4 - Fetching Data with Queries
1 - Nested Queries

2 - More on Nested Queries

3 - A Quick Breather

4 - Multiple RootQuery Entry Points

5 - Bidirectional Relations

6 - More on Bidirectional Relations

7 - Resolving Circular References

8 - Query Fragments

9 - Introduction to Mutations

10 - NonNull Fields and Mutations

11 - Do It Yourself - Delete Mutation!

12 - Do It Yourself - Edit Mutation!



                    Section 5 - The GraphQL Ecosystem
1 - GraphQL Clients - Apollo vs Relay

2 - Sidenote - Apollo Server vs GraphQL Server



                    Section 6 – Clientside GraphQL
1 - The Next App

2 - Starter Pack Walkthrough

3 - MongoLab Setup

4 - Working Through the Schema

5 - Apollo Client Setup

6 - React Component Design

7 - GQL Queries in React

8 - Bonding Queries with Components



                    Section 7 – Gotchas with Queries in React
1 - Handling Pending Queries

2 - Fixing Key Warnings

3 - Architecture Review

4 - Adding React Router

5 - Creating a Song



                    Section 8 – Frontend Mutations
1 - Mutations in React

2 - Query Params

3 - Defining Query Variables in React

4 - Navigating on Successful Mutation

5 - Troubleshooting List Fetching

6 - Refetching Queries

7 - Deletion by Mutation

8 - Associating Mutations with a Component

9 - Invoking Delete Mutations



                    Section 9 – Automatic Data Caching
1 - Refetching a Query

2 - A Quick CSS Breather

3 - Showing a Particular Song

4 - Fetching Individual Records



                    Section 10 – React Router + GraphQL
1 - Integrating React Router with GraphQL

2 - Watching for Data

3 - Navigating Between Screens

4 - Lyric Creation Form

5 - The CreateLyric Mutation

6 - Submitting Mutations

7 - Showing a List of Lyrics

8 - Enhancing Queries

9 - Identifying Records

10 - Caching with DataIdFromObject

11 - Thumbs Up Icon



                    Section 11 - More on Client Side Mutations
1 - The Like Mutation

2 - Showing Likes with Lyrics

3 - Fetching Likes

4 - Optimistic UI Updates

5 - Handling Optimistic Responses

6 - A Quick Bugfix

7 - Application Wrapup



                    Section 11 - Building From (Mostly) Scratch
1 - App Overview

2 - App Challenges

3 - Boilerplate Setup

4 - Authentication Approach

5 - MLab Setup

6 - The User Type

7 - The Signup Mutation

8 - Delegating to the Auth Service

9 - Testing Signup

10 - The Logout Mutation

11 - The Login Mutation

12 - Checking Authentication Status



                    Section 12 - Moving Client Side
1 - Client Side Setup

2 - Root Routes with React Router

3 - Figuring Out the Current User

4 - Including Cookies with GraphQL Requests

5 - Authentication State

6 - Login and Logout Buttons

7 - Handling the Logout Mutation

8 - Automatic Component Rerenders

9 - Login Form Design

10 - The Auth Form

11 - Importing the Login Mutation

12 - Submitting the Auth Form

13 - Refreshing the Current User

14 - Error Handling with GraphQL

15 - More on Error Handling

16 - The Signup Mutation

17 - More on the Signup Mutation



                    Section 13 - Handling Errors Gracefully
1 - Handling Errors Around Signup

2 - Race Conditions - A Big Gotcha

3 - Finalized Auth Flow

4 - Fixing the Login Process

5 - Fix Signup Too!

6 - The Dashboard Route

7 - The Need for a HOC

8 - Getting Started with RequireAuth

9 - Applying RequireAuth

10 - Fixing RequireAuth

