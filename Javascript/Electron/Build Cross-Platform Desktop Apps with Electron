                    Build Cross-Platform Desktop Apps with Electron
                    Course Notes


                    Section 1 - The Electron Big Picture
1 - Overview
A high level overview of Electron
  - Electron was called atom-shell
  - It is a framework for building cross-platform desktop applications with web technologies
Why would you want to use Electron
  - You want to build an application that has advance permissions like file system access
  - You want to build a small application that lives in the user's menubar or system tray
  - You want to build an application that works well offline
  - You may want to build a gui for a Node application

2 - Technology Benefits
A discussion on the benefits of Electron and the technology under the hood
The Chromium Content Module
  - https://www.chromium.org/developers/content-module
  - These are things that make a browser but not just a Goggle web browser eg HTML rendering
  - Blink is the layout engine for Chrome
  - From the NodeJS part you get filesystem access
Electron gives you everything both a client side and a server side application gets
Electron packages and entire version of Chromium with the app
  - This means that there is no need to worry about vendor prefixes
  - Electron has a fairly modern version of Chromium
  - The need for browser polyfills has be done away with in Electron
Other mainly Chrome API's available for use include
  - HTML Imports, Shadow DOM, Custom Elements, Web Midi API
  - Some of these API are not available in other browsers but because each Electron app has its own Chromium run time
    they are here
Electron application have all the freedoms of any other Node processes
  - This bypasses many of the browser sandbox restrictions
  - There is no compulsory use of Webpack or build tools
  - Using require can get any package from the NPM repo
  - Native modules are available eg SQLite
Electron apps will interact with different OS differently
  - EG Add it to the system tray
  - There is no custom code written as Electron takes care of compatability


                    Section 2 - Getting an Electron Application Up and Running
1 - Structuring an Electron Application
Getting a high level overview of Electron App structure
  - Electron does not have an opinion on file structure
  - There are however some fundamental concepts which should be understood

2 - Coding a Proof of Concept
A sample app is checked out from github
The IDE used is Visual Studio Code
  - The application is question is a sample bookmark app
  - Most of the work in this app will be done in the renderer process
  - The app can use the fetch API & has no CORS troubles
  - main.js and renderer.js are random names for comprehension
Example Syntax
  // package.json file
  "main": "app/main.js",
  "scripts": {
    // Starts electron in the current directory, if you run npm install, npm scripts run a local
    // version of electron not the global
    "start": "electron ."
  }

3 - Bringing in Modules
Example Syntax
  // main.js
  // Press ctrl + c to quit the application and npm start to run it
  // const electron = require('electron');
  
  // Using ES6 destructuring to cut down on code
  const { app, BrowserWindow } = require('electron');
  
  // Showing all the modules available on the object
  console.log(Object.keys(electron));
  
  // The mainWindow is function scoped at this stage which means that it is eligible for garbage collection
  // The below adds it to the global scope
  let mainWindow = null;
  
  app.on('ready', () => {
    // console.log('The application is ready');
    
    // BrowserWindow and renderer processes go hand in hand, a BrowserWindow is the container for the renderer process
    const mainWindow = new BrowserWindow({
      width: 300,
      height: 600,
      show: false
    });
    
    // Helps avoid the flash which happens when starting a new window
    // This is much more akin to native experience
    mainWindow.once('ready-to-show', () => {
      mainWindow.show();
    })
    
    // This will clean up and close when the main window is closed
    mainWindow.on('closed', () => {
      mainWindow = null;
    })
    
    // This will annoy Chrome,
    // BrowserWindow has a lot of properties that can be set
    // Examining the official docs is the place to go to check to see which can be set
    mainWindow.loadURL(`file://${__dirname}/index.html`);
  });
   
  
4 - Rendering Process

5 - Bookmark Application

6 - Shell Module

7 - Debugging Electron

8 - Changing Theme Styles



                    Section 3 - Building a Markdown Text Editor
1 - Rendering Markdown

2 - Setting the OS Font

3 - Opening a File

4 - Filtering File Types



                    Section 4 - Managing Multiple Windows
1 - Reading File Contents

2 - Open File Button

3 - Displaying a File

4 - Refactoring

5 - Multiple Windows

6 - Title Bar

7 - Save Changes

8 - Detecting Change

9 - Additional Visual Cues



                    Section 5 - File Handling
1 - Revert and Save Buttons

2 - Recently Opened Files

3 - Saving Files

4 - Watching Files

5 - Accessing the Operaring System



                      Section 6 - Menu Bar Items
1 - Introducing Menu Bar Items

2 - Building a Menu Bar



                      Section 7 - Menu Bar Applications
1 - Introducing Menu Bar Applications

2 - Code Review of a Menu Bar Application



                      Section 8 - Package an Application for Distribution
1 - Introducing Electron Packager

2 - Packaging an Electron App

3 - Adding an Icon

4 - Code Protection and Performance



                      Section 9 - Wrapping Up
1 - Modules & Libraries

2 - Wrapping Up
A few final words and the course ends
