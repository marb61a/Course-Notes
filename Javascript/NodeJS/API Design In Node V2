                    API Design In Node V2
                    Course Notes
                    
 
1 - 
Introduction to the course
This is the second version of the course
  - There are some changes to the approach used from the first version
  - This is not an advanced version of the course compared to the first version
A brief biography and introduction to the course instructor
What is NodeJS
  - Its a platform built on the Chrome V8 engine
  - It can be used out of the browser to build tooling and network based applications
  - Its maintained by the Nodejs foundation
  - It is more than just Javascript out of the browser

HTTP In Node
  - Node comes with a built in module for creating network based apps
  - It is just a library not a framework
  - You still need to develop abstractions around the http module to build servers

Node Server Frameworks
  - Node has multiple server frameworks
  - Express, Connect, Koa, Hapi & Sails are just a few
  - Express is the defacto framework used by a lot of the community

Why Express?
  - The go-to for creating API's with Node
  - Other frameworks are based off Express
  - Lots of plugins, integrations and resources
  - Easy to use, develop or test

Some of the features of Express
  - Declarative Routing
    - Exact routing, pattern matching, parameter matching
  - Middleware
    - Functions that run serially on requests
  - Powerful response options
    - JSON to static files, Stream, Redirect
  - DB agnostic
  - Highly configuarable and much more

Example Syntax
  // Simplest Example 
  const express = require('express');
  
  // Declare an app from express
  const app = express
  
  // Setup basic routing for the index route
  app.get('/', (req, res) => {
    res.json({ok: true});
  })
  
  // Start the server on a given port
  app.listen(3000, () => {
    console.log('http://localhost:3000');
  })

Example Syntax
  // From the course GitHub repo, src/index.js
  // The course will use webpack for build the example app
  // Also Hot Module Reloading will be used on the server side
  import http from 'http';
  import { createServer } from 'http';
  
  import app from './server';
  let currentApp = app;
  
  if(module.hot){
    module.hot.accept(['./server'], () => {
      server.removeListener('request', currentApp);
      server.on('request', app);
      currentApp = app;
    })
  }

2 -
Continuing to use the example from the previous section
Example Syntax
  import http from 'http';
  import { createServer } from 'http';
  
  import app from './server';
  
  const server = http.createServer(app);
  let currentApp = app;
  
  server.listen(3000, () => {
    console.log("Listening on port 3000");
  })
  
  if(module.hot){
    module.hot.accept(['./server'], () => {
      server.removeListener('request', currentApp);
      server.on('request', app);
      currentApp = app;
    })
  }  
  
  // Server.js file
  import express from 'express';
  import setupMiddleware from './middleware';
  import { restRouter } from './api';
  import { connect } from './db';
  import { signin, protect } from './api/modules/auth';
  
  // Declare an app from express
  const app = express();
  
  setupMiddleware(app);
  connect();
  
  // Setup basic routing for the index route
  app.use('signin', signin);
  
  // Catch all
  // Use all which covers all http verbs
  app.all('*', (req, res) => {
    res.json({ok true});
  });

Hot module reloading
  - stores the update in hot-update.json
  - There are differences with Nodemon which will do a complete reload
    - This means that any state that exists in the app at that point will be gone
    - Using hot reloading will maintain state
  - Hot module reloading is recommended as a work flow
    - It will be removed in production section
  - A module is a closure so it cannot interact with the global space
    - Webpack simulates a module system
    - Module has a hot property on it
    - Webpack.HotModuleReplacementPlugin() is what supplice the parameter to the module global inside of Node
    - It is dependent on Webpack not Node.js
    
Routing With Express
  - Flexible pattern matching
  - Handles parameters
  - Multi router support
  - Both Static and Dynamic configuration
  - There is support for all HTTP verbs (REST)
    - This will be negated when using GraphQL
  - Order based
Example Syntax
  // You can have multiple routers each with their own sets of routes
  // This means that customers, admin, analytics etc can have their own separate API routes
  
  // The usual declaring an app from express
  const app = express();
  
  // This router has nothing to do with the one in app declared above
  // It will have to be used in order to be seen
  const apiRouter = express.Router();

3 -

4 -

5 -

6 -

7 -

8 -

9 -

10 -

11 -

12 -

13 -

14 -

15 -
