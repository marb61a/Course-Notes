                                  Course notes from the awesome Udemy course
                                     Learn and Understand NodeJS by
                                            Anthony Alicea
                                            

                    Section 1 - Introduction and setup
1 - Introduction and course goal
Basic introduction to the course and what the goal of the course is.

2 - Big Words and NodeJS
Learning NodeJS can be intimadting due to some of the terminology involved, the instructor has devised an
excellent strategy for handling this issue which is to specifically address these terms using "Big Word Alerts"
these are then broken down into to simple explanations.

3 - Watching the course
There are different video resolutions available and where possible it should be viewed in the highest 
resolution possible in order to fully observe what the instructor is doing.

4 - Command Line Interface
A basic guide to using the command line, there are huge amounts of indepth tutorials on using the cli
and it is highly recommended to do some learning as these skill are very transferable.

5 - Command Line References
Not necessary for the course to know CLI but if you want to learn
 - http://cli.learncodethehardway.org/book/



                    Section 2 - V8: The Javascript Engine
1 - Conceptual Aside: Processors, Machine Language, and C++
Processors - Processors or CPU (Central Processing Unit)
  - The CPU is often referred to as the brain of the computer
  - Many new computer users may improperly call their computer and sometimes their monitor the CPU
  - Intel and AMD are leading makers of CPU for PC type computers, ARM for devices like phones etc
  - On the PC the main platform is x86 & x64 which take in 32 and 64 pieces of information in parallel

Machine Language - This is a language which a computer can respond to directly
  - Programs written in high-level languages are translated into assembly language or machine language by a compiler
  - Every CPU has its own unique machine language

C++ - The main ISO standard C++ site is located at
  - https://isocpp.org
  - C++ is a general purpose Object-Oriented Language
  - Used extensively in places like Games drivers etc
  - Tutorials on C++ available at
    - https://www.tutorialspoint.com/cplusplus/

2 - Javascript Aside: Javascript Engines and The ECMAScript Specification
Javascript is a trade name
ECMAScript - The standard on which Javascript is based
ECMA is a standards agency - https://www.ecma-international.org
Javascript engines should match ECMA standard
An engine is something that converts JS into machine code

3 - V8 Under the Hood
The v8 engine is an open source JavaScript engine

4 - Adding Features to Javascript



                    Section 3: The Node Core
1 - Conceptual Aside: Servers and Clients
A quick, very high level overview of client - server architecture.
There are explanations of the various architectures used including client - server at
http://tutorials.jenkov.com/software-architecture/client-server-architecture.html

2 - What Does Javascript Need to Manage a Server?

3 - The C++ Core
Lecture begins by looking at the NodeJS source code using Github
There is a quick overview of some of the folders within the NodeJS source code.
There is a lot of C++ code in the src folder

4 - The Javascript Core
Another quick look at the folder structure in the NodeJS souce code but this time looking at the
Javascript end as oppposed to the previous example.

5 - Downloading Lecture Source Code (Article)
Instructions on how to download the source code used in examples

6 - Let's Install and Run Some Javascript in Node




                    Section 4: Modules, Exports, and Require
1 - Conceptual Aside: Modules
Modules are nothing more than blocks of code to be reused, this is a new addition to the
Javascript language. Modules do not affect other code accidently.
CommonJS is basically a set of standards covering how modules should be built.

2 - Javascript Aside: First-Class Functions and Function Expressions
Important part of Javascript and fundamental to how Node works
First Class Functions - Everything that you can do with other types in Javascript you can do with functions. You can use them
like Strings, Numbers etc. A lot of programming languages do not have this feature but Javascript does.
Expression - An expression is a block of code that results in a value. Function Expressions in Javascript are possible because
Functions are first class, because they can have properties and methods just like any other object.
Function Statement - function name(){}
Function Expression - var name = function(){}
Creating Function expressions on the fly is very common

3 - Let's Build a Module
Building a small sample module
Modules help make code much more manageable
Using require import files
File path is passed in as a string
You can expicitly make code available using module.exports

4 - Javascript Aside: Objects and Object Literals

5 - Javascript Aside: Prototypal Inheritance and Function Constructors
Inheritance is when one object gets access to the properties and methods of another object
Javascript implements inheritance differently than other languages, it uses prototypal inheritance
Prototype chain is a sequence of objects connected whose properties can be accessed down the line on any objects
without having to specify which one it is
Full discussion on prototypal inheritance is available here
  - http://javascript.info/prototype-inheritance
JavaScript has a few different ways of creating objects
  - Classes which are used by ES6 and are like blueprints
  - Function Constructors which are normal functions that are used to construct objects. The "this" variable points a new empty 
  object and is returned from the function automatically
__proto__ - shows the prototype object of an object (not recommended for production use)

6 - Javascript Aside: By Reference and By Value
How Javascript behaves when you pass a value to a function, whether you pass an object or a primitive
A primitive is a type of data that represents a single value eg number or string
Javascript uses pass by reference
This affects how require and modules work 

7 - Javascript Aside: Immediately Invoked Function Expressions (IIFEs)
Immediately Invoked Function Expressions are very important to understand how modules work
Scope is where in code you have access to a particular variable or function
IIFEs affect scope
The syntax is to turn a function into an expression 
  (function(){
  }());
This syntax turns the function into a function expression and immediately invokes it hence the name
Has allowed Javascript to approximate modules

8 - How Do Node Modules Really Work?: module.exports and require


9 - Javascript Aside: JSON
JSON is an acronym which stands for JavaScript Object Notation
JSON is a syntax for storing and exchanging data.
JSON is text, written with JavaScript object notation.
When exchanging data between a browser and a server, the data can only be text. JSON is text, and we can convert any 
JavaScript object into JSON, and send JSON to the server. We can also convert any JSON received from the server into JavaScript 
objects. This way we can work with the data as JavaScript objects, with no complicated parsing and translations.

10 - More on require
Require is a Javascript function
Example using stepping into a function
  - Using module.js file
  - http://stackoverflow.com/questions/10638059/javascript-debugging-line-by-line-using-google-chrome
Every module that you create gets an object created to represent it
This has access to a require function
If you have to require a file whose file extension is not js then you have to explicitly declare it as require will
incorrectly assume that the extension is js
Code written by me is wrapped inside a function expression in node and then run
When you create the file it is wrapped in a function which takes 5 parameters
  - exports
  - require
  - module
  - __filename
  - __dirname
This is then ran using an apply function in module.js
.apply is just a way of invoking something in Javascript

11 - Module Patterns
There is no one way to use module patterns it will depend on the architecture
First pattern is
  module.exports = function(){
    console.log('Hello World');
  }
This overwrites the exports empty object with a single function
  module.exports.greet = function(){
    console.log('Hello World');
  }
Normally the above is used as it allows much more explicit requires as it reaches down into the exports file for
a particular method
  var name = require('filepath').greet;
The third pattern replaces exports with own function
  function Greetr(){
      this.greeting = 'Hello World';
      this.greet = function(){
        console.log(this.greeting);
      }
    }
  module.exports = New Greetr;
The next pattern is very popular within javascript
  var greeting = 'Hello World';
  function greet(){
    console.log(greeting);
  }
  module.exports = {
    greet : greet
  }
This is called the revealing module pattern which exposes only the properties and methods you want via a returned object.
Its a very common way to structure code and protect code within modules.

12 - exports vs module.exports
When code is ran through Node it is wrapped in a function expression
Exports in this case is a shorthand for module.exports
It is two variables pointing at the same object
Althought they are both pointing at the same object exports does not work for all patterns seen so far
Syntax of example
  exports = function(){
    console.log('Hello World');
  }
  console.log(exports);
  console.log(module.exports);
The exports returns a function while the module.exports returns the empty object
In another language both would return the same but this is a quirk of Javascript
This is due to the pass by reference, in Javascript when a variable is set equal to a value then its a new spot in memory
In Javascript adding a method or property to an object is called mutating, it means that you have mutated the object
You can use exports if you mutate the object not if you replace the object
Just use module.exports!!

13 - Requiring Native (Core) Modules
The node file looked at is module.js
There is an if statement  which as ks for NativeModule and if it exists
Native Modules are the items seen in the /lib folder
The API documentation is where to find out more 
  - https://nodejs.org/dist/latest-v7.x/docs/api/
Node developers should always read the API documentation!!
You will use require to make modules available
  - Syntax
    var util = require('util');
util.log instead of console.log works similar but adds a time stamp

14 - Modules and ES6
Node JS added the feature of modules to JS as you need modular structure for large scale software
ES6 has now added the concept of modules to JS
ES6 has new syntax eg export or import

15 -Web Server Checklist
A list of things needed by Javascript to manage a server


                    Section 5: Events and the Event Emitter
1 - Conceptual Aside: Events
Events in Node JS are when somethaing has happened in an app that can be responded to.
Many areas of software use the concept of events
In node there are actually 2 types of events
 - System Events -- C++ core libuv
 - Custom Events -- JS Core Event Emitter
Javascript events are faked using the node event emitter
Most core modules are built on top of this

2 - Javascript Aside: Object Properties, First Class Functions, and Arrays
Properties are the most important part of any JavaScript object
Object properties are the values associated with the object
Arrays are collections of values, it is a variable that can hold more than one value at a time
To add a value to an array is to push the values
In JS a function is a block of code designed to perform a particular task
It runs when something calls\invokes it
In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object
Functions can be used the same way as you use variables, in all types of formulas, assignments, and calculations.

3 - The Node Event Emitter - Part 1
Building a sample emitter
Multiple different ways to create
  syntax - function(){
              this.events = {};
            }
            Emitter.prototype.on = function(type, listener){
              this.events[type] = this.events[] || [];
              this.events[type].push(listener);
            }
            Emitter.prototype.emit = function(type){
              if(this.events[type]){
                this.events[type].forEach(function(listener){
                  listener();
                })
              }
            }
            nodule.exports = Emitter;
An event listener is the code that responds to an event
You can have many listeners listening for the same event
Node JS emitter works similarly but is obviously much larger

4 - The Node Event Emitter - Part 2
Looking at the Node Event Emitter
All developers should be familiar with the Node API documentation
  - https://nodejs.org/api/
  - https://nodejs.org/api/events.html
A look through the Node source code specifically the events.js file
  - there is a function called EventEmitter
  - There are many different features
  - There is an emit function on the EventEmitter.prototype
  - Uses .call which is another way to invoke a function
  - Uses an array of functions which are looped through
Magic strings 
  - A string that has sme special meaning in the code
  - Not good because typos can cause bugs and can be very difficult to find with tools
Using Magic Strings in larger applications is not good practice and there are a few ways to avoid it
The example uses another module with configuration values which can replace the Magic Strings
Using properties as variables in place of Magic Strings helps tools and avoids typing bugs

5 - Javascript Aside: Object.create and Prototypes
Helping understand why the event emitter is a fndamental part of Node
Every object has a prototype
Class uses the extends keyword to implement inheritance
Example Syntax
  var person = {
    firstname : '',
    lastname : '',
    greet : function(){
      return this.firstname + ' ' + this.lastname;
    }
  }
  // This object will point to person as its prototype
  var john = Object.create(person);
  john.firstname = 'John';
  john.lastname = 'Doe';

Object.create is a very clean way to set up inheritance

6 - Inheriting From the Event Emitter
A lot of core modules inside Node inherit from the Event Emitter
Multiple different ways of setting up inheritance\prototype chain
Using util.js
  - Contains inherits function which takes 2 constructors -- ctor & superCtor
  - First is a constructor upon which you want to add new methods and properties
  - Second is where the methods and properties you want
Creates a brand new prototype chain by placing a prototype between 2 objects
Syntax
  var EventEmitter = require('events');
  var util = require('util');
  function Greetr(){
    this.greeting = 'Hello World';
  }
  util.inherits(Greetr, EventEmitter);
  Greetr.prototype.greet = function(){
    console.log(this.greeting);
    this.emit('greet');
  }
  var greetr1 = new Greetr();
  greetr1.on('greet', function(){
    console.log('Someone greeted!!');
  });
  greetr1.greet();

7 - Javascript Aside: Node, ES6, and Template Literals
New version of JS is called ECMAScript 2015/ES6
ES6 contains new feature to make writing JS code easier
Not every browser will support it
You may not be able to use the latest version of Node JS
Dont't mix JS versions
BabelJS allows you to write ES6 as it converts code to older JS
Example uses Visual Studio Code IDE and has its own settings
  - You may need jsconfig.json file to use with VS Code
Template Literal - This is a way to concatenate strings in ES6, it can be easier to work with than using + to 
concatenate a bunch of strings
Template literals use back ticks
  Syntax -
    var name = "John Doe";
    // Old style JS
    var greet = "Hello " + name;
    // ES6 Template literal style
    var greet2 = `Hello ${name}`;
Template literals are a lot quicker

8 - Javascript Aside: .call and .apply
.call and .apply can be used for invoking functions
Syntax
  var obj = {
    name: 'John Doe'.
    greet : function(){
    \\ES6 backticks template literal
      console.log(`Hello ${ this. name }`);
    }
  }
  obj.greet();y
  // Variable passed to call is what the this keyword will point to
  obj.greet.call({name : 'Jane Doe' });
  // The difference between call and apply is if you were passing in parameters to greet function in call they would
  // be sequential, one after the other, in apply they would be an array
  obj.greet.appl({name : 'Jane Doe' });
Using .call and .apply can be very powerful methods for borrowing methods

9 - Inheriting From the Event Emitter - Part 2
Adding one more line to complete patterns for inheriting
Reusing the previously made greetr function
Inside the constructor there can be added methods and properties directly on to the object being created
What if the event emitter adds properties and methods on to the object
Syntax
  function Greetr(){
    //New line added
    // It is equivalent to what in languages like Java etc would call the Super Constructor
    EventEmitter.call(this);
    this.greeting = 'Hello World';
  }
Second example Syntax
  var util = require('util');

  function Person(){
    this.firstname = 'John';
    this.lastname = 'Doe';
  }

  Person.prototype.greet = function(){
    console.log('Hello ' + this.firstname + ' ' + this.lastname );
  }

  function Policeman(){
    Person.call(this);
    this.badgenumber = '1234'
  }
  
  util.inherits(Policerman, Person);
  var officer = new Policeman();
  officer.greet();

10 - Javascript Aside: ES6 Classes
A new way to build objects which may make it easier
Because it does not change anything behind the scenes it is called Syntactic Sugar
Syntactic Sugar is a feature that changes only how you type something but does not change under the hood
  - Remeber that it is important to understand what is going on under the hood to avoid flawed assumptions
Reusing the sample code from above
You will need to add a line to the top of the file
  - 'use strict' -- this helps avoid mistakes and is recommended to be used, some packages may require using strict to operate
Syntax
  class Person{
    constructor (firstname, lastname){
      this.firstname = firstname;
      this.lastname = lastname;
    }
  }
This replaces the previously written code using function Person
It is still just setting up the prototype chain
Classes in JS are much different than classes in languages like Java or C#

11 - Inheriting From the Event Emitter - Part 3
Updating the previous event emitter example to use ES6 classes
Using strict will cause more errors as it will not allow certain things
To call parent of constructor just use super()



                    Section 6: Asynchronous Code, libuv, The Event Loop, Streams, Files, and more…
1 - Javascript Aside: Javascript is Synchronous
Asynchronous means that more than 1 process is running simultaneously
Node does things asynchronously, V8 does not
Synchronous means one thing running at a time
JS is synchronous

2 - Conceptual Aside: Callbacks
Callbacks are functions passed to another function which we assume will be invoked at some time

3 - libuv, The Event Loop, and Non-Blocking Asynchronous Execution
Libuv is C++ System Events
Libuv handles OS events
Callbacks similar in concept to event listeners
Non-blocking in this case means that you can do things without stopping your program running
Non-blocking is made possible by Node doing things Asynchronously
Node has eased difficulties in running code asynchronously
Libuv - https://libuv.org

4 - Conceptual Aside: Streams and Buffers
Buffer - A buffer is a temporary holding spot for moving data from one location to another, it is intentionally
limited in its size
Stream  - A stream is a sequence of data made available over time, usually pieces of data that combine into a
whole.
Streams and buffers work in combination a lot of the time

5 - Conceptual Aside: Binary Data, Character Sets, and Encodings
Binary - Either 0 or 1
Known as base 2 because there are only the 2 digits
There are multiple tutorials on Binary available 
  - https://www.tutorialspoint.com/computer_logical_organization/binary_codes.htm
Character sets are representations of characters as numbers
  - Unicode -- https://unicode-table.com/en/
  - ASCII -- http://www.asciitable.com
Character encoding is how characters are stored in binary, code points or the numbers are converted and stored in Binary
  - One example is UTF-8 -- http://www.utf8-chartable.de
Javascript is not good at encoding so V8 has some mechanisms to help

6 - Buffers
Using buffers in Node
Node has built in buffer object, it is on the c++ side of things
Buffer Methods available at
  - https://nodejs.org/api/buffer.html
The Buffer class was introduced as part of the Node.js API to make it possible to interact with octet streams
The buffer holds raw 1's and 0's
Example Syntax
  - var buf = New Buffer('Hello', 'UTF-8');
    console.log(buf);
    console.log(buf.toString());
    console.log(toJSON());

You do not need to require Buffer
UTF-8 is the default encoding for Buffer
Running will output in Hex

7 - ES6 Typed Arrays
Not used in the rest of the course but good to learn
Typed arrays were introduced into ES6 to allow Javascript deal with binary data
Not part of V8 but Javascript itself
Example Syntax
  - var buffer = New ArrayBuffer
    var view = New Int32Array(buffer);
    
    view[0] = 5;
    view[1] = 15;
    console.log(view);

8 - Javascript Aside: Callbacks
The definition of a callback is done earlier
  - Callbacks are functions passed to another function which we assume will be invoked at some time
Syntax
  function greet(callback){
    console.log('Hello');
    var data = {
      name : 'John Doe'
    }
    callback(data);
  }
  greet(function(data){
    console.log('The callback was invoked');
    console.log(data);
  })
  greet(function(data){
    console.log('A different callback was invoked');
    console.log(data.name);
  })

9 - Files and fs

10 - Streams

11 - Conceptual Aside: Pipes

12 - Pipes

13 - Web Server Checklist
A list of things needed by Javascript to manage a server



                    Section 7: HTTP and being a Web Server
1 - Conceptual Aside: TCP/IP
A quick overview of TCP\IP, there is a much more indepth tutorial available at the following address
http://www.w3schools.com/website/web_tcpip.asp

2 - Conceptual Aside: Addresses and Ports
A quick overview of IP Addresses and Ports which handle the various protocols. There are 2 different types of IP addresses
there are tutorials much more indepth at the following locations
http://www.tutorialspoint.com/ipv4/index.htm
http://www.tutorialspoint.com/ipv6/index.htm

3 - Conceptual Aside: HTTP
HTTP is an acronym that stands for  Hypertext Transfer Protocol
It is essentially a set of rules for transferring data across the web
It is a format defining data transferred via HTTP
There are many different status codes for HTTP which operates via a request - response mechanism
The list of codes is available here
  - https://github.com/marb61a/Course-Notes/blob/master/Marketing/http%20status%20codes
MIME - This is a type which is a standard for defining the type od data being sent is 
MIME is an acronym that stands for - Multipurpose Internet Mail Extensions
The list of different MIME types is available here
  - https://www.sitepoint.com/web-foundations/mime-types-complete-list/

4 - http_parser
The Node JS parser code is located at 
  - https://github.com/nodejs/http-parser
A quick run through of the http_parser package
The http_parser breaks up the requests and responses into the proper format

5 - Let's Build a Web Server in Node

6 - Outputting HTML and Templates

7 - Streams and Performance
Using streams to improve performance
Using createReadStream method from fs
Create a readable file stream and then pipe it to stream
  - fs.createReadStream(_dirname + "/index.html").pipe(res)
This will take chunks of a file instead of waiting for a full file
This will improve performance levels and streams are fundamental to how the internet works anyway

8 - Conceptual Aside: APIs and Endpoints
API -- This is an acronym that stands for Application Programming Interface
It is a set of tools used to build a software application
On the internet these are made available via a set of URL's which accept and send only data via HTTP and TCP\IP
Endpoint - An Endpoint is one url in a web api
Sometimes that endpoint does multiple things by making choices based on the HTTP request headers

9 - Outputting JSON
Mime type = application/json
JSON similar to object literal syntax
You can use JSON.stringify(string) -- this will create a string in the JSON format
Serialize - Translating an object into a form that can be stored or transferred
CSV, XML and JSON are popular formats
DeSerialize is the opposite

10 - Routing

11 - Web Server Checklist



                    Section 8: NPM: the Node Package Manager
1 - Conceptual Aside: Packages and Package Managers

2 - Conceptual Aside: Semantic Versioning (semver)
Versioning - Specifying the version of a set of code
Semantic - Implies that there is something conveys meaning
Looking at a version number should convey a meaning
In Node version numbers should go Major.Minor.Patch eg 1.7.10 
 - Small patches eg bugfixes would become 1.7.11
 - Minor feature additions 1.8.11
 - Big changes 2.0.0 (will probably cause breakages)
Semantic Versioning - http://semver.org

3 - npm and the npm registry: Other People's Code
NPM - Node Package Manager
Install -- npm install
Check version installed -- npm -v
https://www.npmjs.com - Package repositories
Be very careful about packages you install

4 - init, nodemon, and package.json
Installation of Moment JS which is a JS library for dates times etc
  - https://momentjs.com
npm init - This is used to generate the npm package manager
The package.json file is created by npm init which contains the settings of your app
You can use npm to install packages
  - npm install moment --save 
  - using save saves it to drive and also writes an entry into package.json
  - Creates a node_modules folder to hold your installed packages
  - Not just used for Node apps
In package.json
  - ^ in a package means that it is alright to update to anything within the major packages eg 2.10.7 could be 2.11.8 but not 3
  - ~ means to only update patches
  - Having package.json means that you can share with people
  - You dont share node_modules folder
  
5 - npm Global Installation (Article)
You may run across permission issues on Mac or Linux. If that happens to you, here's a helpful link directly from npm's website:
  - https://docs.npmjs.com/getting-started/fixing-npm-permissions

6 - init, nodemon, and package.json - Part 2
npm install - this will install dependencies listed in package.json
Dev dependencies are dependencies needed for development
Example package for dev-dependencies is jasmine-node
  - https://www.npmjs.com/package/jasmine
  - npm install jasmine-node --save-dev // will save to dev-dependencies section of the package.json
  - Jasmine has its own node_modules folder for dependencies as does some of these dependencies
Dev-dependencies are not needed for the app to run
To install globally(available anywhere)
  - npm install -g
  - You may need permissions on *nix based systems
  - Various places for global modules to be stored
Nodemon is a utility that will monitor for any changes in your code and restarts the server
  - https://nodemon.io
  - Nodemon has its own node_modules folder
  - Nodemon has its own CLI utility
  - nodemon "entrypoint" eg nodemon server.js
Because of the amount of dependencies there can be a lot of bloat
To update installed packeages
  - npm update

7 - Using Other People's Code
Using npm is using other peoples code
Research properly
  - See how popular the package is
  - Check Github for issues
  - Test well
  - Proper semantic versioning may not be used


                    Section 9: Express
1 - Installing Express and Making it Easier to Build a Web Server

2 - Routes

3 - Static Files and Middleware

4 - Templates and Template Engines

5 - Querystring and Post Parameters

6 - RESTful APIs and JSON

7 - Structuring an App



                    Section 10: Javascript, JSON, and Databases
1 - Conceptual Aside: Relational Databases and SQL
Relational Databases
  - Typically a table with rows and columns
  - Not all data is put in one table
  - Avoid repeating yourself by breaking the information up as much as possible
SQL - Structured Query Language
  - Asks questions or queries of the database

2 - Node and MySQL
MySQL has a package on the npm registry
  - npm install mysql
Try use the most used package for the database you are using
Using MYSQL Workbench
  - https://www.mysql.com/products/workbench/
Tutorial on Node & MySQL
  - https://codeforgeek.com/2015/01/nodejs-mysql-tutorial/

3 - Conceptual Aside: NoSQL and Documents
NoSQL - Covers a variety of technologies
One type is a document DB - MongoDB is one of those
There are no tables
MongoDB uses JSON like documents
Changing technologies has superseeded the reason for using SQL in some cases

4 - MongoDB and Mongoose
Available here - https://www.mongodb.com
  - Install instructions available for installation on various platforms
Mongoose NPM package - http://mongoosejs.com
  - npm install mongoose
Cloud based service - https://mlab.com -- Free tier available
  - Demo of using Mongolab
    - Gives you a url to connect to

MongoDB uses a format called BSON (Binary JSON) which is a binary-encoded serialization of JSON-like documents
Full set of notes available on MongoDB available at 
  - Quick basic introduction to the material that will be covered by the section

5 - Web Server Checklist
Ability to work with databases



                  Section 11: The MEAN stack
Extensive notes covering these topics are available at 
  - https://github.com/marb61a/Course-Notes/tree/master/Javascript
  - https://github.com/marb61a/Course-Notes/tree/master/Databases/MongoDB
1 - MongoDB, Express, AngularJS, and NodeJS
2 - AngularJS: Managing the Client
3 - AngularJS: Managing the Client (Part 2)
4 - AngularJS: Managing the Client (Part 3)
5 - Conceptual Aside: Angular 1, Angular 2, React, and more…
6 - Working with The Full Stack (and being a Full Stack Developer) - Part 1



                    Section 12: Let's Build an App! (in record time)
A very basic app is built to demonstrate the concepts from the course

1 - NodeTodo: Software Requirements
A basic run through of what the project will require
2 - Initial Setup
3 - Setting up Mongo and Mongoose
4 - Adding Seed Data
5 - Creating our API
6 - Testing our API
7 - Future Lectures  (Article)
