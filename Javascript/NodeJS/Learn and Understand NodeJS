                                  Course notes from the awesome Udemy course
                                     Learn and Understand NodeJS by
                                            Anthony Alicea
                                            

                    Section 1 - Introduction and setup
1 - Introduction and course goal
Basic introduction to the course and what the goal of the course is.

2 - Big Words and NodeJS
Learning NodeJS can be intimadting due to some of the terminology involved, the instructor has devised an
excellent strategy for handling this issue which is to specifically address these terms using "Big Word Alerts"
these are then broken down into to simple explanations.

3 - Watching the course
There are different video resolutions available and where possible it should be viewed in the highest 
resolution possible in order to fully observe what the instructor is doing.

4 - Command Line Interface
A basic guide to using the command line, there are huge amounts of indepth tutorials on using the cli
and it is highly recommended to do some learning as these skill are very transferable.

5 - Command Line References
Not necessary for the course to know CLI but if you want to learn
 - http://cli.learncodethehardway.org/book/



                    Section 2 - V8: The Javascript Engine
1 - Conceptual Aside: Processors, Machine Language, and C++
Processors 

2 - Javascript Aside: Javascript Engines and The ECMAScript Specification
Javascript is a trade name
ECMAScript - The standard on which Javascript is based
ECMA is a standards agency - https://www.ecma-international.org
Javascript engines should match ECMA standard
An engine is something that converts JS into machine code

3 - V8 Under the Hood
The v8 engine is an open source JavaScript engine

4 - Adding Features to Javascript



                    Section 3: The Node Core
1 - Conceptual Aside: Servers and Clients
A quick, very high level overview of client - server architecture.
There are explanations of the various architectures used including client - server at
http://tutorials.jenkov.com/software-architecture/client-server-architecture.html

2 - What Does Javascript Need to Manage a Server?

3 - The C++ Core
Lecture begins by looking at the NodeJS source code using Github
There is a quick overview of some of the folders within the NodeJS source code.
There is a lot of C++ code in the src folder

4 - The Javascript Core
Another quick look at the folder structure in the NodeJS souce code but this time looking at the
Javascript end as oppposed to the previous example.

5 - Downloading Lecture Source Code (Article)
Instructions on how to download the source code used in examples

6 - Let's Install and Run Some Javascript in Node




                    Section 4: Modules, Exports, and Require
1 - Conceptual Aside: Modules
Modules are nothing more than blocks of code to be reused, this is a new addition to the
Javascript language. Modules do not affect other code accidently.
CommonJS is basically a set of standards covering how modules should be built.

2 - Javascript Aside: First-Class Functions and Function Expressions
Important part of Javascript and fundamental to how Node works
First Class Functions - Everything that you can do with other types in Javascript you can do with functions. You can use them
like Strings, Numbers etc. A lot of programming languages do not have this feature but Javascript does.
Expression - An expression is a block of code that results in a value. Function Expressions in Javascript are possible because
Functions are first class, because they can have properties and methods just like any other object.
Function Statement - function name(){}
Function Expression - var name = function(){}
Creating Function expressions on the fly is very common

3 - Let's Build a Module
Building a small sample module
Modules help make code much more manageable
Using require import files
File path is passed in as a string
You can expicitly make code available using module.exports

4 - Javascript Aside: Objects and Object Literals

5 - Javascript Aside: Prototypal Inheritance and Function Constructors
Inheritance is when one object gets access to the properties and methods of another object
Javascript implements inheritance differently than other languages, it uses prototypal inheritance
Prototype chain is a sequence of objects connected whose properties can be accessed down the line on any objects
without having to specify which one it is
Full discussion on prototypal inheritance is available here
  - http://javascript.info/prototype-inheritance
JavaScript has a few different ways of creating objects
  - Classes which are used by ES6 and are like blueprints
  - Function Constructors which are normal functions that are used to construct objects. The "this" variable points a new empty 
  object and is returned from the function automatically
__proto__ - shows the prototype object of an object (not recommended for production use)

6 - Javascript Aside: By Reference and By Value
How Javascript behaves when you pass a value to a function, whether you pass an object or a primitive
A primitive is a type of data that represents a single value eg number or string
Javascript uses pass by reference
This affects how require and modules work 

7 - Javascript Aside: Immediately Invoked Function Expressions (IIFEs)
Immediately Invoked Function Expressions are very important to understand how modules work
Scope is where in code you have access to a particular variable or function
IIFEs affect scope
The syntax is to turn a function into an expression 
  (function(){
  }());
This syntax turns the function into a function expression and immediately invokes it hence the name
Has allowed Javascript to approximate modules

8 - How Do Node Modules Really Work?: module.exports and require


9 - Javascript Aside: JSON
JSON is an acronym which stands for JavaScript Object Notation
JSON is a syntax for storing and exchanging data.
JSON is text, written with JavaScript object notation.
When exchanging data between a browser and a server, the data can only be text. JSON is text, and we can convert any 
JavaScript object into JSON, and send JSON to the server. We can also convert any JSON received from the server into JavaScript 
objects. This way we can work with the data as JavaScript objects, with no complicated parsing and translations.

10 - More on require
Require is a Javascript function
Example using stepping into a function
  - Using module.js file
  - http://stackoverflow.com/questions/10638059/javascript-debugging-line-by-line-using-google-chrome
Every module that you create gets an object created to represent it
This has access to a require function
If you have to require a file whose file extension is not js then you have to explicitly declare it as require will
incorrectly assume that the extension is js
Code written by me is wrapped inside a function expression in node and then run
When you create the file it is wrapped in a function which takes 5 parameters
  - exports
  - require
  - module
  - __filename
  - __dirname
This is then ran using an apply function in module.js
.apply is just a way of invoking something in Javascript

11 - Module Patterns
There is no one way to use module patterns it will depend on the architecture
First pattern is
  module.exports = function(){
    console.log('Hello World');
  }
This overwrites the exports empty object with a single function
  module.exports.greet = function(){
    console.log('Hello World');
  }
Normally the above is used as it allows much more explicit requires as it reaches down into the exports file for
a particular method
  var name = require('filepath').greet;
The third pattern replaces exports with own function
  function Greetr(){
      this.greeting = 'Hello World';
      this.greet = function(){
        console.log(this.greeting);
      }
    }
  module.exports = New Greetr;
The next pattern is very popular within javascript
  var greeting = 'Hello World';
  function greet(){
    console.log(greeting);
  }
  module.exports = {
    greet : greet
  }
This is called the revealing module pattern which exposes only the properties and methods you want via a returned object.
Its a very common way to structure code and protect code within modules.

12 - exports vs module.exports

13 - Requiring Native (Core) Modules

14 - Modules and ES6
Node JS added the feature of modules to JS as you need modular structure for large scale software
ES6 has now added the concept of modules to JS
ES6 has new syntax eg export or import

15 -Web Server Checklist



                    Section 5: Events and the Event Emitter
1 - Conceptual Aside: Events
Events in Node JS are when somethaing has happened in an app that can be responded to.
Many areas of software use the concept of events
In node there are actually 2 types of events
 - System Events -- C++ core libuv
 - Custom Events -- JS Core Event Emitter
Javascript events are faked using the node event emitter
Most core modules are built on top of this

2 - Javascript Aside: Object Properties, First Class Functions, and Arrays
Properties are the most important part of any JavaScript object
Object properties are the values associated with the object
Arrays are collections of values, it is a variable that can hold more than one value at a time
To add a value to an array is to push the values
In JS a function is a block of code designed to perform a particular task
It runs when something calls\invokes it
In JavaScript, functions are first-class objects, because they can have properties and methods just like any other object
Functions can be used the same way as you use variables, in all types of formulas, assignments, and calculations.

3 - The Node Event Emitter - Part 1
Building a sample emitter
Multiple different ways to create
  syntax - function(){
              this.events = {};
            }
            Emitter.prototype.on = function(type, listener){
              this.events[type] = this.events[] || [];
              this.events[type].push(listener);
            }
            Emitter.prototype.emit = function(type){
              if(this.events[type]){
                this.events[type].forEach(function(listener){
                  listener();
                })
              }
            }
            nodule.exports = Emitter;
An event listener is the code that responds to an event
You can have many listeners listening for the same event
Node JS emitter works similarly but is obviously much larger

4 - The Node Event Emitter - Part 2
Looking at the Node Event Emitter
All developers should be familiar with the Node API documentation
  - https://nodejs.org/api/
  - https://nodejs.org/api/events.html
A look through the Node source code specifically the events.js file
  - there is a function called EventEmitter
  - There are many different features
  - There is an emit function on the EventEmitter.prototype
  - Uses .call which is another way to invoke a function
  - Uses an array of functions which are looped through
Magic strings 
  - A string that has sme special meaning in the code
  - Not good because typos can cause bugs and can be very difficult to find with tools
Using Magic Strings in larger applications is not good practice and there are a few ways to avoid it
The example uses another module with configuration values which can replace the Magic Strings
Using properties as variables in place of Magic Strings helps tools and avoids typing bugs

5 - Javascript Aside: Object.create and Prototypes

6 - Inheriting From the Event Emitter

7 - Javascript Aside: Node, ES6, and Template Literals
New version of JS is called ECMAScript 2015/ES6
ES6 contains new feature to make writing JS code easier
Not every browser will support it
You may not be able to use the latest version of Node JS
Dont't mix JS versions
BabelJS allows you to write ES6 as it converts code to older JS
Example uses Visual Studio Code IDE and has its own settings
  - You may need jsconfig.json file to use with VS Code
Template Literal - This is a way to concatenate strings in ES6, it can be easier to work with than using + to 
concatenate a bunch of strings
Template literals use back ticks
  Syntax -
    var name = "John Doe";
    // Old style JS
    var greet = "Hello " + name;
    // ES6 Template literal style
    var greet2 = `Hello ${name}`;
Template literals are a lot quicker

8 - Javascript Aside: .call and .apply

9 - Inheriting From the Event Emitter - Part 2

10 - Javascript Aside: ES6 Classes

11 - Inheriting From the Event Emitter - Part 3



                    Section 6: Asynchronous Code, libuv, The Event Loop, Streams, Files, and more…
1 - Javascript Aside: Javascript is Synchronous
Asynchronous means that more than 1 process is running simultaneously
Node does things asynchronously, V8 does not
Synchronous means one thing running at a time
JS is synchronous

2 - Conceptual Aside: Callbacks
Callbacks are functions passed to another function which we assume will be invoked at some time

3 - libuv, The Event Loop, and Non-Blocking Asynchronous Execution
Libuv is C++ System Events
Libuv handles OS events
Callbacks similar in concept to event listeners
Non-blocking in this case means that you can do things without stopping your program running
Non-blocking is made possible by Node doing things Asynchronously
Node has eased difficulties in running code asynchronously
Libuv - https://libuv.org

4 - Conceptual Aside: Streams and Buffers
Buffer - A buffer is a temporary holding spot for moving data from one location to another, it is intentionally
limited in its size
Stream  - A stream is a sequence of data made available over time, usually pieces of data that combine into a
whole.
Streams and buffers work in combination a lot of the time

5 - Conceptual Aside: Binary Data, Character Sets, and Encodings
Binary - Either 0 or 1
Known as base 2 because there are only the 2 digits
There are multiple tutorials on Binary available 
  - https://www.tutorialspoint.com/computer_logical_organization/binary_codes.htm
Character sets are representations of characters as numbers
  - Unicode -- https://unicode-table.com/en/
  - ASCII -- http://www.asciitable.com
Character encoding is how characters are stored in binary, code points or the numbers are converted and stored in Binary
  - One example is UTF-8 -- http://www.utf8-chartable.de
Javascript is not good at encoding so V8 has some mechanisms to help

6 - Buffers

7 - ES6 Typed Arrays

8 - Javascript Aside: Callbacks

9 - Files and fs

10 - Streams

11 - Conceptual Aside: Pipes

12 - Pipes

13 - Web Server Checklist



                    Section 7: HTTP and being a Web Server
1 - Conceptual Aside: TCP/IP
A quick overview of TCP\IP, there is a much more indepth tutorial available at the following address
http://www.w3schools.com/website/web_tcpip.asp

2 - Conceptual Aside: Addresses and Ports
A quick overview of IP Addresses and Ports which handle the various protocols. There are 2 different types of IP addresses
there are tutorials much more indepth at the following locations
http://www.tutorialspoint.com/ipv4/index.htm
http://www.tutorialspoint.com/ipv6/index.htm

3 - Conceptual Aside: HTTP
HTTP is an acronym that stands for  Hypertext Transfer Protocol
It is essentially a set of rules for transferring data across the web
It is a format defining data transferred via HTTP
There are many different status codes for HTTP which operates via a request - response mechanism
The list of codes is available here
  - https://github.com/marb61a/Course-Notes/blob/master/Marketing/http%20status%20codes
MIME - This is a type which is a standard for defining the type od data being sent is 
MIME is an acronym that stands for - Multipurpose Internet Mail Extensions
The list of different MIME types is available here
  - https://www.sitepoint.com/web-foundations/mime-types-complete-list/

4 - http_parser
The Node JS parser code is located at 
  - https://github.com/nodejs/http-parser
A quick run through of the http_parser package
The http_parser breaks up the requests and responses into the proper format

5 - Let's Build a Web Server in Node

6 - Outputting HTML and Templates

7 - Streams and Performance
Using streams to improve performance
Using createReadStream method from fs
Create a readable file stream and then pipe it to stream
  - fs.createReadStream(_dirname + "/index.html").pipe(res)
This will take chunks of a file instead of waiting for a full file
This will improve performance levels and streams are fundamental to how the internet works anyway

8 - Conceptual Aside: APIs and Endpoints
API -- This is an acronym that stands for Application Programming Interface
It is a set of tools used to build a software application
On the internet these are made available via a set of URL's which accept and send only data via HTTP and TCP\IP
Endpoint - An Endpoint is one url in a web api
Sometimes that endpoint does multiple things by making choices based on the HTTP request headers

9 - Outputting JSON
Mime type = application/json
JSON similar to object literal syntax
You can use JSON.stringify(string) -- this will create a string in the JSON format
Serialize - Translating an object into a form that can be stored or transferred
CSV, XML and JSON are popular formats
DeSerialize is the opposite

10 - Routing

11 - Web Server Checklist



                    Section 8: NPM: the Node Package Manager
1 - Conceptual Aside: Packages and Package Managers

2 - Conceptual Aside: Semantic Versioning (semver)
Versioning - Specifying the version of a set of code
Semantic - Implies that there is something conveys meaning
Looking at a version number should convey a meaning
In Node version numbers should go Major.Minor.Patch eg 1.7.10 
 - Small patches eg bugfixes would become 1.7.11
 - Minor feature additions 1.8.11
 - Big changes 2.0.0 (will probably cause breakages)
Semantic Versioning - http://semver.org

3 - npm and the npm registry: Other People's Code
NPM - Node Package Manager
Install -- npm install
Check version installed -- npm -v
https://www.npmjs.com - Package repositories
Be very careful about packages you install

4 - init, nodemon, and package.json
Installation of Moment JS which is a JS library for dates times etc
  - https://momentjs.com
npm init - This is used to generate the npm package manager
The package.json file is created by npm init which contains the settings of your app
You can use npm to install packages
  - npm install moment --save 
  - using save saves it to drive and also writes an entry into package.json
  - Creates a node_modules folder to hold your installed packages
  - Not just used for Node apps
In package.json
  - ^ in a package means that it is alright to update to anything within the major packages eg 2.10.7 could be 2.11.8 but not 3
  - ~ means to only update patches
  - Having package.json means that you can share with people
  - You dont share node_modules folder
  
5 - npm Global Installation (Article)
You may run across permission issues on Mac or Linux. If that happens to you, here's a helpful link directly from npm's website:
  - https://docs.npmjs.com/getting-started/fixing-npm-permissions

6 - init, nodemon, and package.json - Part 2
npm install - this will install dependencies listed in package.json
Dev dependencies are dependencies needed for development
Example package for dev-dependencies is jasmine-node
  - https://www.npmjs.com/package/jasmine
  - npm install jasmine-node --save-dev // will save to dev-dependencies section of the package.json
  - Jasmine has its own node_modules folder for dependencies as does some of these dependencies
Dev-dependencies are not needed for the app to run
To install globally(available anywhere)
  - npm install -g
  - You may need permissions on *nix based systems
  - Various places for global modules to be stored
Nodemon is a utility that will monitor for any changes in your code and restarts the server
  - https://nodemon.io
  - Nodemon has its own node_modules folder
  - Nodemon has its own CLI utility
  - nodemon "entrypoint" eg nodemon server.js
Because of the amount of dependencies there can be a lot of bloat
To update installed packeages
  - npm update

7 - Using Other People's Code



                    Section 9: Express
1 - Installing Express and Making it Easier to Build a Web Server

2 - Routes

3 - Static Files and Middleware

4 - Templates and Template Engines

5 - Querystring and Post Parameters

6 - RESTful APIs and JSON

7 - Structuring an App



                    Section 10: Javascript, JSON, and Databases
1 - Conceptual Aside: Relational Databases and SQL

2 - Node and MySQL

3 - Conceptual Aside: NoSQL and Documents
NoSQL - Covers a variety of technologies
One type is a document DB - MongoDB is one of those
There are no tables
MongoDB uses JSON like documents
Changing technologies has superseeded the reason for using SQL in some cases

4 - MongoDB and Mongoose
Available here - https://www.mongodb.com
  - Install instructions available for installation on various platforms
Mongoose NPM package - http://mongoosejs.com
  - npm install mongoose
Cloud based service - https://mlab.com -- Free tier available
  - Demo of using Mongolab
    - Gives you a url to connect to

MongoDB uses a format called BSON (Binary JSON) which is a binary-encoded serialization of JSON-like documents
Full set of notes available on MongoDB available at 
  - Quick basic introduction to the material that will be covered by the section

5 - Web Server Checklist
Ability to work with databases



                  Section 11: The MEAN stack
1 - MongoDB, Express, AngularJS, and NodeJS

2 - AngularJS: Managing the Client

3 - AngularJS: Managing the Client (Part 2)

4 - AngularJS: Managing the Client (Part 3)

5 - Conceptual Aside: Angular 1, Angular 2, React, and more…
The frameworks in the title are client side
This is JS running in the browser
It is all still just JavaScript

6 - Working with The Full Stack (and being a Full Stack Developer) - Part 1



                    Section 12: Let's Build an App! (in record time)
A very basic app is built to demonstrate the concepts from the course

1 - NodeTodo: Software Requirements
A basic run through of what the project will require

2 - Initial Setup
3 - Setting up Mongo and Mongoose
4 - Adding Seed Data
5 - Creating our API
6 - Testing our API
7 - Future Lectures  (Article)
