                    Rethinking Asynchronous Javascript
                    
                    
                    
                    Section 1 - Parallel vs Async
1 - Course Introduction
Introduction to both the course and instructor
Course will be indepth
Instructor developed asynquence
  - https://github.com/getify/asynquence
Instructor prefers to learn the concepts of why rather than starting to use libraries etc without understanding why it works
Callbacks have some very serious deficiencies which will be discussed
New level of competency is an understanding of promises & generators and how they mix

2 - Single Threaded Javascript
Most people think that Async and Parallel are the same but they arent
An explanation of the differences is available 
  - https://www.quora.com/What-are-the-differences-between-parallel-concurrent-and-asynchronous-programming

3 - Concurrency
People think that concurrency means things occuring at the same time which the instructor partially agrees with
Instructor personally defines concurrency as 2 higher level tasks happening within the same timeframe
Demo of micro vs macro level tasks -- not official terminology
The operations have to happen on the same thread
Thread may suffer problems with contention 
Synchronous XHR has been deprecated and was a very bad idea
Synchronous XHR information available at
  - https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests
Interleaving operations give the impression of better performance and the ability for concurrency
Callbacks are insufficient for dealing with the complexity of modern Javascript



                    Section 2 - Callback
1 - Callback Hell
There is a website available with JS callback examples
  - http://callbackhell.com
Async Callback Example Syntax
  setTimeout(function(){
    console.log("callback");
  }, 1000);
The author call this example a continuation with 2 halves
  - 1st half is everything outside the timeout including the call itself
  - 2nd is everything inside the callback
Callbacks == Continuations
Callback Hell Example Syntax
  setTimeout(function(){
    console.log("one");
    setTimeout(function(){
      console.log("two");
      setTimeout(function(){
        console.log("three");
      }, 1000);
    }, 1000);
  }, 1000);
Sometimes referred to as the pyramid of doom
Not just about nesting or indentation
Example above in Continuation Passing Style Syntax
It suffers the same problems as above but the nesting is much more subtle
  function one(cb){
    console.log("one");
    setTimeout(cb, 1000);
  }
  function two(cb){
    console.log("two");
    setTimeout(cb, 1000);
  }
  function three(cb){
    console.log("three");
    setTimeout(cb, 1000);
  }
  one(function(){
    two(three);
  })

2 - Exercise 1
# Instructions
1. This exercise calls for you to write some async flow-control code. To start off with, you'll use callbacks only.
2. Expected behavior:
	- Request all 3 files at the same time (in "parallel").
	- Render them ASAP (don't just blindly wait for all to finish loading)
	- BUT, render them in proper (obvious) order: "file1", "file2", "file3".
	- After all 3 are done, output "Complete!".
Managing state through callbacks may seem simple but is difficult

3 - Exercise 1 Solution
There are many solutions possible but this is the official solution
Ordering callbacks will require sequential requesting
Paralell requesting will cause concurrency co-ordination complexity
The main point point of the exercise was to show how 3 callbacks would shared a closured state to co-ordinate
Solution Syntax
	function getFile(file){
		fakeAjax(file, function(text){
			fileReceived(file, text);
		});
	}

	function fileReceived(file,text) {
	// haven't received this text yet?
	if (!responses[file]) {
		responses[file] = text;
	}
	var files = ["file1","file2","file3"];
	// loop through responses in order for rendering
	for (var i=0; i<files.length; i++) {
		// response received?
		if (files[i] in responses) {
			// response needs to be rendered?
			if (responses[files[i]] !== true) {
				output(responses[files[i]]);
				responses[files[i]] = true;
			}
		}
		// can't render yet
		else {
			// not complete!
			return false;
		}
	}
	output("Complete!");
	}	

// hold responses in whatever order they come back
var responses = {};

4 - Callback Problems Inversion of Control
Inversion of Control
	- Loads of different definitions available
	- Here it means that there are portions of the code I am incharge of executing and parts I am not
	- This takes the code that executes now and the code executed in a callback and gives someone else control which is the inversion
	- This is said to be one of two major problems with callbacks
	- Example Syntax
	trackCheckout(
		purchaseInfo,
		function finish(){
			chargeCreditCard(purchaseInfo);
			showThankYouPage();
		}
	)
	The example above trusts that it will not be called too many times or too few, below is a fix based on a boolean
	- Example Syntax
	var hasBeenCalled = false;
	trackCheckout(
		purchaseInfo,
		function finish(){
			if(!hasBeenCalled){
				hasBeenCalled = true;
				chargeCreditCard(purchaseInfo);
				showThankYouPage();
			}
		}
	)
	- Trust
	 - Not too early
	 - Not too late
	 - Not too many times
	 - Not too few times
	 - No lost context
	 - No swallowed errors
	What happens if the trust falls apart?
	If your program does not have fixes for all of the above issues then the program has a bug even if is not apparent
	
5 - Callback Problems Not Reasonable
Callbacks in the instructors view cannot be reasoned about.
The instructor reckons that bugs happen when the programmers natural inclination for sequential steps diverges from the JS Engine
Pseudo Task Syntax
	- start task1:
		do some stuff
		pause
	- start task2:
		do some other stuff
		pause
	- resume task1:
		do more stuff
		pause
	- resume task2:
		finish stuff
	- resume task1:
		finish stuff
Refactored Pseudocode which has begun to resemble callbacks Syntax
	- start task1:
		do some stuff
		pause
			resume task1:
				do more stuff
				pause
					resume task1:
						finish stuff
	- start task2:
		do some other stuff
		pause
			resume task2:
				finish stuff
Temporal dependency is where an item depends on another item finishing before this item can proceed, this nesting is the
only way callbacks can handle temporal dependencies
No single developer will understand all flow paths of async code

6 - Non-Fixes
Some attempts at fixes have made issues worse
Split callbacks are an example of attempts to fix callbacks
	- This was is a situation where we have an error that we do not want to get swallowed just in case there is a problem with 
	  the main function, this then passes a seperate callback for errors
	- This doesn't work as it makes trust issues worse, what happens if neither function or both is called?
	-
Split callback Syntax
	function trySomething(ok, err){
		setTimeout(function(){
			var num = Math.random();
			if(num > 0.5) ok(num);
			else err(num);
		}, 1000);
	}
	trySomething(
		function(num){
			console.log('Success : ' + num);
		},
		function(num){
			console.log('Sorry : ' + num);
		}
	);

Error first Callbacks
	- used in Node.js
	- Dont fix the trust issues from split callbacks
	- Syntax
	function trySomething(cb){
		setTimeout(function(){
			var num = Math.random();
			if(num > 0.5) cb(null, num);
			else cb('Too Low');
		}, 1000);
	}
	trySomething(
		function(err, num){
			if(err){
				console.log(err);		
			}
			else {
				console.log('Number : ' + num);
			}
		}
	);

Nested Callback Syntax
	function getData(d, cb){
		setTimeout(function(){
			cb(d);
		}, 1000);	
	}
	getData(10, function(num1){
		var x = 1 + num1;
		getData(30, function(num2){
			var y = 1 + num2;
			getData(
				"Meaning of Life : " + (x + y),
				function(answer){
					console.log(answer);
				}
			);
		});
	});

                    Section 3 - Thunks
1 - Synchronous and Asynchronous Thunks
From a synchronous perspective a thunk is a function that has everything already that it needs to give you something back
you do not need to pass in anything, simply call it and it gives you back a value
Synchronous Thunk Example Syntax
	function add(x, y){
		return x + y;
	}
	
	var thunk = function(){
		return add(10,15);
	}
	
	thunk();
thunk has become a wrapper around that state as it is the same number and can be passed around the program like a token
This is the conceptual underpinning for what a promise is in JS
An asynchrounous thunk has many definitions, there are many different right answers, is can be defined as a function that
does not need any arguments passed to it tot do its job except you need to pass it a callback to get the value out
Asynchronous Thunk Example Syntax
	function addAsync(x, y, cb){
		setTimeout(function(){
			cb(x + y);
		}, 1000);
	};
	
	var thunk = function(cb){
		addAsync(10, 15, cb);
	};
	
	thunk(function(sum){
		sum();
	});
What makes this so powerful is that we do not know or care how long it will take to get that value
By wrapping the function around the state and allowing it to be asynchronous we have esentially normalised time out of the equation
Time is the most complex factor of state in a program
Thunks do not offer any solutions to Inversion of Control, promises will offer solutions to IOC's
Nested Thunk Syntax
// This is a re-writing of the previous section example
// The first line does not perform an AJAX request, it merely creates a wrapper that will make the request when called
  var get10 = makeThunk(getData, 10);
  var get30 = makeThunk(getData, 30);
  
  get10(function(num1){
    var x = 1 + num1;
    get30(function(num2){
      var y = 1 + num2;
      // This thunk cannot be created earlier as it is temporally dependent on the other thunks
      var getAnswer = makeThunk(getData, 
        "Meaning of life is " + (x + Y)
      );
      getAnswer(function(answer){
        console.log(answer);
      });
    });
  })

2 - Exercise 2
The same as exercise 1 but this time it involves thunks instead

3 - Exercise 2 Solution
Solution Syntax
	var th1 = getFile("file1");
  var th3 = getFile("file2");
  var th3 = getFile("file3");
  
  th1(function ready(text1){
    output (text1);
    th2(function ready(text2){
      output (text2);
      th3(function ready(text3){
        output (text3);
        output ("Complete"):
      });
    });
  });
If the thunk above was lazy it would not make the AJAX request until th1 was finished
This is much better than exercise 1
  Get File Syntax
  function getFile(file){
    var resp;
    
    fakeAjax(file, function(text){
      if(!resp){
        resp = text;
      } else{
        resp(text);
      } 
    })
    
    return function th(cb){
      if(resp){
        cb(resp);
      } else {
        resp = cb;
      }
    }
  }
Promises are not a replacement for thunks
You do not always need a framework, using the tools you have better can be a better solution

4 - Thunks and Closure
Thunks are not really all that special
Thunks use closure to maintain state
Thunks do not solve all the issues of callbacks
Thunks do however solve a problem
  - By using the closure to maintain state you eliminate time as a complicating factor


                    Section 4 - Promises
1 - Native Promises
Promises have a multitude of ways that they are explained
It's important to understand the concepts first before understanding the API
  - Many courses take the opposite approach
Promises are not perfect and have gotchas which you will need to understand in order to fix problems
There is such thing as promises hell
A future value is a programming concept for a value that will be fulfilled sometime in the future
Promises are concepts that have come from the language E where they are called futures
This is related to functional programming
  - Promise mechanisms are very similar to monads

2 - Promise API
Example Syntax for Completion Event
  // This avoids inversion of control
  function finish(){
    chargeCreditCard(purchaseInfo);
    showThankYouPage();
  }
  
  function error(err){
    logStatsError(err);
    finish();
  }  
  var listener = trackCheckout(purchaseInfo);
  
  listener.on("completion", finish);
  listener.on("error", error);

Promises uninvert the inversion of control problem
Promises are like event listeners but the completion event in promises is called the "Then" event
Example Syntax
  function trackCheckout(info){
    return new Promise(
      function(resolve, reject){
        // Attempt to track the checkout
        // If successful call resolve otherwise call reject(error)
      }
    )
  }
  
  // Refactored version of completion event example
  function finish(){
    chargeCreditCard(purchaseInfo);
    showThankYouPage();
  }
  
  function error(err){
    logStatsError(err);
    finish();
  }
  var promise = trackCheckout(purchaseInfo);
  
  promise.then(finish, error);

Frameworks use inversion of control intentionally where things are called for you, this also separates 
a library from a framework.
The instructor does not recommend inversion of control in Async coding
Promises still use call backs but there has been trust installed into the design
Promise Trust
  - They are only resolved once
  - They are either success or error
  - Messages passed or kept
  - Exceptions become errors
  - Immutable once resolved

3 - Promise Flow Control
Using the API is where people normally start learning about promises
Very rare to have a single asychronous action in a modern Javascript programme
Managing how all steps in your programme occur is called Flow Control
Chaining Promises
  - If you have 2 promises the return of the first promise inside a handler should be the second promise   
Example Psedocode
  doFirstThing()
    .then(function(){
      return doSecondThing();
    })
    .then(function(){
      return doThirdThing();
    })
    .then(
      complete, 
      error
    );
The fact that the promises are using a vertical chain rather that being nested is the least important factor
Delay Example Syntax
  function delay(num){
    return new Promise(function(resolve, reject){
      setTimeOut(resolve,num);
    })
  }
  delay(100)
  .then(function(){
    return delay(50);
  })
  .then(function(){
    return delay(200);
  })
  .then(function(){
    console.log('All Done');
  })
Meaning of Life Example Syntax
  function getData(d){
    return new Promise(function(resolve, reject){
      setTimeOut(function(){
        resolve(d);
      }, 1000);
    })
  }
  var x;
  
  getData(10)
  .then(function(num1){
    x = 1 + num1;
    return getData(30);
  })
  .then(function(num2){
    var y = 1 + num2;
    return getData("The meaning of life : " + (x + y));
  })
  .then(function(answer){
    console.log(answer);
  })

4 - Exercise 3

5 - Exercise 3 Solution

6 - Exercise 3 Solution Questions Part 1

7 - Exercise 3 Solution Questions Part 2

8 - Exercise 4 

9 - Exercise 4 Solution

10 - Abstractions

11 - Sequences and Gates

12 - Exercise 5

13 - Exercise 5 Solution

14 - Exercise 6



                    Section 5 - Generators
1 - Generator Example

2 - Messaging

3 - Messaging Questions

4 - Async Generator

5 - Promises Generator

6 - Exercise 7

7 - Exercise 7 Solution

8 - Quiz



                    Section 6 - Observables
1 - Events-Promises

2 - Observables

3 - Reactive Sequences

4 - Exercise 8

5 - Exercise 8 Solution Part 1

6 - Exercise 8 Solution Part 2



                    Section 7 - CSP (Communicating Sequential Processes)
1 - Concurrency Channels

2 - Blocking Chains

3 - Event Channels

4 - Exercise 9

5 - Exercise 9 Solution

6 - Recap

7 - Exercise 10

8 - Wrap Up
