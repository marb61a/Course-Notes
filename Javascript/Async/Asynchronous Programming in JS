                                  Notes from Asynchronous Programming in Javascript
                                  A Frontend Masters course
                    
                    
                    Section 1 - Building Blocks
1 - Introduction - 
Like all Frontend Masters courses this is classroom based, the first section introduces
the instructor and what is to come in the course. There is also a small dip into some preconceptions regarding
Async programming. There are also some code samples used to illlustrate the road ahead.

2 - Javascript Tutorial
The second video is a very basic run through of some new ES6 syntax and some of the functions which are important
going through the course such as Map and Filter as well as a function which will be made by participants.

3 - Creating Collections 
  
4 - Iterators and Observables
What is the difference between an event and an array
Events and arrays are both collections
Mistakes were made in the GOF design patterns book
Iterator pattern is in ES6
Iterators and Observables are deeply related
Iterators have producers and consumers
  - Consumers request information one ane piece at a time until the producer says I have no more or error occured
Syntax in example 
  - var iterator = [1,2,3].iterator();
  - console.log(iterator.next());
  - when run this will give the next number at eash iteration and a done false message until done is true
The iterator enables you to use a data structure without knowing anything about its internal implementation details and 
consume the elements in the structure
The new for of loop uses this
Map, Filter and ConcatAll can be implemented using an iterator
Observer Pattern syntax example
   - document.addEventListener(
      "mousemove";
      function next(e){
        console.log(e);
   })
This pattern was used to communicate a change to a model to the view or vice versa
In Javascript they are DOM events
In iterator pattern consumers are in control they decide when to get the next value but in the observer pattern
the producer is in control
The iterator and observer pattern are symmetrical
Iterator and Observer have different semantics
Javascript deals with push streams regularly which was not foreseen at time of book
Multiple different streams API are available 
  - DOM Events
  - Websockets
  - Server-sent Events
  - Node Streams
  - Service Workers
  - jQuery Events
  - XMLHttpRequest
  - setInterval
Various mechanisms for indication of completion
There should be one interface for push streams in Javascript
  - Observable
    - Array is an iterable which is something you can ask to give you an iterator
    - Observable === Collection + Time -- a collection that arrives over time
    

  
                    Section 2 - Observables
1 - Observables Introduction
Observables can model
  - Events
  - Async Server Requests
  - Animations
These are the 3 most common actions that are seen in UI
Reactive Extensions
  - Events as streams
  - Open Source Apache 2 licence
  - Ported to multiple languages - c#, Java, Javascript
Events to Observables
  Syntax - var mouseMoves = Observable.from(element, "mousemove");
Observable libraryhas functions to help deal with Stream API

Event Subscription
  Syntax - 
    // Subscribe
    var handler = (e) => console.log(e);
    document.addEventListener("mousemove", handler);
    
    // Unsubscribe
    document.removeEventListener("mousemove", handler);
Observable.forEach(covers the above example)
  Syntax -
    // Subscribe
    var subscription = mouseMoves.forEach(console.log);
    // Unsubscribe
    subscription.dispose();
Observable forEach method differs from an array forEach method

Expanded Observable.forEach
  Syntax -
  // Subscribe
  var subscription = mouseMoves.forEach(
    // Next Data
    onNext : event => console.log(event),
    // Error
    onError : error => console.error(error),
    // Completed
    onCompleted : () => console.log("done")
  );
  // Unsubscribe
  subscription.dispose();
Proposal to add Observable to Javascript

2 - Observable Metaphor
Observable is both push and pull data
Example using people handing cake to each other until you run out of pieces
Observables is about who is in control producers or consumers

Observer Object Syntax
  // Subscribe
  var subscription = mouseMoves.forEach({
    // Next Data
    onNext : event => console.log(event),
    // Error
    onError : error => console.error(error),
    // Completed
    onCompleted : () => console.log("done")
  });
  // Unsubscribe
  subscription.dispose();
  
Converting Events to Observables
  Syntax -
  Observable.fromEvent = function(dom, eventName){
    // Returning Obervable Object
    return {
      forEach : function(observer){
        var handler = (e) => observer.onNext(e)
        dom.addEventListener(eventName, handler);
        
        // Returning Subscription Object
        return {
          dispose : function(){
            dom.removeEventListener(eventName, handler);
          }
        }
      }
    }
  }

An observable is nothing but an object with a forEach method
All other functions are implemented with forEach in mind

3 - Observables In Action
Example using special syntax to create an observable
Not official syntax
  Example Syntax
    - Observable Literal
    time ---->
    {1..2...3..}

Map applies a function to every item in a collection and returns a new collection containing new results
Filter takes a collection a creates a new collection of the items that passed the filtering
concatAll flattens arrays top to bottom
A collection of observables, an observable of observables contains more than one way to flatten it
You can resolve nearly all UI async concurrency problem using 3 strategies
The new dimension of time in observables allows for concurrency

concatAll Strategy Syntax -
  time ---->
  {
    ...{1}
    ......{2.........3},
    ...........{}
    .............{4}
  }.concatAll()
  // Flattened Stream
  {..1..2............3..4}

What distinguishes concatAll is that is allways ensures that elements come out in the order thet the collection
that they were inside of arrives
The observables will not emit values until you begin to forEach over them, not all observables behave like this
Hot observables are streams that are operating whether you are listening or not, the example is a cold observable
forEach on an empty collection will fire onCompleted

4 - Race Conditions And Nested Observables
The previous example helps prevent race conditions
Tutorial on JS race conditions
  - https://medium.com/@slavik57/async-race-conditions-in-javascript-526f6ed80665
Never use concatAll() on an infinite stream
If you get an error between inner observables you would never get to the rest of the observables as onCompleted would be called
dispose() never calls onComplete()

5 - TakeUntil
TakeUntil Strategy Syntax -
  time ---->
  {...1..2.......3}.takeUntil( // Source collection
  {..........4}) // Stop Collection
  {...1..2..}

takeUntil takes anobservable thats a source observable and an observable thats a stop observable and every time that the source
observable emits something it forwards it on but as soon but as soon as the stop observable emits a value it completes the
overall observable
You do not need to remove event listeners because this will replace it
Dont unsubscribe from events instead create streams of data that complete when you want them to

6 - Implementing Mouse Move
Mouse Drags Collection Syntax
  - var getElementDrags = elemt => {
      elemt.mouseDowns = Observable.fromEvent(elemt, 'mousedown');
      elemt.mouseUps = Observable.fromEvent(elemt, 'mouseup');
      elemt.mouseMoves = Observable.fromEvent(elemt, 'mousemove');
      return elemt.mouseDowns.
          map( mouseDown =>
            document.mouseMoves.
              takeUntil(document.mouseUps)).
          concatAll();
     };
    getElementDrags(image).
      forEach(pos => image.position = pos);

Question sked about proper tails calls, more on tails calls is here
  - http://2ality.com/2015/06/tail-call-optimization.html
  - Tail recursion does not have much to do with async

The Javascript event loop 
  - http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/

Arrow syntax - If you have multiple lines of code you need an explicit return statement

7 - MergeAll & SwitchLatest
mergeAll Strategy Syntax -
  time ---->
  {
    ...{1}
    ......{2.........3},
    ...........{}
    .............{4}
  }.mergeAll()
  {..1..2....4.........3}
In mergeAll its first come first served
Use mergeAll when you dont worry about data order

switchLatest Strategy Syntax -
  time ---->
  {
    ...{1}
    ......{2.........3},
    ...........{}
    .............{4}
  }.switchLatest()
  {..1..2...4}
switchLatestOnNotification - Flattening pattern
Switch happens as soon as another observable arrives
This is the most common pattern
switchLatest is the most useful pattern in UI it replaces State machines

8 - Netflix Search Box
Don't unsubscribe from events, complete them when another event fires
UI's are usually made of 3 asynchronous events
  - Events
  - Async Requests
  - Animations
Example using observables to combine events and async requests
  Netflix Search Example Syntax
  var searchResultsSets = 
    keyPresses.
      throttle(250).
      map(key => 
        getJson("/searchResults?q=" + input.value).
        retry(3).
        takeUntil(keyPresses)).
      concatAll();
  
  searchResultsSets.forEach(
    resultSet => updateSearchResults(resultSet);
    error => showMessage("The server appears to be down");
  )

9 - Optimizing The Search
Simplified version use switchLatest
  var searchResultsSets = 
    keyPresses.
      throttle(250).
      map(key => 
        getJson("/searchResults?q=" + input.value).
        retry(3)).
      switchLatest();
  
  searchResultsSets.forEach(
    resultSet => updateSearchResults(resultSet);
    error => showMessage("The server appears to be down");
  )
Promises are not useful for most UI problems (network requests & animations) because Promises cannot be cancelled
A promise is an object that eventually resolves asynchronously to a value
Observables are much more useful in certain situations
Creating an observable doesn't create a network request
An observable is lazy
Retry is called on the observable
Throttle in this case is a performance optimisation

10 - Three Dimension Collections
You will have to learn how to handle multi dimensional collections
You will then apply the appropriate flattening strategies until it reaches a single dimensiion and then run a forEach
That is not a natural skill but instaed needs to be drilled, it can be applied to a lot of different areas not just async
Player Callback Hell Syntax
  function play(movieID, cancelButton, callback){
    var movieTicket,
        playError,
        tryFinish = function(){
          if(playError){
            callback(null, playError);
          } else if(movieTicket && player.initialized){
            callback(null, ticket);
          }
        };
    cancelButton.addEventListener("click", function(){playError = "cancel";});
     
    if(!player.initialized){
      player.init(function(error){
        playError = error;
        tryFinish();
      });
    }
    authorizeMovie(movieId, function(error, ticket){
      playError = error;
      movieTicket = ticket;
      tryFinish();
    })
  }
The above is replaced with the following syntax
  var authorizations = 
    player.
    // Creates an observable of 1
      init().
      map(() =>
        playAttempts.
          map(movieId =>
            player.authorize(movieId).
            // Creates a function that can optionally resume from
            // Only catching error on inner observable
              catch(e => Observable.empty).
              takeUntil(cancels)).
          concatAll()))
      concatAll();
  authorizations.forEach(
    licence => player.play(licence),
    error => showDialog("Sorry cannot play right now")
  );  
Each map will deepen by a level


  
										Section 3 - Creating Array Functions
Use debugger in exercise  will help find errors in developer tools

1 - Exercises 1 - 5
Recommended to use Firefox
Points to
  - https://github.com/ReactiveX/learnrx
  - http://reactivex.io/learnrx/

Exercise 1 Syntax
function(console) {
	var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"],
		counter;

	for(counter = 0; counter < names.length; counter++) {
		console.log(names[counter]);
	}
}

Exercise 2 Syntax
function(console) {
	var names = ["Ben", "Jafar", "Matt", "Priya", "Brian"];

	names.forEach(function(name) {
		console.log(name);
	});
}

Exercise 3 Syntax
Projection is basically map() function
function() {
	var newReleases = [
		{
			"id": 70111470,
			"title": "Die Hard",
			"boxart": "http://cdn-0.nflximg.com/images/2891/DieHard.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [4.0],
			"bookmark": []
		},
		{
			"id": 654356453,
			"title": "Bad Boys",
			"boxart": "http://cdn-0.nflximg.com/images/2891/BadBoys.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [5.0],
			"bookmark": [{ id: 432534, time: 65876586 }]
		},
		{
			"id": 65432445,
			"title": "The Chamber",
			"boxart": "http://cdn-0.nflximg.com/images/2891/TheChamber.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [4.0],
			"bookmark": []
		},
		{
			"id": 675465,
			"title": "Fracture",
			"boxart": "http://cdn-0.nflximg.com/images/2891/Fracture.jpg",
			"uri": "http://api.netflix.com/catalog/titles/movies/70111470",
			"rating": [5.0],
			"bookmark": [{ id: 432534, time: 65876586 }]
		}
	],
	videoAndTitlePairs = [];
  newReleases.forEach(function(video){
    videoAndTitlePairs.push({id: video.id, title: video.title});
  })
	return videoAndTitlePairs;
}

Exercise 4 Syntax
Array.prototype.map = function(projectionFunction) {
	var results = [];
	this.forEach(function(itemInArray) {
		results.push(projectionFunction(itemInArray));
	});
	return results;
};

Exercise 5 Syntax
Same data set for exercise 3 but using map this time
return newReleases.map(video => ({id: video.id, title: video.title}))


2 - Exercises 6 - 11
Exercise 6 Syntax
Use forEach() to loop through the videos in the newReleases array and, if a video has a rating of 5.0, add it to the videos array.
	videos = [];
	newReleases.forEach(function(video){
	    if(video.rating === 5.0){
		videos.push(video);
	    }
	  })
	return videos;

Exercise 7 Syntax
To make filtering easier, let's add a filter() function to the Array type. The filter() function accepts a predicate.
A predicate is a function that accepts an item in the array, and returns a boolean indicating whether the item should be retained in
the new array.
	Array.prototype.filter = function(predicateFunction) {
	var results = [];
	this.forEach(function(itemInArray) {
	    if(predicateFunction(itemInArray)){
		results.push(itemInArray);
	    }
		});
	return results;
};

Exercise 8 Syntax
Chain filter and map to collect the ids of videos that have a rating of 5.0
	return newReleases.
    		filter(video => video.rating === 5.0).
   	 	map(video => video.id);

Exercise 9 Syntax
Flatten the movieLists array into an array of video ids
	movieLists.forEach(movieList => {
		movieList.videos.forEach(video => {
			allVideoIdsInMovieLists.push(video.id);
		});
	});

Exercise 10 Syntax
Let's add a concatAll() function to the Array type. The concatAll() function iterates over each sub-array in the array and 
collects the results in a new, flat array. Notice that the concatAll() function expects each item in the array to be another array.
	Array.prototype.concatAll = function() {
	var results = [];
	this.forEach(function(subArray) {
	    subArray.forEach(function(item){
		results.push(item);
	    })
		});
		return results;
	};

	// JSON.stringify([ [1,2,3], [4,5,6], [7,8,9] ].concatAll()) === "[1,2,3,4,5,6,7,8,9]"
	// [1,2,3].concatAll(); // throws an error because this is a one-dimensional array

Exercise 11 Syntax
Use map() and concatAll() to project and flatten the movieLists into an array of video ids
ConcatAll only works on arrays of arrays not objects which cintain arrays hence comes after mapping in the example
	return movieLists.map(movieList => 
		movieList.videos.map(video => video.id))
	.concatAll();

3 - Exercise 12
Retrieve id, title, and a 150x200 box art url for every video
There's just more one thing: you can't use indexers. In other words, this is illegal:
	var itemInArray = movieLists[0];
Developers not comfortable with nested collections
Being Comfortable is key to becoming good at async programming
Syntax
	return movieLists.
	  map(function(movieList) {
		return movieList.videos.
		  map(function(video) {
			return video.boxarts.
			  filter(function(boxart) {
				return boxart.width === 150;
			  }).
			  map(function(boxart) {
				return {id: video.id, title: video.title, boxart: boxart.url};
			  });
		  }).
		  concatAll();
	  }).
	  concatAll();
Flatten by n - 1 for example if you have 3 levels of mapping concatAll 2 times
Ensure that your code is readable even in multiple nesting levels
Keep mapping until you have a variable bound to everything you need to create a result 

4 - Exercises 13 - 14
Exercise 13 - Implement concatMap()
Nearly every time we flatten a tree we chain map() and concatAll(). Sometimes, if we're dealing with a tree several levels deep, 
we'll repeat this combination many times in our code. To save on typing, let's create a concatMap function that's just a map 
operation, followed by a concatAll.
Syntax
	Array.prototype.concatMap = function(projectionFunctionThatReturnsArray) {
	return this.
		map(function(item) {
			return projectionFunctionThatReturnsArray(item);
		}).
		// apply the concatAll function to flatten the two-dimensional array
		concatAll();
	};

Exercise 14 -Use concatMap() to retrieve id, title, and 150x200 box art url for every video
Let's repeat the exercise we just performed. However this time we'll simplify the code by replacing the map().concatAll() calls with
concatMap().
Syntax
	return movieLists.concatMap(
		movieList =>
		movieList.videos.concatMap(
			video => 
				video.boxarts.
				filter( boxart => boxart.width === 150 && boxart.height === 200 ).
				map( boxart =>
					({
						id: video.id,
						title: video.title,
						boxart: boxart.url
					})
				)
		)
	)


5 - Exercises 15 - 17
Reduce takes an array with many values an reduces it to an array with a single value
Reduce is written in such a way that it cannot be implemented over an observable, it is regarded as a code smell is reduce
is doing too much specifically if inside a function that returns one value. This is a shortcut that works when looking at an array 
definition but when looking at array and observable cases there is only one definition of reduce that will work for both arrays
and observables and that is to return an array of one or observable of one
Reduce is for when you need to look at 2 values at least at the same time 

Exercise 15 Use forEach to find the largest box art
In this example we use forEach to find the largest box art. Each time we examine a new boxart we update a variable with the currently 
known maximumSize. If the boxart is smaller than the maximum size, we discard it. If it's larger, we keep track of it. Finally we're
left with a single boxart which must necessarily be the largest.
Syntax
	function() {
		var boxarts = [
				{ width: 200, height: 200, url: "http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
				{ width: 150, height: 200, url: "http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				{ width: 300, height: 200, url: "http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
				{ width: 425, height: 150, url: "http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
			],
			currentSize,
			maxSize = -1,
			largestBoxart;

		boxarts.forEach(function(boxart) {
			currentSize = boxart.width * boxart.height;
			if (currentSize > maxSize) {
				largestBoxart = boxart;
				maxSize = currentSize;
			}
		});

		return largestBoxart;
	}
	
Exercise 16
Let's add a reduce() function to the Array type. Like map. Take note this is different from the reduce in ES5, which returns a value
instead of an Array!
Syntax
	// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }); === [6];
	// [1,2,3].reduce(function(accumulatedValue, currentValue) { return accumulatedValue + currentValue; }, 10); === [16];
	Array.prototype.reduce  = function(combiner, initialValue){
		var counter,
			accumulatedValue;
		
		// If array is empty do nothing
		if(this.length === 0){
			return this;
		} else {
			// If the user didn't pass an initial value, use the first item.
			if(arguments.length === 1){
				counter.length = 1;
				accumulatedValue = this[0];
			} else if (arguments.length >= 2){
				counter = 0;
				accumulatedValue = initialValue;
			} else{
				throw "Invalid arguments.";
			}
			// Loop through the array, feeding the current value and the result of
			// the previous computation back into the combiner function until
			// we've exhausted the entire array and are left with only one value.
			while(counter < this.length) {
				accumulatedValue = combiner(accumulatedValue, this[counter])
				counter++;
			}
			return [accumulatedValue];
		}
	}

Exercise 17
Retrieve the largest rating. Let's use our new reduce function to isolate the largest value in an array of ratings.
Syntax
	function() {
		var ratings = [2,3,1,4,5];
		// You should return an array containing only the largest rating. Remember that reduce always
		// returns an array with one item.
		return ratings.
		reduce(function(acc, curr){
		  return acc > curr ? acc : curr;
		})
	}

6 - Exercises 18 - 19
Exercise 18 Retrieve url of the largest boxart
Let's try combining reduce() with map() to reduce multiple boxart objects to a single value: the url of the largest box art.
Syntax
	function() {
		var boxarts = [
				{ width: 200, height: 200, url: "http://cdn-0.nflximg.com/images/2891/Fracture200.jpg" },
				{ width: 150, height: 200, url: "http://cdn-0.nflximg.com/images/2891/Fracture150.jpg" },
				{ width: 300, height: 200, url: "http://cdn-0.nflximg.com/images/2891/Fracture300.jpg" },
				{ width: 425, height: 150, url: "http://cdn-0.nflximg.com/images/2891/Fracture425.jpg" }
			];

		// You should return an array containing only the URL of the largest box art. Remember that reduce always
		// returns an array with one item.
		return boxarts.
		reduce((acc, curr) => 
		  (acc.width * acc.height > curr.width * curr.height) ? acc : curr)
		  .map(boxart => boxart.url)
	}

Exercise 19 Reducing with an initial value
Sometimes when we reduce an array, we want the reduced value to be a different type than the items stored in the array. Let's say we 
have an array of videos and we want to reduce them to a single map where the key is the video id and the value is the video's title.
Using reduce() can be challenging because sometimes the type of the objects in the collection differs from the type that we
want to come out of reduce(). The result of reduce() will usually be the same type as whatever the acc value is. If you provide
an acc value you would expect what comes out of reduce to be that type.
Inside of a map, filter, reduce functions etc never ever change a variable that you do not own!!!!
Using object mutation can creat a lot of complexity in an application 
Map, Filter etc never mutate arrays they create new data from old data
Because of prototypical inheritance every object in Javascript is like a linkedlist of objects
Syntax
	return videos.
		reduce(function(accumulatedMap, video) {
		var clone = Object.create(accumulatedMap);
		clone[video.id] = video.title;
		return clone;
		},	
  	{});
Object.seal() can be used to lock down objects

7 - Exercise 20
Exercise 20: Retrieve the id, title, and smallest box art url for every video.
This is a variation of the problem we solved earlier, where we retrieved the url of the boxart with a width of 150px. This 
time we'll use reduce() instead of filter() to retrieve the smallest box art in the boxarts array.
You will need to use reduce as you will be comparing items to find the smallest
You will use 2 concatAll() on 3 dimensions as it flattens by 1 each time
Syntax
	return movieLists.
		concatMap(movieList =>
    	movieList.videos.concatMap(video =>
    		video.boxarts.reduce((acc, curr) => 
     			acc.width * acc.height < curr.height * curr.width ? acc : curr).
				map( boxart =>
					({
						id: video.id,
						title: video.title,
						boxart: boxart.url
					})
				)
		  )         
    )	

8 - Exercises 21 - 23
Zipping Arrays
Sometimes we need to combine two arrays by progressively taking an item from each and combining the pair. If you visualize a zipper,
where each side is an array, and each tooth is an item, you'll have a good idea of how the zip operation works.
Exercise 21: Combine videos and bookmarks by index
Use a for loop to traverse the videos and bookmarks array at the same time. For each video and bookmark pair, create a 
{videoId, bookmarkId} pair and add it to the videoIdAndBookmarkIdPairs array.
Syntax
// There is the video and bookmarks arrays above this but this is where the functionality occurs
	counter,
	videoIdAndBookmarkIdPairs = [];

	for(counter = 0; counter < Math.min(videos.length, bookmarks.length); counter++) {
    videoIdAndBookmarkIdPairs.push({videoId: videos[counter].id, bookmarkId: bookmarks[counter].id })
  }

	return videoIdAndBookmarkIdPairs;

Exercise 22: Implement zip
Let's add a static zip() function to the Array type. The zip function accepts a combiner function, traverses each array at the same
time, and calls the combiner function on the current item on the left-hand-side and right-hand-side. The zip function requires an 
item from each array in order to call the combiner function, therefore the array returned by zip will only be as large as the smallest
input array.
Syntax
  // JSON.stringify(Array.zip([1,2,3],[4,5,6], function(left, right) { return left + right })) === '[5,7,9]'
  Array.zip = function(left, right, combinerFunction) {
    var counter,
      results = [];

    for(counter = 0; counter < Math.min(left.length, right.length); counter++) {
    // This generalises the zip functioin
      results.push(combinerFunction(left[counter], right[counter]))
    }
    return results;
  };

Exercise 23 Combine Videos And Bookmarks By Index
Let's repeat exercise 21, but this time lets use your new zip() function. For each video and bookmark pair, create a {videoId, 
bookmarkId} pair.
Syntax
  return Array.
		zip(
    	videos,
      bookmarks,
      (video, bookmark) => ({videoId: video.id, bookmarkId: bookmark.id})
    )
It can seem difficult to move away from loops but the functions being learned are much more self descriptive
It is important to master these functions
There are many ways to process a collection and many of what seemed new are just specialisations of an overall pattern

9 - Exercise 24
Exercise 24: Retrieve each video's id, title, middle interesting moment time, and smallest box art url.
This is a variation of the problem we solved earlier. This time each video has an interesting moments collection, each representing 
a time during which a screenshot is interesting or representative of the title as a whole. Notice that both the boxarts and
interestingMoments arrays are located at the same depth in the tree. Retrieve the time of the middle interesting moment and the 
smallest box art url simultaneously with zip(). Return an {id, title, time, url} object for each video.
Syntax
return movieLists.
		concatMap(movieList => 
    	movieList.videos.concatMap(video => {
      	var middleInterestingMoment = 
        	video.interestingMoments.filter(moment => moment.type === "Middle");
  			var smallestBoxArt = video.boxarts.reduce(
        	(smallestSoFar, current) => 
          	smallestSoFar.width * smallestSoFar.height < current.width * current.height ?
          	smallestSoFar : current);
  			return Array.zip(middleInterestingMoment, smallestBoxArt, (moment, boxart) => ({
                  id: video.id,
                  title: video.title,
                  time: moment.time,
                  url: boxart.url
          }));
       })
		);
When solving problems like the one above you will ask yourself which is the right function to use as there are only 5
Zip allows you to use as many arrays as you like


										Section 4 - Creating Trees
1 - Debugging Async
Debugging these progrgams will differ from what would have been done previously
Debugging tools are built for debugging existing imperative programs
Debugging async programs can be very difficult
Instead of the usual procedure of step overs you will set breakpoint run set breakpoint run ...
Chrome is the browser used for debugging
  - Add a breakpoint and play(using the play button)
Browser optimisations may cause bugs
Unit tests should be very much the same
Most JS testing frameworks support Async testing

2 - SQL Comparison
Quick overview of the material covered thus far
Some of the examples used thus far are very similar to SQL
  - The syntax is different but the concepts are very similar
Map, filter very same as SQL concepts
SQL Example Syntax
  - SELECT videos.name, lists.name FROM video videos FROM list lists WHERE list.id = video.listid 
  - The same in JS is
    var videoNamesAndListNames = lists.map(list =>
      videos.filter(video => video.listid === list.id)
      .map(video => {
        name: video.name,
        listName: list.name
      })).concatAll()
The same operations occur in
  - Filter & WHERE
  - Map & SELECT

3 - Exercise 25

4 - Exercise 26a

5 - Exercise 26b

6 - Exercise 27



										Section 5 - Handling Events with Observables
1 - Exercises 28 - 30

2 - Exercise 31

3 - Observables And Events

4 - Anatomy Of An Observable

5 - Creating A setTimeout Observable

6 - Observables vs Promises

7 - Exercise 32

8 - Exercise 33



										Section 6 - Handling HTTP Requests with Observables
1 - Exercise 34

2 - Searching Wikipedia

3 - JSONP as an Observable

4 - Composing a Stream

5 - Displaying AutoComplete Data

6 - distinctUntilChanged

7 - Catching Errors

8 - Handling Empty Searches

9 - Showing The Search Box

10 - Close Button Observable

11 - Completing The Close Button

13 - Audience Questions



										Section 7 - Observable In Depth
1 - Creating an Observable Class

2 - Observable Map Function

3 - Observable Filter Function

4 - Using the Observable Class

5 - Observable Take Function

6 - Implementing A Better Object.observe

7 - Binding Between Views And Models

8 - Syncing Data with the Server

9 - Observables As Animations
