                                  Notes from Asynchronous Programming in Javascript
                                  A Frontend Masters course
                    
                    
                    Section 1 - Building Blocks
1 - Introduction - 
Like all Frontend Masters courses this is classroom based, the first section introduces
the instructor and what is to come in the course. There is also a small dip into some preconceptions regarding
Async programming. There are also some code samples used to illlustrate the road ahead.

2 - Javascript Tutorial
The second video is a very basic run through of some new ES6 syntax and some of the functions which are important
going through the course such as Map and Filter as well as a function which will be made by participants.

3 - Creating Collections 
  
4 - Iterators and Observables
What is the difference between an event and an array
Events and arrays are both collections
Mistakes were made in the GOF design patterns book
Iterator pattern is in ES6
Iterators and Observables are deeply related
Iterators have producers and consumers
  - Consumers request information one ane piece at a time until the producer says I have no more or error occured
Syntax in example 
  - var iterator = [1,2,3].iterator();
  - console.log(iterator.next());
  - when run this will give the next number at eash iteration and a done false message until done is true
The iterator enables you to use a data structure without knowing anything about its internal implementation details and 
consume the elements in the structure
The new for of loop uses this
Map, Filter and ConcatAll can be implemented using an iterator
Observer Pattern syntax example
   - document.addEventListener(
      "mousemove";
      function next(e){
        console.log(e);
   })
This pattern was used to communicate a change to a model to the view or vice versa
In Javascript they are DOM events
In iterator pattern consumers are in control they decide when to get the next value but in the observer pattern
the producer is in control
The iterator and observer pattern are symmetrical
Iterator and Observer have different semantics
Javascript deals with push streams regularly which was not foreseen at time of book
Multiple different streams API are available 
  - DOM Events
  - Websockets
  - Server-sent Events
  - Node Streams
  - Service Workers
  - jQuery Events
  - XMLHttpRequest
  - setInterval
Various mechanisms for indication of completion
There should be one interface for push streams in Javascript
  - Observable
    - Array is an iterable which is something you can ask to give you an iterator
    - Observable === Collection + Time -- a collection that arrives over time
    


  
                    Section 2 - Observables
1 - Observables Introduction
Observables can model
  - Events
  - Async Server Requests
  - Animations
These are the 3 most common actions that are seen in UI
Reactive Extensions
  - Events as streams
  - Open Source Apache 2 licence
  - Ported to multiple languages - c#, Java, Javascript
Events to Observables
  Syntax - var mouseMoves = Observable.from(element, "mousemove");
Observable libraryhas functions to help deal with Stream API

Event Subscription
  Syntax - 
    // Subscribe
    var handler = (e) => console.log(e);
    document.addEventListener("mousemove", handler);
    
    // Unsubscribe
    document.removeEventListener("mousemove", handler);
Observable.forEach(covers the above example)
  Syntax -
    // Subscribe
    var subscription = mouseMoves.forEach(console.log);
    // Unsubscribe
    subscription.dispose();
Observable forEach method differs from an array forEach method

Expanded Observable.forEach
  Syntax -
  // Subscribe
  var subscription = mouseMoves.forEach(
    // Next Data
    onNext : event => console.log(event),
    // Error
    onError : error => console.error(error),
    // Completed
    onCompleted : () => console.log("done")
  );
  // Unsubscribe
  subscription.dispose();
Proposal to add Observable to Javascript

2 - Observable Metaphor
Observable is both push and pull data
Example using people handing cake to each other until you run out of pieces
Observables is about who is in control producers or consumers

Observer Object Syntax
  // Subscribe
  var subscription = mouseMoves.forEach({
    // Next Data
    onNext : event => console.log(event),
    // Error
    onError : error => console.error(error),
    // Completed
    onCompleted : () => console.log("done")
  });
  // Unsubscribe
  subscription.dispose();
  
Converting Events to Observables
  Syntax -
  Observable.fromEvent = function(dom, eventName){
    // Returning Obervable Object
    return {
      forEach : function(observer){
        var handler = (e) => observer.onNext(e)
        dom.addEventListener(eventName, handler);
        
        // Returning Subscription Object
        return {
          dispose : function(){
            dom.removeEventListener(eventName, handler);
          }
        }
      }
    }
  }

An observable is nothing but an object with a forEach method
All other functions are implemented with forEach in mind

3 - Observables In Action
Example using special syntax to create an observable
Not official syntax
  Example Syntax
    - Observable Literal
    time ---->
    {1..2...3..}

Map applies a function to every item in a collection and returns a new collection containing new results
Filter takes a collection a creates a new collection of the items that passed the filtering
concatAll flattens arrays top to bottom
A collection of observables, an observable of observables contains more than one way to flatten it
You can resolve nearly all UI async concurrency problem using 3 strategies
The new dimension of time in observables allows for concurrency

concatAll Strategy Syntax -
  time ---->
  {
    ...{1}
    ......{2.........3},
    ...........{}
    .............{4}
  }.concatAll()
  // Flattened Stream
  {..1..2............3..4}

What distinguishes concatAll is that is allways ensures that elements come out in the order thet the collection
that they were inside of arrives
The observables will not emit values until you begin to forEach over them, not all observables behave like this
Hot observables are streams that are operating whether you are listening or not, the example is a cold observable
forEach on an empty collection will fire onCompleted

4 - Race Conditions And Nested Observables
The previous example helps prevent race conditions
Tutorial on JS race conditions
  - https://medium.com/@slavik57/async-race-conditions-in-javascript-526f6ed80665
Never use concatAll() on an infinite stream
If you get an error between inner observables you would never get to the rest of the observables as onCompleted would be called
dispose() never calls onComplete()

5 - TakeUntil
TakeUntil Strategy Syntax -
  time ---->
  {...1..2.......3}.takeUntil( // Source collection
  {..........4}) // Stop Collection
  {...1..2..}

takeUntil takes anobservable thats a source observable and an observable thats a stop observable and every time that the source
observable emits something it forwards it on but as soon but as soon as the stop observable emits a value it completes the
overall observable
You do not need to remove event listeners because this will replace it
Dont unsubscribe from events instead create streams of data that complete when you want them to

6 - Implementing Mouse Move
Mouse Drags Collection Syntax
  - var getElementDrags = elemt => {
      elemt.mouseDowns = Observable.fromEvent(elemt, 'mousedown');
      elemt.mouseUps = Observable.fromEvent(elemt, 'mouseup');
      elemt.mouseMoves = Observable.fromEvent(elemt, 'mousemove');
      return elemt.mouseDowns.
          map( mouseDown =>
            document.mouseMoves.
              takeUntil(document.mouseUps)).
          concatAll();
     };
    getElementDrags(image).
      forEach(pos => image.position = pos);

Question sked about proper tails calls, more on tails calls is here
  - http://2ality.com/2015/06/tail-call-optimization.html
  - Tail recursion does not have much to do with async

The Javascript event loop 
  - http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/

Arrow syntax - If you have multiple lines of code you need an explicit return statement

7 - MergeAll & SwitchLatest

8 - Netflix Search Box

9 - Optimizing The Search

10 - Three Dimension Collections


  
Section 3 - Creating Array Functions
1 - Exercises 1 - 5

2 - Exercises 6 - 11

3 - Exercise 12

4 - Exercises 13 - 14

5 - Exercises 15 - 17

6 - Exercises 18 - 19

7 - Exercise 20

8 - Exercises 21 - 23

9 - Exercise 24



Section 4 - Creating Trees
1 - Debugging Async

2 - SQL Comparison

3 - Exercise 25

4 - Exercise 26a

5 - Exercise 26b

6 - Exercise 27



Section 5 - Handling Events with Observables
1 - Exercises 28 - 30

2 - Exercise 31

3 - Observables And Events

4 - Anatomy Of An Observable

5 - Creating A setTimeout Observable

6 - Observables vs Promises

7 - Exercise 32

8 - Exercise 33



Section 6 - Handling HTTP Requests with Observables
1 - Exercise 34

2 - Searching Wikipedia

3 - JSONP as an Observable

4 - Composing a Stream

5 - Displaying AutoComplete Data

6 - distinctUntilChanged

7 - Catching Errors

8 - Handling Empty Searches

9 - Showing The Search Box

10 - Close Button Observable

11 - Completing The Close Button

13 - Audience Questions



Section 7 - Observable In Depth
1 - Creating an Observable Class

2 - Observable Map Function

3 - Observable Filter Function

4 - Using the Observable Class

5 - Observable Take Function

6 - Implementing A Better Object.observe

7 - Binding Between Views And Models

8 - Syncing Data with the Server

9 - Observables As Animations
