                    Professor Frisby Introduces Composable Functional JavaScript
                    Course Notes
                    
 
1 - Create linear data flow with container style types (Box)
Example Syntax
  // Each of the lines is doing something different the goal is to compose
  // a much more linear workflow
  const nextCharForNumberString = str => {
    const trmmed = str.trim();
    const number = parseInt(trimmed);
    const nextNumber = number + 1;
    return String.fromCharCode(nextNumber); 
  }
  
  // Using the same as above but with an array and helper
  // Each expression has its own self contained state
  const nextCharForNumberString = str =>
    (str)
    .map(s => s.trim())
    // A different s from above
    .map(s => parseInt(s))
    .map(r => new Number(r))
    .map(i => i + 1)
    .map(i => String.fromCharCode(i))
    .fold(c => c.toLowerCase())
 
 // Using box
 const Box = x =>
  ({
    map: f => Box(f(x)),
    // Fold will remove the value from the box
    fold: f => f(x),
    // Inspect will allow you to see what a structure is hoding when console.log is run
    inspect: () => `Box(${x})`
  })
 
  const result = nextCharForNumberString('64');
  console.log(result);
Map is not so much about iteration but composition within a context
Box is also known as the identity functor

2 - Refactor imperative code to a single composed expression using Box


3 - Enforce a null check with composable code branching using Either


4 - Use chain for composable error handling with nested Eithers


5 - A collection of Either examples compared to imperative code


6 - Create types with Semigroups


7 - Semigroup examples


8 - Ensure failsafe combination using monoids


9 - A curated collection of Monoids and their uses


10 - Unbox types with foldMap


11 - Delay Evaluation with LazyBox


12 - Capture Side Effects in a Task


13 - Use Task for Asynchronous Actions


14 - You've been using Functors


15 - Lift into a Pointed Functor with of


16 - You've been using Monads


17 - Build curried functions


18 - Applicative Functors for multiple arguments


19 - Apply multiple functors as arguments to a function (Applicatives)


20 - List comprehensions with Applicative Functors


21 - Write applicatives for concurrent actions


22 - Leapfrogging types with Traversable


23 - Maintaining structure whilst asyncing


24 - Principled type conversions with Natural Transformations


25 - Apply Natural Transformations in everyday work


26 - Isomorphisms and round trip data transformations


27 - Build a data flow for a real world app


28 - Retrieve and use data from an api with pure functional constructs


29 - Find the intersection of sets with Semigroups

