                    Professor Frisby Introduces Composable Functional JavaScript
                    Course Notes
                    
 


1 - Create linear data flow with container style types (Box)


2 - Refactor imperative code to a single composed expression using Box


3 - Enforce a null check with composable code branching using Either


4 - Use chain for composable error handling with nested Eithers


5 - A collection of Either examples compared to imperative code


6 - Create types with Semigroups


7 - Semigroup examples


8 - Ensure failsafe combination using monoids


9 - A curated collection of Monoids and their uses


10 - Unbox types with foldMap


11 - Delay Evaluation with LazyBox


12 - Capture Side Effects in a Task


13 - Use Task for Asynchronous Actions


14 - You've been using Functors


15 - Lift into a Pointed Functor with of


16 - You've been using Monads


17 - Build curried functions


18 - Applicative Functors for multiple arguments


19 - Apply multiple functors as arguments to a function (Applicatives)


20 - List comprehensions with Applicative Functors


21 - Write applicatives for concurrent actions


22 - Leapfrogging types with Traversable


23 - Maintaining structure whilst asyncing


24 - Principled type conversions with Natural Transformations


25 - Apply Natural Transformations in everyday work


26 - Isomorphisms and round trip data transformations


27 - Build a data flow for a real world app


28 - Retrieve and use data from an api with pure functional constructs


29 - Find the intersection of sets with Semigroups

