                    Professor Frisby Introduces Composable Functional JavaScript
                    Course Notes
                    
 
1 - Create linear data flow with container style types (Box)
Example Syntax
  // Each of the lines is doing something different the goal is to compose
  // a much more linear workflow
  const nextCharForNumberString = str => {
    const trmmed = str.trim();
    const number = parseInt(trimmed);
    const nextNumber = number + 1;
    return String.fromCharCode(nextNumber); 
  }
  
  // Using the same as above but with an array and helper
  // Each expression has its own self contained state
  const nextCharForNumberString = str =>
    (str)
    .map(s => s.trim())
    // A different s from above
    .map(s => parseInt(s))
    .map(r => new Number(r))
    .map(i => i + 1)
    .map(i => String.fromCharCode(i))
    .fold(c => c.toLowerCase())
 
 // Using box
 const Box = x =>
  ({
    map: f => Box(f(x)),
    // Fold will remove the value from the box
    fold: f => f(x),
    // Inspect will allow you to see what a structure is hoding when console.log is run
    inspect: () => `Box(${x})`
  })
 
  const result = nextCharForNumberString('64');
  console.log(result);
Map is not so much about iteration but composition within a context
Box is also known as the identity functor

2 - Refactor imperative code to a single composed expression using Box
Example Syntax
  const Box = x =>
  ({
    map: f => Box(f(x)),
    fold: f => f(x),
    inspect: () => `Box(${x})`
  })
  
  const moneyToFloat = str =>
    parseFloat(str.replace(/\$/g, ''))
                          // Using the box version of above
                          // Box un-nests expressions
                            const moneyToFloat = str =>
                              Box(str)
                              .map(str.replace(/\$/g, ''))
                              .map(r => parseFloat(r))


  const percentToFloat = str => {
    const replaced = str.replace(/\%g, '')
    const number = parseFloat(replaced)
    return number * 0.01
  }
                          // The box version of the above
                          // There are no stateful variables
                            const percentToFloat = str => {
                              Box(str.replace(/\%g, ''))
                              .map(replaced => parseFloat(replaced))
                              .map(number => number * 0.01)}


  const applyDiscount = (price, discount) => {
    const cost = moneyToFloat(price)
    const savings = percentToFloat(discount)
    return cost - cost * savings
  }
                          // The box version of above
                            const applyDiscount = (price, discount) => {
                              moneyToFloat(price)
                              .fold(
                                percentToFloat(discount)
                                  .fold(
                                    savings => cost - cost * savings
                                  )
                                ) 
                            }
                          
  const result = applyDiscount('$5.00', '20%')
  console.log(result)
Ensure that you remember how many layers you have mapped 

3 - Enforce a null check with composable code branching using Either


4 - Use chain for composable error handling with nested Eithers


5 - A collection of Either examples compared to imperative code


6 - Create types with Semigroups


7 - Semigroup examples


8 - Ensure failsafe combination using monoids


9 - A curated collection of Monoids and their uses


10 - Unbox types with foldMap


11 - Delay Evaluation with LazyBox


12 - Capture Side Effects in a Task


13 - Use Task for Asynchronous Actions


14 - You've been using Functors


15 - Lift into a Pointed Functor with of


16 - You've been using Monads


17 - Build curried functions


18 - Applicative Functors for multiple arguments


19 - Apply multiple functors as arguments to a function (Applicatives)


20 - List comprehensions with Applicative Functors


21 - Write applicatives for concurrent actions


22 - Leapfrogging types with Traversable


23 - Maintaining structure whilst asyncing


24 - Principled type conversions with Natural Transformations


25 - Apply Natural Transformations in everyday work


26 - Isomorphisms and round trip data transformations


27 - Build a data flow for a real world app


28 - Retrieve and use data from an api with pure functional constructs


29 - Find the intersection of sets with Semigroups

