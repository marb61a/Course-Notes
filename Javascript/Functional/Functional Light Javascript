                    Functional Light Javascript (v2)
                    Course Notes
                    
                    
                    Section 1 - Introduction
1 - Introduction
Brief intro to the course and the instructor


                    Section 2 - Functional Programming Introduction
1 - Functional Programming
An explanation of the title of the course
  - This is a refresh of an existing course
The word light is not meant to convey beginner or introductory
  - Functional Programming is not easy but the course is meant to ease some of the difficulty
The approach of the course will be from the bottom up rather than a lot of courses which are top down
Imperative vs Declaritive
  - Impertive code is code thhat focuses on how to accomplish a task
  - Declaritive code is code that focuses on what should happen
    - Declaritive code is easier to read and understand

2 - Provable and Readable
Provability is a key concept of functional programming
  - It uses concepts that have been tried and tested for many years
  - Using this should help developers know what works before testing
  - Provable code is easier to understand
  - Code that is not understood is code that should not be trusted
  - Code that has already been proven also means that there is less to read
  - Readers of code should trust that the code will work
  - Code structured better will help other developers and your future self
  - Abstraction should not be confused with encapsulation

3 - Pure Functions and Side-Effects
All functional programming should start with the function
  - Functions must be properly understood
  
Example Syntax
  // Not a function from a functional programming viewpoint
  function foo(x, y, z, w){
    console.log(x, y, z, w);
  }
  
  // This function may not be considered as a function either from a functional viewpoint as it is polluted
  // by using the foo function. An arbitrary collection of operations is correctly called a proceedure
  // ES6 syntax, default parameters and rest operator
  function bar(x = 2, ...args){
    // The spread operator here not the rest operator
    return foo(x, 42, ...args);
  }
  
  bar();                            // 2, 42, undefined, undefined
  bar(3, 8, 11);                    // 3, 42, 8, 11
  bar(...[6, 5]);                   // 6, 42, 5, undefined

Example Syntax
  // An example which does meet the criteria from a function viewpoint to be called a function
  function foo(x, y){
    // In a base sense to be considered as a proper function there must be a returned value
    return [x + 1, y - 1];
  }
  
  var [a, b] = foo(...[5, 10]);
  
  a;                                // 6
  b;                                // 9

Example Syntax
  // Javascript representation of a math equation f(x) = 2x2(squared) + 3
  function f(x) {
    return 2 * Math.pow(x, 2) + 3;
  }
  
Example Syntax
  // Although this may look like a function it is probably not due to using side effects
  // X is not passed into the function, it is an indirect input instead
  function f(){
    y = 2 * Math.pow(x, 2) + 3;
  }
  var x, y;
  x = 0;
  f();
  y;                                // 3
  
  x = 2;
  f();
  y;                                // 11

Side inputs should be avoided in applications as much as possible
  - This is because they can cause unforseen issues which will be very difficult to debug
  - Code should be optimised for readability instead of writeability
  - Side effects can affect how code is reasoned about
  - Redux in the React ecosystem makes extensive use of function programming priciples without using the terminology
  - If there are functions with side effects make sure that a reader knows where they are

4 - Purifying Functions
Example Syntax
  function f(x){
    return 2 * Math.pow(x, 2) + 3;
  }
  
  var y;
  y = f(0);                         // 3
  y = f(2);                         // 11
  y = f(-1);                        // 5

There are techniques available for minimising side effects where eliminating them is not an option
Example Syntax
  // Pure functions are functions without side effects
  // Pure function example
  function foo(x, y){
    return x + y;
  }
  
  // Impure function example, this is impure because of the variable z which is referenced
  // from outside of the function
  function bar(x, y){
    return x + y + z;
  }

Example Syntax
  // Purifying functions example

5 - Challenge 1: Purify a Function

6 - Challenge 1: Solution

7 - Evolving Understanding of Impurity



                    Section 3 - Managing Function Inputs
1 - Arguments

2 - No Points

3 - Challenge 2: Point-Free Style

4 - Challenge 2: Solution



                    Section 4 - Composing Functions
1 - Composition Introduction

2 - Challenge 3: Compose and Pipe Utility

3 - Challenge 3: Solution



                    Section 5 - Immutability
1 - Immutability Introduction

2 - Challenge 4: Compose and Pipe

3 - Challenge 4: Solution



                    Section 6 - Closure
1 - Closure and Side Effects

2 - Challenge 5: Purifying Closure

3 - Challenge 5: Solution



                    Section 7 - Partial Application
1 - Generalized to Specialized



                    Section 8 - Recursion
1 - Recursion Introduction

2 - Challenge 6: Recursive Operation

3 - Challenge 6: Solution

4 - Proper Tail Calls

5 - Continuation Passing Style

6 - Trampolines



                    Section 9 - Data Structures
1 - List Transformations

2 - Filter: Exclusion

3 - Reduce: Combining

4 - Challenge 7: Culmination Exercise

5 - Challenge 7: Solution

6 - Challenge 7: Solution 2

7 - Challenge 7: Solution 3

8 - Fusion

9 - Transducing



                    Section 10 - Data Structure Operations
1 - Data Structure Operations Introduction

2 - Challenge 8: Culmination Exercise 2

3 - Challenge 8: Solution



                    Section 11 - Functional Programming Utility
1 - FPO.js



                    Section 12 - Async Programming
1 - Lazy Arrays

2 - Challenge 9: Observables

3 - Challenge 9: Solution



                     Section 13 - Wrapping Up Functional JavaScript v2
1 - Wrapping Up
