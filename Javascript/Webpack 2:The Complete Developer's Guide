                    Webpack 2: The Complete Developer's Guide
                    Course Notes


                    Section 1 – How to Use This Course
1 - Start Here!
Quick intro to the course

2 - Links to Github Repos
There are a couple of different repos to link to 
  - Sample Project Code At -- https://github.com/StephenGrider/WebpackProject
  - Complete Code -- https://github.com/StephenGrider/WebpackCasts
Do not get the two confused


                    Section 2 – What Does Webpack Do?
1 - Why Do We Use Build Tools?
Why is Webpack becoming so popular?
Rich Web Applications - Web apps that have a lot of dynamic features
To understand Webpack popularity and why it is used it's necessary to understand the ecosystem
  - Server Side Templating
    - More of a legacy technology for creating web apps and showing HTML documents to users
    - In this world a backend server creates a HTML document and sends it to a user
    - The process is
      - User Visits Page -> HTTP Request To Server -> New HTML Doc -> User Clicks A Link -> HTTP Request To Server
      -> New HTML Doc
  - Single Page Application
    - This contrasts with the Server Side Templating world
    - The server in this case sends a bare boned HTML document to the user
    - Javasript runs on the users machine to assemble a webpage
    - The process here is
      - User Visits Page -> HTTP Req To Server -> New HTML Doc -> React\Angular Shows Page ->
                              User Clicks A Link -> React\Angular shows new content
 Over the last couple of years Single Page Applications have become very popular
 The reason for Webpack is that in an SPA world there is a huge amount of JS being assembled in the users browser

2 - Javascript Modules
When you have a lot of Javascript there can be issues
Working on large code bases split between only a couple of large files can be challenging
To address this issue of JS the notion of modules
Instead of having a small number of large JS files there will be many small files in the modular world
There is a middle line between these approaches
There can be issue with a modular approach

3 - The Purpose of Webpack
When using modules you need to understand fully the necessary loading order for modules
Incorrect load order can cause a lot of different problems
Having many JS files to load can be bad for performance especially on mobile devices
The purpose of Webpack is to take the big collection of tiny JS modules and merge into a big JS file while ensuring
that the correct loading order is maintained
As a side benefit Webpack can handle css files and turning ES6 in ES5 

4 - Webpack in Action
To demonstrate Webpack there will be 2 small modules built and linked with Webpack
  Syntax
    - mkdir js_modules      // makes a new directory for the project
    - cd js_modules         // Change into the project directory
    - npm init              // Initialises the npm package manager in the project
    - ls                    // This will show the package.json file generated from the npm init, it will show dependencies
    - Create a new folder src to hold the 2 modules that will be created
    - Create index.js and sum.js inside the src folder

5 - Javascript Module Syntax
Sum.js - Its purpose is to provide utility function for working with mathematical calculations
Index.js - It calls functions from sum.js then prints the result
The index file will depend on the sum file
Syntax sum.js
  // The course will be using ES6\2015 syntax 
  const sum = (a, b) => a + b;
  
The JS world has several differ rulesets for governing how modules behave
Some of the common module systems in place are
  - Common JS
    - Common syntax -- module.exports require
    - Implemented by node.js
  - AMD
    - Common syntax -- define, require
    - Ancronym for Asynchronous Module Definition
    - More commonly used in front end applications
  - ES2015
    - Common Syntax -- import, export
    - Modern web development is headed towards this

Syntax index.js

6 - Linking Files with CommonJS
Sum.js Syntax
  // Using CommonJS Syntax
  const sum = (a, b) => a + b;
  
  module.exports = sum;

Index.js Syntax
  const sum = require('./sum');
  
  const total = sum(10, 5);
  console.log(total);

7 - Webpack Installation and Configuration
There is a very specific version of Webpack used to install
  - npm install --save-dev webpack@2.2.0-rc.0
Webpack will need to be told which files to be used so a configuration file is put together to guide this process
  - The default name for the Webpack configuration file is webpack.config.js
  - When Webpack is run it will automatically look for a file of this name inside the project

Example webpack.config.js Syntax
  const config = {
    // Webpack cannot run the config file without an entry property
    // Traditionally in Webpack the entry point to an app is called index.js
    // The entry file forms the start of the module building process
    entry: './src/index.js'
  };
  
  module.exports = config;

8 - More on Webpack Configuration
Continuing with the example from the previous chapter
This time there will be the second of two compulsory properties
  - The output property

Example Syntax
  // Node helper for getting file path part of the node runtime
  const path = require('path');
  
  const config = {
    entry: './src/index.js',
    
    // The output property gives file name and path
    output: {
      // Output path must be full absolute path
      // Using path.resolve will allow it to generate path on any OS
      path: path.resolve(__dirname. 'build'),
      // By convention the output filename is usually bundle.js
      filename: 'bundle.js'
    }
  }
  
  module.exports = config;

9 - Running Webpack
Creating a script inside package.json file to run webpack
Example Syntax
  // In the section marked scripts
  // Double quotes on both sections are important
  "build": "webpack"
The author recommends againt installing webpack globally
  - Using the webpack in the script section will run the local copy in the node_modules folder
  - This approach allows for multiple versions of webpack
  - npm run build       // will run the webpack
In the example the generated bundle.js is far larger than the sum of the two files

10 - The Bundle.js File
An examination of the bundle file generated
This may be the most important section of the course
The course instructor has a customised version of bundle file that he has put together from
the generated one to showcase what is actually going on behind the scenes
Example Syntax
  var myModules = [
    function(){
      const sum = (a, b) => a + b;
      return sum
    },
    function(){
      const sum myModules[0]();
      const total = sum(10, 10);
      console.log(total);
    }
  ]
  
  var entryPointIndex = 1;
  myModules[entryPointIndex]();

There is no magic JS involved in webpack as it's code generated runs on multiple browsers of all types

11 - Running the App
To run the code inside the browser a single html file is created
  - It will load up the bundle and automatically render the code
Example Syntax
  index.html
  <html>
    <head>
    
    </head>
    <body>
      <script src="build/bundle.js"></script>
    </body>
  </html>



                    Section 3 – Handling Project Assets
1 - Introduction to Loaders
Module loaders are used to do some preprocessing on files before they are added to bundle.js file
They are commonly used for transpiling ES2015, CSS
  - EG Babel
Babel has support for multiple transpilations to ES5
There are 3 separate modules needed to get Babel working
  - babel-loader -- This teaches Babel how to work with Webpack
  - babel-core -- Knows how to take in code parse it and generate output files
  - babel-preset-env -- Ruleset for telling Babel exactly what pieces of ES6 code to look for and how to turn it into ES5
To install
  - npm install --save-dev babel-loader babel-core babel-preset-env 

2 - Babel Setup for ES2015
Loaders can be applied to any type of file
  - It does make sense to limit to certain types of files
Example Syntax
  const path = require('path');
  
  const config = {
    entry: './src/index.js',
    
    output: {
      path: path.resolve(__dirname. 'build'),
      filename: 'bundle.js'
    },
    // In Webpack 1 these preprocessing steps were called loaders
    // In Webpack 2 they are part of the module systems each loader is called a rule
    module: {
      rules: [
      ]
    }
  }
  
  module.exports = config;

3 - Babel Configuration
A continuation of the previous chapter
Example Syntax
  const path = require('path');
  
  const config = {
    entry: './src/index.js',
    
    output: {
      path: path.resolve(__dirname. 'build'),
      filename: 'bundle.js'
    },
    // In Webpack 1 these preprocessing steps were called loaders
    // In Webpack 2 they are part of the module systems each loader is called a rule
    module: {
      rules: [
        {
          use: 'babel-loader',
          // If the file ends is js then babel is applie due to the regex
          test: /\.js$/
        }
      ]
    }
  }
A new file is created .babelrc
.babelrc Syntax
  {
    // You need double inverted commas on both sides
    "presets": ["babel-preset-env"]
  }

4 - Refactor to ES2015 Modules
Example Syntax
  // Sum.js Syntax
  // Now using ES2015 Syntax
  const sum = (a, b) => a + b;
  
  export default sum;
  
  // Index.js Syntax
  import sum from './sum';
  
  const total = sum(10, 5);
  console.log(total);

5 - Handling CSS with Webpack
Example Syntax
  // image_viewer.js syntax
  const image = document.createElement('img');
  image.src = 'image url';
  
  document.body.appendChild(image);

  // Index.js Syntax
  import sum from './sum';
  import './image_viewer';
  
  const total = sum(10, 5);
  console.log(total);

6 - The Style and CSS Loaders
Example Syntax
  // CSS Files -> Created new styles directory and image_viewer.css file
  img{
    border: 10px solid black;
  }
  
  // image_viewer.js
  import '../styles/image_viewer.css';
  
  const image = document.createElement('img');
  image.src = 'image url';
  
  document.body.appendChild(image);
  
  // Webpack needs to be taught how to handle css files
  // There will be 2 additional modules installed
  // css-loader & style-loader
  // To install -> npm install --save-dev style-loader css-loader
  
  // Webpack config file
  const path = require('path');
  
  const config = {
    entry: './src/index.js',
    
    output: {
      path: path.resolve(__dirname. 'build'),
      filename: 'bundle.js'
    },
    module: {
      rules: [
        {
          use: 'babel-loader',
          test: /\.js$/
        },
        {
          use: ['style-loader', 'css-loader'],
          test: /\.css$/
        }
      ]
    }
  }

7 - Loaders are Tricky!
Using the dom browser as part of the developer tools
  - This shows that the CSS is being loaded in the head of the html
  - This has been injected by the style & css loaders
  - There is no connection between webpack and the css
  - It uses a module.push where the css is plain text
  - Webpack does not actually modify the html but adds code to the bundle file which tells the bundle file how to update
    the html document afer it has loaded
  - This may not agree with standards for handling css

8 - The Extract Text Plugin
This is an alternative approach for handling css to the previous section
There is a specific version of Webpack Text Extraction plugin used
  - npm install --save-dev extract-text-webpack-plugin@2.0.0-beta.4
  - This plugin will take a reference to a loader, run Webpack with it, take any text that was generated by that load
    save it into a separate file in the output directory
Example Syntax
  // Webpack config file
  const path = require('path');
  const ExtractTextPlugin = require('extract-text-webpack-plugin');
  
  const config = {
    entry: './src/index.js',
    
    output: {
      path: path.resolve(__dirname. 'build'),
      filename: 'bundle.js'
    },
    module: {
      rules: [
        {
          use: 'babel-loader',
          test: /\.js$/
        },
        {
          // loader & use are identical in the webpack world but loader is needed here
          loader: ExtractTextPlugin.extract({
            loader: 'css-loader'
          }),
          test: /\.css$/
        }
      ]
    },
    plugins: [
      new ExtractTextPlugin(style.css)
    ]
  }
  
9 - Handling Images with Webpack
Changing the image handling
  - images stored locally will load quicker
There are 2 new image loaders to be installed
  - image-webpack-loader & url-loader, image webpack-loader will automatically compress images
  npm install --save-dev image-webpack-loader  url-loader
Example Syntax
  // Webpack config file
  const path = require('path');
  const ExtractTextPlugin = require('extract-text-webpack-plugin');
  
  const config = {
    entry: './src/index.js',
    
    output: {
      path: path.resolve(__dirname. 'build'),
      filename: 'bundle.js'
    },
    module: {
      rules: [
        {
          use: 'babel-loader',
          test: /\.js$/
        },
        {
          loader: ExtractTextPlugin.extract({
            loader: 'css-loader'
          }),
          test: /\.css$/
        },
        {
          test: /\.(jpe?g|png|gif|svg)$/,
          use: [
            {
              loader: 'url-loader',
              options: { limit: 40000 }
            },
            'image-webpack-loader'
          ]
        }
      ]
    },
    plugins: [
      new ExtractTextPlugin(style.css)
    ]
  }

10 - Automatic Image Compression
New folder created -> assets
Site to source free images 
  - http://lorempixel.com
Example Syntax
  // image_viewer.js syntax
  import bigimage from 'big_image_path';
  import smallimage from 'small_image_path';
  import '../styles/image_viewer.css';
  
  const image = document.createElement('img');
  image.src = small;
  
  document.body.appendChild(image);
  
  const bigImage = document.createElement('img');
  bigImage.src = big;
  
  document.body.appendChild(bigImage);
  
  // The large image will be saved as a separate file
  // The small image will be encoded into the bundle file as a base64 string

11 - Public Paths
Example Syntax
  // Webpack config file
  const path = require('path');
  const ExtractTextPlugin = require('extract-text-webpack-plugin');
  
  const config = {
    entry: './src/index.js',
    
    output: {
      path: path.resolve(__dirname. 'build'),
      filename: 'bundle.js',
      // URL loader emits the url of the file with output.publicPath prepended to the url
      publicPath: 'build/'
    },
    module: {
      rules: [
        {
          use: 'babel-loader',
          test: /\.js$/
        },
        {
          loader: ExtractTextPlugin.extract({
            loader: 'css-loader'
          }),
          test: /\.css$/
        },
        {
          test: /\.(jpe?g|png|gif|svg)$/,
          use: [
            {
              loader: 'url-loader',
              options: { limit: 40000 }
            },
            'image-webpack-loader'
          ]
        }
      ]
    },
    plugins: [
      new ExtractTextPlugin(style.css)
    ]
  }



                    Section 4 – Building for Performance with Webpack
1 - Introduction to Code Splitting
This is the point of the course where the basics have been covered and advanced topics are introduced
Code Splitting is a very big part of Webpacks success
The course will be reusing the previous code to demonstrate code splitting
  - Then there will be another larger example used (React based)
Codesplitting - Webpack allows for bundle.js to be split and then decide programatically when to load
each separate piece

2 - Codesplitting in Practice
Using 2 files in the example for code splitting
  - index.js
    - Only this loads up until the user clicks a button at which point the image_viewer will load
  - image_viewer.js
Example Syntax
  // Wiped the existing index.js file
  const button = document.createElement('button');
  button.innerText = 'Click Me';
  // Do not use capital C 
  button.onclick = () =>{
  
  }
  
  document.body.appendChild(button);

3 - On Demand Code Loading
Example Syntax
  // index.js file
  const button = document.createElement('button');
  button.innerText = 'Click Me';

  button.onclick = () =>{
    // System is a global variable inside Javascript
    // It is part of the ES6 specification
    // If the image viewer had imports they would be pulled in too
    // This is Async code and returns a promise
    System.import('./image_viewer').then(module => {
      console.log(module)
    })
  }
  
  document.body.appendChild(button);
  
  // image_viewer files
  export default () => {
    import smallimage from 'small_image_path';
    import '../styles/image_viewer.css';

    const image = document.createElement('img');
    image.src = small;

    document.body.appendChild(image);
  }
  
4 - System Import Calls
A behind the scenes look at how the rebuilt example
  - This uses the console in the developer tools
  - Also using the network tab filtering for only JS files
    - When reloading the page  there is only a bundle.js file loaded
    - After clicking the button there is a file called 0.bundle.js loaded
The generated bundle.js file has much more text than previously
  - By using code spliting there will be JSONP callbacks added to load chunks
    - There is no magic behind the scenes in Webpack
  - There is also a list of modules
A quick run through the 0.bundle.js file
  - This has the logic on creating the image
This shows that our code is being split into 2 different files
  - Webpack looks for calls to System.import
Example Syntax
  // index.js file
  const button = document.createElement('button');
  button.innerText = 'Click Me';

  button.onclick = () =>{
    System.import('./image_viewer').then(module => {
      module.default();
    })
  }
Later example will use a much more real world example using code splitting for
  - React and React Router



                    Section 5 – Applying Webpack to a Real Project
1 - A Real World Project
Some features of Webpack will need to be tested on larger apps for a more effective learning experience
  - Some features will also only make sense on a larger app
The sample project to be used is located on GitHub at
  - https://github.com/StephenGrider/WebpackProject
  - It is a React JS project
  - Either clone or download as a zip file
    - git clone https://github.com/StephenGrider/WebpackProject.git
  - npm install to install the dependencies

2 - Setting Up Babel
Example Syntax
  var webpack = require('webpack');
  var path = require('path');
  
  module.exports = {
    entry: './src/index.js',
    output: {
      path: path.join(__dirname, 'dist'),
      filename: 'bundle.js'
    },
    ,
    module: {
      rules: [
        {
          use: 'babel-loader',
          test: /\.js$/,
          exclude: /node_modules/
        }
      ]
    }
  }

3 - Minimum Webpack Config

4 - Vendor Asset Caching

5 - More on Vendor Caching

6 - Refactoring for Vendor Splitting

7 - Effect of Code Splitting

8 - Troubleshooting Vendor Bundles

9 - Chunk Hashing for Cache Busting

10 - Cache Busting Wrapup

11 - Cleaning Project Files



                    Section 6 – Webpack Dev Server
1 - Introduction to Webpack Dev Server

2 - Gotchas with Webpack Dev Server



                    Section 7 – React-Specific Topics
1 - React Router with Codesplitting

2 - Plain Routes with React Router Codesplitting



                    Section 8 – Webpack-Based Deployment for Static Sites
1 - Deployment Options

2 - Getting Production Ready

3 - Deployment with Surge (Easiest!)

4 - Deployment with Github Pages

5 - Deployment with AWS S3



                      Secion 9 – Webpack-Based Deployment for Dynamic Sites
1 - Deployment of Servers

2 - Node and Webpack Integration

3 - Webpack Middleware in Development

4 - Webpack Middleware in Production

5 - Deployment to Heroku

6 - Deployment to AWS

7 - More on AWS Deployment

