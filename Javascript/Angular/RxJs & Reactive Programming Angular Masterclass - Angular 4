                    RxJs & Reactive Programming Angular Masterclass - Angular 4
                    Course Notes
                    
                    
                    Section 1 – Getting Started - Why a New Package Manager?
1 - Reactive Patterns Angular Architecture Course Helicopter View
Introduction to the course and instructor
The number 1 difficulty people have is with Reactive programming and observables
RXJS is a library which allows us to build Async using Observable pattern
The course will be a deep dive into the Observable
  - The course project will be built using non Observabes, they will then be introduce to showcase the beneifts
    that this particular approach will give
  - The main items discussed will be Observable\Observer and Subject

2 - Setting Up Your Environment - Node, Npm & Git, Which IDE to Choose ?

3 - How to Get the Most Out of the Questions and Answers Section ?

4 - Testing Our Tools Installation - Installing The Course Code

5 - The Yarn Package Manager - Why Should We Use It ?

6 - Scaffolding an Application Using the Angular CLI

7 - Setting Up A Small Application For Learning Reactive Patterns



                    Section 2 – Why Build Applications in Reactive Style ?
1 - Observable Pattern Section Introduction

2 - What Reactive Properties do Browser Events Have ?

3 - Browsers Events and Reactive Programming - Another Important Similarity

4 - Custom Application Events, the Observer Pattern - How Are They Related ?

5 - Building An Application Based on a Custom Event Bus

6 - Implementing a Global Event Bus From Scratch

7 - Finishing the Implementation of a Global Event Bus - Its That Simple

8 - Using The Global Event Bus To Broadcast Application Data

9 - Improve Global Event Bus - Add Support To Different Types of Application Events

10 - An Application Implemented in Non Reactive Style - What Does It Look Like ?

11 - Adding Features to An Event Bus Application - Complexity Breakpoint Reached ?

12 - Application Starts Not To Scale In Complexity - Who Owns Which Data ?

13 - Only One More Feature - Learn Why The Application is no Longer Maintainable



                    Section 3 – The Key Concept of Reactive Programming - The Observable Pattern
1 - Introducing the Observable Pattern

2 - Building Our Program Around Observable Data Streams

3 - A First Benefit of Building Asynchronous Applications in Reactive Style

4 - Starting To Tackle A Second Architectural Issue

5 - Implementing Our First Observable - An Unexpected Issue Occurs

6 - Fixing Our Observable Implementation, Introducing a New Pattern

7 - Is The Centralized Store a Reactive Pattern ?
05:05
Implementing Add Lesson - How To Ensure Encapsulation of Store Data
03:30
Refactoring Toggle And Delete Lesson - Avoiding Data Mutation On The View Layer
06:17
Application Working - Review Of The Benefits of Using a Reactive Approach
06:09
The Store And The Observable Patterns - How Are They Related ?
02:49
Introducing The RxJs Library - A Simple Explanation
06:37
Refactoring Our Application To Use RxJs
03:56
Introducing BehaviorSubject - When To Use It ?
06:29
Observable Pattern Conclusion And Introduction To Reactive Patterns Section
04:58
–
Reactive Patterns Catalog - Stateless Observable Services
56:59
Switch Branches - A Running Application With a Firebase Backend
Preview
05:34
See Firebase Hot Observables In Action - Review Of Router Configuration
03:52
An Application Written in Imperative Style - What Does It Look Like ?
09:13
Learn An RxJs Anti-Pattern While Reviewing the Imperative-Style Application
07:11
Introducing The Stateless Observable Service Pattern
05:02
Designing And implementing The API of a Stateless Observable Service
07:09
Separating The View and The Service Layer With An Observable-based API
04:45
Service Layer API Design - Short-Lived or Long-Lived Observables ?
05:12
Refactoring a Component From Imperative To Reactive Style
09:01
–
Smart vs Presentational Components Part I
10:04
Splitting Mixed Responsibility Component Into Smart + Presentational Components
Preview
05:30
Smart vs Presentational Components - What Are the Different Responsibilities ?
04:34
–
Observable Data Services
41:39
Observable Data Services - Introducing a New Refactoring Starting Point
Preview
06:33
Learn What Use Cases And Problems We Will Be Covering In This Section
02:46
Writing Our First Observable Data Services - API Design
09:14
Implementing The Login Functionality Using The User Observable Data Service
07:16
Implementing The User Service - Notice The Similarities
05:05
Redefining The API Of The User Observable Data Service
06:52
Observable Data Services - Conclusion and What's Next ?
03:53
–
Deeply Nested Smart Components / Component Design and On Push
23:12
Avoiding the RxJs Nested Subscribe Anti-Pattern
06:43
Identifying a Common Design Problem
05:58
Fixing the Event Bubbling Design Issue
04:58
Making Deeply Nested Smart Components Work With OnPush Change Detection
05:33
–
Implementing a Data Table Pagination Service
32:29
Switching Branches - Introducing a New HTTP Backend
Preview
04:55
Implementing the Lessons Pager Service - How to Design a Pagination Service
07:47
Implementing a Pager Service - Loading Data From The Backend
07:03
Finishing The Implementation Of The Data Pager Service - Whats Next ?
04:59
The Local Service Design Pattern - Leveraging the Angular DI System
07:45
–
The Master Detail Design Pattern With Cached Master Table
19:07
Switching Branches - The Master Detail Design Pattern With Cached Master Table
03:04
Master Detail Implementation - Implementing The Master Part
04:42
The Master Detail Pattern - Implementing The Detail Part
07:14
Master Detail With Cached Master Table Conclusion & How To Avoid Memory Leaks
04:07
–
Error Handling In Reactive Applications
25:56
Error Handling In Reactive Applications - Avoid This Pitfall While Using Subject
04:39
26 Implementing Error Handling While Using Observable Data Services
05:08
Implementing an Error Handling System - The Messages Service
05:31
Implementing an Error Handling System - The Messages Component
05:36
Local Services And Error Handling - What's Next ?
05:02
-
Router Data Pre-Fetching, Loading Indicator and Container Components
25:03
Switch Branches - Router Data Pre-Fetching And Loading Indicator
03:57
Implementing a Router Data Resolver - Introducing Typescript Tuple Types
04:23
Data Resolver Implementation - Advanced Use Of The RxJs switchMap Operator
05:31
Introducing A New Type Of Component - Container Components
04:00
Implementing A Router Loading Indicator
07:12
-
Leveraging Reactive Forms - Draft Pre-Saving
12:12
Switching Branches - Using Reactive Forms To Pre-Save a Form Draft
03:42
Reactive Forms - Draft Data Saving Implementation
08:30


                    Section 13 - Conclusion and Course Summary
1 - Conclusion and Course Summary

2 - Bonus Lecture: Learn More About The Angular University And My YouTube Channel

