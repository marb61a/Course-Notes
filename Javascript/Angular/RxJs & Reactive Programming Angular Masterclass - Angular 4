                    RxJs & Reactive Programming Angular Masterclass - Angular 4
                    Course Notes
                    
                    
                    Section 1 – Getting Started - Why a New Package Manager?
1 - Reactive Patterns Angular Architecture Course Helicopter View
Introduction to the course and instructor
The number 1 difficulty people have is with Reactive programming and observables
RXJS is a library which allows us to build Async using Observable pattern
The course will be a deep dive into the Observable
  - The course project will be built using non Observabes, they will then be introduce to showcase the beneifts
    that this particular approach will give
  - The main items discussed will be Observable\Observer and Subject

2 - Setting Up Your Environment - Node, Npm & Git, Which IDE to Choose ?
You will need to install and use the latest version of node
  - Yarn package manager will be used
The IDE used is Webstorm
  - https://www.jetbrains.com/webstorm/
The basis code for the course is available at 
  - Its important to have Git installed on your system
  - https://github.com/angular-university/reactive-patterns-course

3 - How to Get the Most Out of the Questions and Answers Section ?
How to get the best out of the Q & A section on the Udemy platform
  - Providing technical answers to other developers is a skill well worth learning
  - Where possible provide source code examples

4 - Testing Our Tools Installation - Installing The Course Code
You will have to either clone or download the zip file for source code from Github
Installing the @angular-cli package
  - npm install -g @angular/cli                       // ensure that there is a g option

5 - The Yarn Package Manager - Why Should We Use It ?
The course will use the Yarn package manager 
  - https://yarnpkg.com/en/
  - This package manager is from Facebook
Consistency of package installations is important
More information on Yarn vs NPM is available at
  - https://blog.risingstack.com/yarn-vs-npm-node-js-package-managers/
The instructor reckons that Yarn is superior to NPM
  - This is due to some race conditions in NPM that cause package installation issues
  - You also get deterministic builds which can be an issue with NPM due to semantic versioning and changes to packages
    - You are able to freeze Node dependencies
    - You are able to also freeze your entire dependency tree
      - You are able to use a similar feature in Node called shrinkwrap but not as deterministically as Yarn
  - Yarn is also designed with offline use in mind
    - This is important in environments such as enterprises where internet use maybe limited
  - Yarn.lock is the file which contains information about the dependency tree
    - This should not be edited directly

6 - Scaffolding an Application Using the Angular CLI
First thing necessary is to check node version to ensure it is above 7
  - node -v
Then check to ensure that @angular-cli is installed
  - ng --version
To scaffold a new @angular-cli application
  - ng new --skip-install app-name                   // The skip install directive prevents running npm install during setup
The example uses yarn to install the dependencies listed in the package.json file
  - yarn                                             // You do not need to have any arguments in this particular case
To run the example app                               // If using npm install it would be npm serve
  - npm start                                        // This runs on localhost:4200

!!!! Some platforms have issues with npm installation of @angular-cli
  Install yarn
    npm install yarn -g
  Use yarn to install angular-cli
    yarn global add angular-cli.

7 - Setting Up A Small Application For Learning Reactive Patterns
This is an optional lesson for students
  - It is for students who are coding along with the course
  - There are some minor tasks which need to be taken care of to completely setup the playground
    - The angular-cli.json file needs to be modified
      - app will be removed from the prefix setting
        - This means that the components will be generated with a selector that corresponds directly to the component
        - Otherwise there would be a prefix added to each component
  - To demonstrate browser events the aungular-cli will be used to scaffold a component
    - ng generate component browser-event-experiments
      - Again depending on the platform running ng can cause problems
      - This can be usually taken care of with npm update
      - Angular-cli was installed using yarn in this example
    - To check to see if generation was successful
      - npm start and go to localhost:4200
  
    

                    Section 2 – Why Build Applications in Reactive Style ?
1 - Observable Pattern Section Introduction
The goal of the section is to understand RxJS and reactive programming
  - Reactive programming is not magical or hard to understand
In this section 
  - There is going to be a small app built with techniques that predate Reactive style programming
  - In this sample app multiple components interact using a global event bus
  - This type of architecture does not scale well
  - There will be a deeper dive into the RxJS libraries as the course goes on
  - The first subject to be examined will be the observable pattern
  - Understanding the Observable pattern will allow more understanding RxJS
  - It is probably more beneficial to not learn RxJS straight away

2 - What Reactive Properties do Browser Events Have ?
The ideas behind reactive programming have been around for a very long time
  - These ideas are much more familiar than some might think
The example to be used is browser events
  - What in their behaviour and API is similar to reactive
Example Syntax
  // browser-event-experiments.component.ts
  import { Component, OnInit} from '@angular/core';
  
  @Component({
    selector: 'browser-event-experiments',
    templateUrl: './browser-event-experiments.component.html',
    styleUrls: ['./browser-event-experiments.component.css']
  })
  
  export class BrowserEventExperimentsComponent implements OnInit{
    constructor(){}
    
    ngOnInit(){
    
    }
  }
  
3 - Browsers Events and Reactive Programming - Another Important Similarity

4 - Custom Application Events, the Observer Pattern - How Are They Related ?

5 - Building An Application Based on a Custom Event Bus

6 - Implementing a Global Event Bus From Scratch

7 - Finishing the Implementation of a Global Event Bus - Its That Simple

8 - Using The Global Event Bus To Broadcast Application Data

9 - Improve Global Event Bus - Add Support To Different Types of Application Events

10 - An Application Implemented in Non Reactive Style - What Does It Look Like ?

11 - Adding Features to An Event Bus Application - Complexity Breakpoint Reached ?

12 - Application Starts Not To Scale In Complexity - Who Owns Which Data ?

13 - Only One More Feature - Learn Why The Application is no Longer Maintainable



                    Section 3 – The Key Concept of Reactive Programming - The Observable Pattern
1 - Introducing the Observable Pattern

2 - Building Our Program Around Observable Data Streams

3 - A First Benefit of Building Asynchronous Applications in Reactive Style

4 - Starting To Tackle A Second Architectural Issue

5 - Implementing Our First Observable - An Unexpected Issue Occurs

6 - Fixing Our Observable Implementation, Introducing a New Pattern

7 - Is The Centralized Store a Reactive Pattern ?

8 - Implementing Add Lesson - How To Ensure Encapsulation of Store Data

9 - Refactoring Toggle And Delete Lesson - Avoiding Data Mutation On The View Layer

10 - Application Working - Review Of The Benefits of Using a Reactive Approach

11 - The Store And The Observable Patterns - How Are They Related ?

12 - Introducing The RxJs Library - A Simple Explanation

13 - Refactoring Our Application To Use RxJs

14 - Introducing BehaviorSubject - When To Use It ?

15 - Observable Pattern Conclusion And Introduction To Reactive Patterns Section



                    Section 4 – Reactive Patterns Catalog - Stateless Observable Services
1 - Switch Branches - A Running Application With a Firebase Backend

2 - See Firebase Hot Observables In Action - Review Of Router Configuration

3 - An Application Written in Imperative Style - What Does It Look Like ?

4 - Learn An RxJs Anti-Pattern While Reviewing the Imperative-Style Application

5 - Introducing The Stateless Observable Service Pattern

6 - Designing And implementing The API of a Stateless Observable Service

7 - Separating The View and The Service Layer With An Observable-based API

8 - Service Layer API Design - Short-Lived or Long-Lived Observables ?

9 - Refactoring a Component From Imperative To Reactive Style



                    Section 5 – Smart vs Presentational Components Part I
1 - Splitting Mixed Responsibility Component Into Smart + Presentational Components

2 - Smart vs Presentational Components - What Are the Different Responsibilities ?



                    Section 6 – Observable Data Services
1 - Observable Data Services - Introducing a New Refactoring Starting Point

2 - Learn What Use Cases And Problems We Will Be Covering In This Section

3 - Writing Our First Observable Data Services - API Design

4 - Implementing The Login Functionality Using The User Observable Data Service

5 - Implementing The User Service - Notice The Similarities

6 - Redefining The API Of The User Observable Data Service

7 - Observable Data Services - Conclusion and What's Next ?



                    Section 7 – Deeply Nested Smart Components / Component Design and On Push
1 - Avoiding the RxJs Nested Subscribe Anti-Pattern

2 - Identifying a Common Design Problem

3 - Fixing the Event Bubbling Design Issue

4 - Making Deeply Nested Smart Components Work With OnPush Change Detection



                    Section 8 – Implementing a Data Table Pagination Service
1 - Switching Branches - Introducing a New HTTP Backend

2 - Implementing the Lessons Pager Service - How to Design a Pagination Service

3 - Implementing a Pager Service - Loading Data From The Backend

4 - Finishing The Implementation Of The Data Pager Service - Whats Next ?

5 - The Local Service Design Pattern - Leveraging the Angular DI System



                    Section 9 – The Master Detail Design Pattern With Cached Master Table
1 - Switching Branches - The Master Detail Design Pattern With Cached Master Table

2 - Master Detail Implementation - Implementing The Master Part

3 - The Master Detail Pattern - Implementing The Detail Part

4 - Master Detail With Cached Master Table Conclusion & How To Avoid Memory Leaks



                    Section 10 – Error Handling In Reactive Applications
1 - Error Handling In Reactive Applications - Avoid This Pitfall While Using Subject

2 - Implementing Error Handling While Using Observable Data Services

3 - Implementing an Error Handling System - The Messages Service

4 - Implementing an Error Handling System - The Messages Component

5 - Local Services And Error Handling - What's Next ?



                    Section 11 - Router Data Pre-Fetching, Loading Indicator and Container Components
1 - Switch Branches - Router Data Pre-Fetching And Loading Indicator

2 - Implementing a Router Data Resolver - Introducing Typescript Tuple Types

3 - Data Resolver Implementation - Advanced Use Of The RxJs switchMap Operator

4 - Introducing A New Type Of Component - Container Components

5 - Implementing A Router Loading Indicator



                     Section 12 - Leveraging Reactive Forms - Draft Pre-Saving
1 - Switching Branches - Using Reactive Forms To Pre-Save a Form Draft

2 - Reactive Forms - Draft Data Saving Implementation



                    Section 13 - Conclusion and Course Summary
1 - Conclusion and Course Summary

2 - Bonus Lecture: Learn More About The Angular University And My YouTube Channel

