                    RxJs & Reactive Programming Angular Masterclass - Angular 4
                    Course Notes
                    
                    
                    Section 1 – Getting Started - Why a New Package Manager?
1 - Reactive Patterns Angular Architecture Course Helicopter View
Introduction to the course and instructor
The number 1 difficulty people have is with Reactive programming and observables
RXJS is a library which allows us to build Async using Observable pattern
The course will be a deep dive into the Observable
  - The course project will be built using non Observabes, they will then be introduce to showcase the beneifts
    that this particular approach will give
  - The main items discussed will be Observable\Observer and Subject

2 - Setting Up Your Environment - Node, Npm & Git, Which IDE to Choose ?
You will need to install and use the latest version of node
  - Yarn package manager will be used
The IDE used is Webstorm
  - https://www.jetbrains.com/webstorm/
The basis code for the course is available at 
  - Its important to have Git installed on your system
  - https://github.com/angular-university/reactive-patterns-course

3 - How to Get the Most Out of the Questions and Answers Section ?

4 - Testing Our Tools Installation - Installing The Course Code

5 - The Yarn Package Manager - Why Should We Use It ?
The course will use the Yarn package manager 
  - https://yarnpkg.com/en/
  - This package manager is from Facebook
Consistency of package installations is important
More information on Yarn vs NPM is available at
  - https://blog.risingstack.com/yarn-vs-npm-node-js-package-managers/
The instructor reckons that Yarn is superior to NPM
  - This is due to some race conditions in NPM that cause package installation issues
  - You also get deterministic builds which can be an issue with NPM due to semantic versioning and changes to packages
    - You are able to freeze Node dependencies
    - You are able to also freeze your entire dependency tree
      - You are able to use a similar feature in Node called shrinkwrap but not as deterministically as Yarn
  - Yarn is also designed with offline use in mind
    - This is important in environments such as enterprises where internet use maybe limited
  - Yarn.lock is the file which contains information about the dependency tree
    - This should not be edited directly

6 - Scaffolding an Application Using the Angular CLI

7 - Setting Up A Small Application For Learning Reactive Patterns



                    Section 2 – Why Build Applications in Reactive Style ?
1 - Observable Pattern Section Introduction
The goal of the section is to understand RxJS and reactive programming
  - Reactive programming is not magical or hard to understand
In this section 
  - There is going to be a small app built with techniques that predate Reactive style programming
  - In this sample app multiple components interact using a global event bus
  - This type of architecture does not scale well
  - There will be a deeper dive into the RxJS libraries as the course goes on
  - The first subject to be examined will be the observable pattern
  - Understanding the Observable pattern will allow more understanding RxJS
  - It is probably more beneficial to not learn RxJS straight away

2 - What Reactive Properties do Browser Events Have ?

3 - Browsers Events and Reactive Programming - Another Important Similarity

4 - Custom Application Events, the Observer Pattern - How Are They Related ?

5 - Building An Application Based on a Custom Event Bus

6 - Implementing a Global Event Bus From Scratch

7 - Finishing the Implementation of a Global Event Bus - Its That Simple

8 - Using The Global Event Bus To Broadcast Application Data

9 - Improve Global Event Bus - Add Support To Different Types of Application Events

10 - An Application Implemented in Non Reactive Style - What Does It Look Like ?

11 - Adding Features to An Event Bus Application - Complexity Breakpoint Reached ?

12 - Application Starts Not To Scale In Complexity - Who Owns Which Data ?

13 - Only One More Feature - Learn Why The Application is no Longer Maintainable



                    Section 3 – The Key Concept of Reactive Programming - The Observable Pattern
1 - Introducing the Observable Pattern

2 - Building Our Program Around Observable Data Streams

3 - A First Benefit of Building Asynchronous Applications in Reactive Style

4 - Starting To Tackle A Second Architectural Issue

5 - Implementing Our First Observable - An Unexpected Issue Occurs

6 - Fixing Our Observable Implementation, Introducing a New Pattern

7 - Is The Centralized Store a Reactive Pattern ?

8 - Implementing Add Lesson - How To Ensure Encapsulation of Store Data

9 - Refactoring Toggle And Delete Lesson - Avoiding Data Mutation On The View Layer

10 - Application Working - Review Of The Benefits of Using a Reactive Approach

11 - The Store And The Observable Patterns - How Are They Related ?

12 - Introducing The RxJs Library - A Simple Explanation

13 - Refactoring Our Application To Use RxJs

14 - Introducing BehaviorSubject - When To Use It ?

15 - Observable Pattern Conclusion And Introduction To Reactive Patterns Section



                    Section 4 – Reactive Patterns Catalog - Stateless Observable Services
1 - Switch Branches - A Running Application With a Firebase Backend

2 - See Firebase Hot Observables In Action - Review Of Router Configuration

3 - An Application Written in Imperative Style - What Does It Look Like ?

4 - Learn An RxJs Anti-Pattern While Reviewing the Imperative-Style Application

5 - Introducing The Stateless Observable Service Pattern

6 - Designing And implementing The API of a Stateless Observable Service

7 - Separating The View and The Service Layer With An Observable-based API

8 - Service Layer API Design - Short-Lived or Long-Lived Observables ?

9 - Refactoring a Component From Imperative To Reactive Style



                    Section 5 – Smart vs Presentational Components Part I
1 - Splitting Mixed Responsibility Component Into Smart + Presentational Components

2 - Smart vs Presentational Components - What Are the Different Responsibilities ?



                    Section 6 – Observable Data Services
1 - Observable Data Services - Introducing a New Refactoring Starting Point

2 - Learn What Use Cases And Problems We Will Be Covering In This Section

3 - Writing Our First Observable Data Services - API Design

4 - Implementing The Login Functionality Using The User Observable Data Service

5 - Implementing The User Service - Notice The Similarities

6 - Redefining The API Of The User Observable Data Service

7 - Observable Data Services - Conclusion and What's Next ?



                    Section 7 – Deeply Nested Smart Components / Component Design and On Push
1 - Avoiding the RxJs Nested Subscribe Anti-Pattern

2 - Identifying a Common Design Problem

3 - Fixing the Event Bubbling Design Issue

4 - Making Deeply Nested Smart Components Work With OnPush Change Detection
05:33
–
Implementing a Data Table Pagination Service
32:29
Switching Branches - Introducing a New HTTP Backend
Preview
04:55
Implementing the Lessons Pager Service - How to Design a Pagination Service
07:47
Implementing a Pager Service - Loading Data From The Backend
07:03
Finishing The Implementation Of The Data Pager Service - Whats Next ?
04:59
The Local Service Design Pattern - Leveraging the Angular DI System
07:45
–
The Master Detail Design Pattern With Cached Master Table
19:07
Switching Branches - The Master Detail Design Pattern With Cached Master Table
03:04
Master Detail Implementation - Implementing The Master Part
04:42
The Master Detail Pattern - Implementing The Detail Part
07:14
Master Detail With Cached Master Table Conclusion & How To Avoid Memory Leaks
04:07
–
Error Handling In Reactive Applications
25:56
Error Handling In Reactive Applications - Avoid This Pitfall While Using Subject
04:39
26 Implementing Error Handling While Using Observable Data Services
05:08
Implementing an Error Handling System - The Messages Service
05:31
Implementing an Error Handling System - The Messages Component
05:36
Local Services And Error Handling - What's Next ?
05:02
-
Router Data Pre-Fetching, Loading Indicator and Container Components
25:03
Switch Branches - Router Data Pre-Fetching And Loading Indicator
03:57
Implementing a Router Data Resolver - Introducing Typescript Tuple Types
04:23
Data Resolver Implementation - Advanced Use Of The RxJs switchMap Operator
05:31
Introducing A New Type Of Component - Container Components
04:00
Implementing A Router Loading Indicator



                     Section 12 - Leveraging Reactive Forms - Draft Pre-Saving
1 - Switching Branches - Using Reactive Forms To Pre-Save a Form Draft

2 - Reactive Forms - Draft Data Saving Implementation



                    Section 13 - Conclusion and Course Summary
1 - Conclusion and Course Summary

2 - Bonus Lecture: Learn More About The Angular University And My YouTube Channel

