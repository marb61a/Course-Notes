                    Angular NgRx Store Masterclass
                    Course Notes


                    Section 1 – Introduction - The Flux Architecture
1 - Course Helicopter View
Introduction to the instructor
The course will teach how to build an application from top to bottom starting with an empty folder
  - This will use NgRx store and the store design pattern
  - The course will also teach about using the flux architecture and the problem it was designed to solve
  - Also the flux architecture and how it led to single store architectures like Redux and NgRx Store
  - There will be a reproduction of the same issue that was facing Facebook developers
    - This will be in conjunction with understanding the counter bug that affected Facebook
  - The application will be an example multi-user chat application
  - Reactive Programming techniques will also be used and taught throughout the course
There is a quick high level overview of the syllabus of the course
  - As soon as is practical NgRx dev tools will be introduced to help with debugging
  - IndexedDB integeration will be covered via the NgRxDB model
This is a full stack course
  - Covered will be designing a REST endpoint and what it would be like to go along with a single store application

2 - Quick Note About Asking Questions In The Help Forums
Some quick instructions on how to best use the question and answer section on Udemy
  - Again answering questions is a great way of learning
  - Providing technical answers to other developers is a skill in itself so should be practiced
  


                    Section 2 – Scaffolding the Chat Application - Gettting The Most Important Part Right
1 - Installing an IDE - Webstorm or Visual Studio Code
An overview of the 2 recommended IDE's for the course
  

2 - IMPORTANT: Using Yarn instead of NPM To Avoid Installation Issues
There is a discussion about using both Yarn and the @angular/cli at 
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/Angular/RxJs & Reactive Programming Angular Masterclass - Angular 4

3 - Scaffolding an Application Using the Angular CLI
Starting from an empty folder
  - Use the latest version of Node, not a lts version
  - Install Git, this is very important as the course has some pre-built items which shorten the course and are on GitHub
  - Install the Angular-Cli -- npm install -g @angular/cli
  - Use the Angular-Cli to setup a skeleton project -- npm init
  - To start a development server -- ng serve
  - This runs on port 4200
  - Copy the CSS links from the Github repository
  - Sample app will be a chat app

4 - Installing The Lodash Utility Library
At this point in the course there is a need for a library to manipulate data
The library chose for the course is Lodash which is a very popular library
  - https://lodash.com
  - This library will be used both on the client and the server
  - There are multiple ways of installing it but the course uses
    - npm install lodash --save
  - Once installed you can use it in any file in the application
    - to use the library import * as _ from 'lodash'
    - Using the underscore _ is standard practice for loadsh
  - Also it is recommended and in some cases necessary to install lodash type definitions
    - npm install @types/lodash

5 - Using the Angular CLI to Scaffold All Application Components
The basic structure of the application will be scaffolded
  - app.component.html will be arranged into a series of smart components
Example Syntax
  // app.component.html file
  <header class="l-header v-center-parent">
    <img class="v-center" routerLink="home" src="image source">
  </header>
  
  <div class="chatapp">
    <user-selection></user-selection>
    <thread-section></thread-section>
    <message-section></message-section>
  </div>
In order to use the angular-cli to generate scaffolds you must be in your project directory
  - ng g component user-selection
  - ng g component thread-section
  - ng g component message-section
    - Each component has a meassage which should display if generation was successful
  - ng g component thread-list
  - ng g component message-list
It is important to remove the "app-" from the selector

6 - What Should be put inside the Store ?
NgRx store is a state container
  - The main question is what type of state should be inside the store
The course will use Typescript to define to identify the different states in an app
  - We will see the state that is shared between the client and server, if any
  - Then will be defined a small in-memory database for testing purposes
If the data structures in an app are defined correctly then other code flows naturally
Any application will not recover from poor modelling, there will be a constant need for work arounds

7 - A Critical Notion For Any UI We Build - Model vs View Model
In the course we will also build the backend that goes with the app
  - There will be a JSON file that simulates a simple database
There needs to be created a shared folder
  - This will hold all the code that is shared between client and server
  - In this folder we will create another folder model to hold the very important model of the application
A view is the projection of a model, that can be the main mode, business model etc
Some of the items that will make up the application model in the example are
  - User\Participant in a chat discussion
  - A message thread which has a number of messsages from multiple users
  - Read\Unread messages
  - A single message
This will form the main model of the app
A data base will typically store the most normalised form of that domain model
  - This is especially true of SQL based databases
The course will use Typescript to define types in both the main model and the view model

8 - Using Typescript Custom Types To Define The Application Model
The model will be defined in the shared folder because it is shared between client and server
Example Syntax
  // The participant.ts file will be the simplest model file
  // All custom types creadted in the course will be interfaces
  export interface Participant{
    // These are both mandatory properties
    id:number;
    name:string;
  }
  
  // message.ts model 
  export interface Model{
    id:number;
    threadId:number;
    participantId:number;
    text:string;
    timestamp:number;
  }
  
  // thread.ts model
  export interface Thread{
    id:number;
    messageIds:number[];
    // This is a map to enable to keep track of unread messages per user
    participants:{[key:number]:number};
  }

9 - Implement a Simple In-Memory Database, Learn What Goes Inside a Store
Using the models defined above to simulate a database
  - The database will just be an in-memory object
  - Create a new folder server
  - The server folder will contain a REST API
Example Syntax
  // db-data.ts
  

10 - First HTTP Call - What is a Transfer Object ?



                    Section 3 – Introducing A Store Solution - The Ngrx Store, Actions And Reducers
1 - Store Concepts Introduction
This section covers the introduction of the ngRx store library
  - A store is regarded as being an observable of application state
  - The section will cover actions, dispatcher, reducers
  - ngRx is similar to Redux
  - The problem being solved is that several parts of the UI display the same data
    - The list, different views etc are representations of the same data
  - The application is not read-only so the server is updating regularly

2 - How To Switch Git Branches During The Course
A quick lesson on checking out the branches for the course from GitHUb
There are extensive notes on how to use Github available at
  - https://github.com/marb61a/Course-Notes/blob/master/General Development/The definitive, step-by-step guide to Git

3 - Getting a REST API Server Running


4 - Installing A Store Solution

5 - Defining The Store Application State - How Many Types Of State Are Th

6 - The Store as an Observable of Application State

7 - Dispatching Our First Store Action

8 - Setting The Store Initial State - Debugging First Action Dispatch

9 - Writing Our First Reducer Function Step By Step

10 - Summary Of How a Store, Actions and Reducers Work



                    Section 4 – Implementing The Thread Section View Using Reactive Programming
1 - Smart Components and Reactive Programming Techniques - Introduction
In this section the first smart component of the application will be built start to finish
Presentational Components are components 
  - That take input data and render it on the screen
  - They render the data and transform it into HTML
  - These compnents can also report back events
  - This type of component also has no idea where the data comes from, nor should they
  - In the sample application an example of this type of component is the ThreadList or MassageList component
Top level Smart Components are sometimes referred to container components
  - These components are aware of backend services and know what data is to be fetched and where to fetch it
  - They have injected in their constructor either the store or thread service
It is best not to get bogged down in differences as it is best to define components according to each situation

2 - Building the Thread Section Using Reactive Programming
Example Syntax
  // The thread-section.component.ts file
  // This will be built using Reactive Programming standards
    import { Component, OnInit } from '@angular/core';
    import { ThreadsService } from "../services/threads.service";
    import { Store } from "@ngrx/store";
    import { ApplicationState } from "../store/application-state";
    import { LoadUserThreadsAction } from "../store/actions";
    
    @Component({
      selector: 'thread-section',
      templateUrl: './thread-section.component.html',
      styleUrl: './thread-section.component.css'
    })
    
    export class ThreadSectionComponent implements OnInit{
      constructor(private threadsService: ThreadsService, private store: Store<ApplicationState>){
        store.subscribe(
          state => console.log()'thread section received state', state;
        )
      }
      
      ngOnInit(){
      
      }
    }

3 - See How Simple It Is To Implement An Unread Messages Counter Using A Store

4 - A Simple Way To Debug An Angular Program

5 - Defining a View Model - Difference Between View Model and Model

6 - Refactoring the Thread Section Component - Extracting Mapping Functions

7 - Writing The Thread Summaries Selector

8 - Implementing our First Presentational Component - The Thread List Component

9 - Refactoring The Selector Functions of The Thread Section Component

10 - Best Practices for Writing Selector Functions



                    Section 5 – Ngrx Effects and the NgRx Dev Tools
1 - Ngrx Effects and DevTools Introduction

2 - Simplifying Smart Components - The Ngrx Effects Library

3 - Understanding the NgRx @Effect Decorator - How to Use It ?

4 - The Added Value Of Ngrx Effects and How It Simplifies Smart Components

5 - The Ngrx Store DevTools and the Time Travelling Debugger

6 - How to Debug RxJs Code ?

7 - A Simple RxJs Debugging Utility



                    Section 6 – Implementing the Message Section Smart Component
1 - Selecting A Thread - Initial Implementation

2 - Understanding Combine Reducers

3 - Writing The Reducing Logic of Select Thread Action

4 - Introducing the Message Section Component

5 - Message Section - Reviewing the Implementation of the Name List Selector

6 - Review of The Messages List Implementation - View to View Model Mapping

7 - Implementation of the Highlight Selected Thread Functionality

8 - Implementation of the Change Selected User Smart Component

9 - Change User Effect Implementation - An Example of a Chain Of Actions

10 - Change Current User Implementation - Backend and Frontend

11 - Implementing the Send New Message Chat Functionality

12 - Implementation of the Send New Message Reducer

13 - Scrolling the Message List To the Bottom Automatically Using OnChanges



                  Section 7 – Getting The Chat Functionality Up and Running !
1 - Solving the Facebook Counter Problem - Section Introduction

2 - Implementing The Write New Message Effect Using Ngrx Effects

3 - Send New Message Implementation - Client Part

4 - New Server Branch - View Send New Message In Action

5 - Refresh Chat Messages Side Effect Implementation

7 - Fetch New Messages - Implementing the Reducer Logic

8 - Finish Implementing the Refresh Messages HTTP Service

9 - Implementing The unread Messages Counter Reducing Logic

10 - Unread Message Counter - See The Solution for The Facebook Counter Issue

11 - Marking Threads With New Messages As Unread

12 - Implementing the Mark Messages As Read Reducer Logic

13 - Mark Threads as Read - Demo of The Nearly Completed Chat

14 - Implementing The Mark Messages As Read Side-Effect

15 - Chat Wrap Up - Summary Of The Advantages Of Store Architectures



                    Section 8 – Finishing Up - Error Handling, Router Integration, Ngrx Store Freeze
1 - Error Handling With Ngrx Store - How To Use The RxJs Catch Operator

2 - Implementing the Error Handling Reducer Logic

3 - Displaying Errors On the Screen - Implementing the Messages Smart Component

4 - Immutability In Reducer Functions - How to Use the Ngrx Store Freeze Library

5 - Adding the Angular Router to the Chat Application

6 - Ngrx Store Router Integration - Time-Travelling with the Dev Tools



                    Section 9 – Performance Tuning - Immutability and OnPush Change Detection
1 - OnPush Change Detection and Immutability - What Are the Advantages ?

2 - Why Freezing Selector Output Does Not Help Leverage OnPush Change Detection

3 - Understanding How OnPush Change Detection Works And How To Leverage It

4 - How To Write Reducers That Leverage OnPush Change Detection

5 - Refactoring Remaining Reducers - Will This Be Enough To Leverage OnPush ?

6 - Introducing a New Functional Programming Concept - Memoization

7 - Introducting The Reselect Library - How To Create a Memoized Selector

8 - How To Write a Memoized Selector With Reselect - What is The Advantage ?

9 - Using the Lodash Memoize Utility To Optimize View Rendering

10 - Preventing Message Re-Renderings Using a Presentational Component

11 - On Push Change Detection Summary - Smart Vs Presentational Components

12 - High-Level Overview of The ImmutableJs Library

13 - Course Summary and Conclusions



                    Section 10 – Building A Development Server
1 - Building The Get All User Data REST API From A to Z

2 - Running And Debugging Our ts-node Development Server

3 - Calling Our REST API Server From the Client - Configuring the Angular CLI

