                    Angular NgRx Store Masterclass
                    Course Notes


                    Section 1 – Introduction - The Flux Architecture
1 - Course Helicopter View
Introduction to the instructor
The course will teach how to build an application from top to bottom starting with an empty folder
  - This will use NgRx store and the store design pattern
  - The course will also teach about using the flux architecture and the problem it was designed to solve
  - Also the flux architecture and how it led to single store architectures like Redux and NgRx Store
  - There will be a reproduction of the same issue that was facing Facebook developers
    - This will be in conjunction with understanding the counter bug that affected Facebook
  - The application will be an example multi-user chat application
  - Reactive Programming techniques will also be used and taught throughout the course
There is a quick high level overview of the syllabus of the course
  - As soon as is practical NgRx dev tools will be introduced to help with debugging
  - IndexedDB integeration will be covered via the NgRxDB model
This is a full stack course
  - Covered will be designing a REST endpoint and what it would be like to go along with a single store application

2 - Quick Note About Asking Questions In The Help Forums
Some quick instructions on how to best use the question and answer section on Udemy
  - Again answering questions is a great way of learning
  - Providing technical answers to other developers is a skill in itself so should be practiced
  


                    Section 2 – Scaffolding the Chat Application - Gettting The Most Important Part Right
1 - Installing an IDE - Webstorm or Visual Studio Code
An overview of the 2 recommended IDE's for the course
  

2 - IMPORTANT: Using Yarn instead of NPM To Avoid Installation Issues
There is a discussion about using both Yarn and the @angular/cli at 
  - https://github.com/marb61a/Course-Notes/blob/master/Javascript/Angular/RxJs & Reactive Programming Angular Masterclass - Angular 4

3 - Scaffolding an Application Using the Angular CLI

4 - Installing The Lodash Utility Library
At this point in the course there is a need for a library to manipulate data
The library chose for the course is Lodash which is a very popular library
  - https://lodash.com
  - This library will be used both on the client and the server
  - There are multiple ways of installing it but the course uses
    - npm install lodash --save
  - Once installed you can use it in any file in the application
    - to use the library import * as _ from 'lodash'
    - Using the underscore _ is standard practice for loadsh
  - Also it is recommended and in some cases necessary to install lodash type definitions
    - npm install @types/lodash

5 - Using the Angular CLI to Scaffold All Application Components

6 - What Should be put inside the Store ?
NgRx store is a state container
  - The main question is what type of state should be inside the store
The course will use Typescript to define to identify the different states in an app
  - We will see the state that is shared between the client and server, if any
  - Then will be defined a small in-memory database for testing purposes
If the data structures in an app are defined correctly then other code flows naturally
Any application will not recover from poor modelling, there will be a constant need for work arounds

7 - A Critical Notion For Any UI We Build - Model vs View Model
In the course we will also build the backend that goes with the app
  - There will be a JSON file that simulates a simple database
There needs to be created a shared folder
  - This will hold all the code that is shared between client and server
  - In this folder we will create another folder model to hold the very important model of the application
A view is the projection of a model, that can be the main mode, business model etc
Some of the items that will make up the application model in the example are
  - User\Participant in a chat discussion
  - A message thread which has a number of messsages from multiple users
  - Read\Unread messages
  - A single message
This will form the main model of the app
A data base will typically store the most normalised form of that domain model
  - This is especially true of SQL based databases
The course will use Typescript to define types in both the main model and the view model

8 - Using Typescript Custom Types To Define The Application Model

9 - Implement a Simple In-Memory Database, Learn What Goes Inside a Store

10 - First HTTP Call - What is a Transfer Object ?



                    Section 3 – Introducing A Store Solution - The Ngrx Store, Actions And Reducers
1 - Store Concepts Introduction

2 - How To Switch Git Branches During The Course

3 - Getting a REST API Server Running

4- Installing A Store Solution

5 - Defining The Store Application State - How Many Types Of State Are Th

6 - The Store as an Observable of Application State

7 - Dispatching Our First Store Action

8 - Setting The Store Initial State - Debugging First Action Dispatch

9 - Writing Our First Reducer Function Step By Step

10 - Summary Of How a Store, Actions and Reducers Work



                    Section 4 – Implementing The Thread Section View Using Reactive Programming
1 - Smart Components and Reactive Programming Techniques - Introduction

2 - Building the Thread Section Using Reactive Programming

3 - See How Simple It Is To Implement An Unread Messages Counter Using A Store

4 - A Simple Way To Debug An Angular Program

5 - Defining a View Model - Difference Between View Model and Model

6 - Refactoring the Thread Section Component - Extracting Mapping Functions

7 - Writing The Thread Summaries Selector

8 - Implementing our First Presentational Component - The Thread List Component

9 - Refactoring The Selector Functions of The Thread Section Component

10 - Best Practices for Writing Selector Functions



                    Section 5 – Ngrx Effects and the NgRx Dev Tools
1 - Ngrx Effects and DevTools Introduction

2 - Simplifying Smart Components - The Ngrx Effects Library

3 - Understanding the NgRx @Effect Decorator - How to Use It ?

4 - The Added Value Of Ngrx Effects and How It Simplifies Smart Components

5 - The Ngrx Store DevTools and the Time Travelling Debugger

6 - How to Debug RxJs Code ?

7 - A Simple RxJs Debugging Utility



                    Section 6 – Implementing the Message Section Smart Component
1 - Selecting A Thread - Initial Implementation

2 - Understanding Combine Reducers

3 - Writing The Reducing Logic of Select Thread Action

4 - Introducing the Message Section Component

5 - Message Section - Reviewing the Implementation of the Name List Selector

6 - Review of The Messages List Implementation - View to View Model Mapping

7 - Implementation of the Highlight Selected Thread Functionality

8 - Implementation of the Change Selected User Smart Component

9 - Change User Effect Implementation - An Example of a Chain Of Actions

10 - Change Current User Implementation - Backend and Frontend

11 - Implementing the Send New Message Chat Functionality

12 - Implementation of the Send New Message Reducer

13 - Scrolling the Message List To the Bottom Automatically Using OnChanges



                  Section 7 – Getting The Chat Functionality Up and Running !
1 - Solving the Facebook Counter Problem - Section Introduction

2 - Implementing The Write New Message Effect Using Ngrx Effects

3 - Send New Message Implementation - Client Part

4 - New Server Branch - View Send New Message In Action

5 - Refresh Chat Messages Side Effect Implementation

7 - Fetch New Messages - Implementing the Reducer Logic

8 - Finish Implementing the Refresh Messages HTTP Service

9 - Implementing The unread Messages Counter Reducing Logic

10 - Unread Message Counter - See The Solution for The Facebook Counter Issue

11 - Marking Threads With New Messages As Unread

12 - Implementing the Mark Messages As Read Reducer Logic

13 - Mark Threads as Read - Demo of The Nearly Completed Chat

14 - Implementing The Mark Messages As Read Side-Effect

15 - Chat Wrap Up - Summary Of The Advantages Of Store Architectures



                    Section 8 – Finishing Up - Error Handling, Router Integration, Ngrx Store Freeze
Error Handling With Ngrx Store - How To Use The RxJs Catch Operator
06:02
Implementing the Error Handling Reducer Logic
02:27
Displaying Errors On the Screen - Implementing the Messages Smart Component
06:43
Immutability In Reducer Functions - How to Use the Ngrx Store Freeze Library
05:22
Adding the Angular Router to the Chat Application
06:42
Ngrx Store Router Integration - Time-Travelling with the Dev Tools
05:50
–
Performance Tuning - Immutability and OnPush Change Detection
01:23:08
OnPush Change Detection and Immutability - What Are the Advantages ?
07:36
Why Freezing Selector Output Does Not Help Leverage OnPush Change Detection
04:20
Understanding How OnPush Change Detection Works And How To Leverage It
04:19
How To Write Reducers That Leverage OnPush Change Detection
11:36
Refactoring Remaining Reducers - Will This Be Enough To Leverage OnPush ?
09:13
Introducing a New Functional Programming Concept - Memoization
06:41
Introducting The Reselect Library - How To Create a Memoized Selector
02:58
How To Write a Memoized Selector With Reselect - What is The Advantage ?
07:52
Using the Lodash Memoize Utility To Optimize View Rendering
07:47
Preventing Message Re-Renderings Using a Presentational Component
05:41
On Push Change Detection Summary - Smart Vs Presentational Components
02:08
High-Level Overview of The ImmutableJs Library
05:23
Course Summary and Conclusions
07:34
–
Building A Development Server
30:29
Building The Get All User Data REST API From A to Z
19:32
Running And Debugging Our ts-node Development Server
06:00
Calling Our REST API Server From the Client - Configuring the Angular CLI
03:39
Bonus Lecture: Learn More About The Angular University And My YouTube Channel
01:18
