                    AngularJS Data Modelling
                    Course Notes
                    
                    
1 - Using Resource For Data Models
Example Syntax
  // Building a POST model
  angular.module('app')
    .provider('Post', function(){
      this.$get = ['$resource', function($resource){
        var Post = $resource('http://localhost:3000/api/post/:_id', {}, {
          // No update method out of the box
          update: {
            method: 'PUT'
          }
        })
        
        function Post(attributes){
          this.$save = new postmethods().save();
        }
        
        Post.query = postmethods.query;
        Post.update = postmethods.update;
        Post.delete = postmethods.delete;
        
        // Returns the model
        return Post;
      }];
    });

  // Controller
  angular.module('app')
    .controller('MainCtrl, ['$scope', '$route', 'Post', 
      function('$scope', '$route', 'Post'){
        $scope.post = new Post();
        // Queries the backend for posts
        $scope.posts = Post.query();
        
        $scope.newPost = function(){
          $scope.post = new Post();
          $scope.editing = false;
        }
        
        $scope.activePost = function(){
          $scope.post = new Post();
          $scope.editing = true;
        }
        
        $scope.save = function(){
          if($scope.post._id){
            Post.update({_id: $scope.post._id}, $scope.post)
          } else {
            $scope.post.$save().then(function(response){
              $scope.posts.push(response);
            })
          }
          $scope.editing = false;
          $scope.post = new Post();
        }
        
        // Another function to be added to the DOM
        $scope.delete = function(post){
          Post.delete(post);
          // Using Lodaash to remove post but in real applications it should not be done without a
          // response from the backend
          _.remove($scope.posts, post);
        }
      }
    ])
The future videos will show how to create a more robust ORM

2 - Create A Model Base Class

3 - Model Caching

4 - Add Caching To The Model Base Class

5 - Refactor The Model Base Class With Mixins

6 - Model Validation Design Review

7 - Basic Implementation Of Configurable Validations

8 - Adding Child Validators

9 - Validations Class

10 - Mixing In Validatable

11 - Errorable Mixin

12 - Finishing Validatable

13 - Serializing And Deserializing Data Models In AngularJS
