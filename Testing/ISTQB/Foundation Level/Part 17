                    ISTQB Certified Tester Foundation Level
                    Course Notes Part 17


Component and Integation Testing
  - In advanced software development models testing is an elaborate activity and is performed at four levels.
  - Dividing the testing activity into these levels helps you efficiently manage and control the activity.
  - Component and integration testing help locate code-related defects 
    - It also helps determine whether the various code segments interact with each other as intended.
  - You perform component and integration testing during the early stages of software development. 
  - Component testing helps to identify errors in each component, such as an object, program, or module, o
    - After the code for a component is written, it can be tested by the original developer, 
    - The involvement of another developer brings objectivity and independence to the component-testing process.
  - During component testing, you don't maintain a formal record of defects. 
    - To avoid oversights later, you or the designated tester should fix all errors as soon as you detect them.
  - A common approach to component testing is the test-first approach, which is an iterative process. 
    - According to this approach, you create test cases before you start developing and testing code. 
    - To create the test cases, you use the specifications documents and the blueprint for the software application.
  - While testing the code of a component, you may also need to check whether the code correctly responds to or calls other components. 
    - However, sometimes, you may not have immediate access to these other components.
  - To check whether a software component can respond to or call other components, you create two temporary components:
  - Stubs
      - Stubs simulate called components. While testing a software component in isolation, you use a stub in place of each 
      - called component. For example, if an component calls an object that is not yet ready, you can use a stub in place of the object.
  - Drivers
      - During component testing, you may also have to create simulated components or test tools known as drivers. 
      - A driver acts as a substitute for a component that calls the component being tested. 
  - A nonfunctional requirement is one that isn’t related to functionality, but to an attribute such as usability, portability etc
  - During component testing, you also test the robustness of a component. 
  - After successful component testing, you move on to integration testing. 
    - At this test level, you determine whether software components interact with each other as intended.
  - During integration testing, you also verify whether the software components interact correctly with hardware and software, such as an operating system. 
    - This level of testing is also known as component integration testing and is typically conducted by either developers or integrators.
  - You can also conduct an integration test after the system-testing process. 
    - At this stage, you refer to integration testing as system integration testing. 
    - This type of testing helps you accurately analyze the interactions between a complete software product and other software systems.

During component and system integration testing, you can test the nonfunctional characteristics of the integrated components and systems. For example, after integration, two components may use a single system resource at the same time. This can negatively affect the performance of the components. You can check for such performance degradation during component integration testing.

Before you plan for and perform integration testing, you should choose an integration strategy. This strategy helps you decide the order in which you integrate the components of a software application. The order depends on the number and types of bugs you expect the application to have.

Based on the integration strategy you choose, you can adopt one of two methods to conduct integration testing:

big-bang integration testing
    You perform big-bang (or non-incremental, as it is formally known) integration testing on a fully integrated system. You should use this method of testing only if you plan to integrate the software components first and then test the resulting system. Bang-bang integration testing proves successful if the components have few and uncomplicated bugs.
    Description of the big-bang integration testing animation:
    The animation depicts the pieces of a jigsaw puzzle being assembled to complete the image of a car.
    Description ends. 
incremental integration testing
    Incremental integration testing is opposite to the big-bang method. In this type of testing, you gradually build and test the system on a component-by-component basis. For example, you test the interactions between any two components before you integrate and test additional components.
    Description of the incremental integration testing animation:
    The animation depicts the pieces of a jigsaw puzzle being assembled one-by-one to complete the image of a car.
    Description ends. 

Both integration testing methods have their advantages and disadvantages.

Big-bang integration testing ensures that you don't require stubs and drivers to simulate missing components. Yet this method is time consuming because it involves testing an entire system. While conducting such tests, you may be unable to identify the cause of defects quickly.

Additionally, big-bang integration testing allows you to detect defects only late in the development process. Fixing defects at this late stage can considerably increase the defects and expenses of the project, leading to budget overruns.

The advantage of incremental integration testing is that you start testing on a small scale. For example, you first test the interaction between two or three components. This increases your chance of isolating defects.

However, when you conduct tests using incremental integration testing, you need to use stubs and drivers to substitute for missing components. Creating the stubs and drivers can be time consuming, increasing the cost and effort involved in the test process.

In most cases, incremental integration testing is preferable to big-bang integration testing because the advantages of incremental integration testing outweigh the disadvantages.

You can divide incremental integration testing into two types:

top-down integration testing
    Top-down integration testing involves testing the external features of a software application first and then gradually integrating and testing the internal components. For example, you start by testing the interactions of the graphical user interface (GUI), which isn't called by any other component. If the components the GUI calls aren't ready, you use stubs to simulate them. When you receive the missing components, you perform integration testing on them.

    The advantage of top-down integration testing is that you don't need to create drivers. Also, this type of testing helps you easily identify and fix defects in the design of your software application. However, additional effort is required to create stubs.
bottom-up integration testing
    In bottom-up integration testing, you first test the component at the lowest level in the software application. This would be the component that doesn’t call any other components. You can use drivers to simulate the components that call this component. Similarly, you progressively build the application and test the higher-level components.

    This method helps you test the interactions between software components more effectively than the top-down method.

Static Techniques and Test Designing Software Testing
  -

Black-box Sofware Testing Techniques
  -

White-box Sofware Testing Techniques
  -

Software Test Management
  -                   
  
