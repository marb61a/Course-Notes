                    ISTQB Certified Tester Foundation Level
                    Course Notes Part 17


Component and Integation Testing
  - In advanced software development models testing is an elaborate activity and is performed at four levels.
  - Dividing the testing activity into these levels helps you efficiently manage and control the activity.
  - Component and integration testing help locate code-related defects 
    - It also helps determine whether the various code segments interact with each other as intended.
  - You perform component and integration testing during the early stages of software development. 
  - Component testing helps to identify errors in each component, such as an object, program, or module, o
  After the code for a component is written, it can be tested by the original developer, 
  or passed for testing to another developer. 
  The involvement of another developer brings objectivity and independence to the component-testing process.

During component testing, you don't maintain a formal record of defects. So to avoid oversights later, you or the designated tester should fix all errors as soon as you detect them.

A common approach to component testing is the test-first approach, which is an iterative process. According to this approach, you create test cases before you start developing and testing code. To create the test cases, you use the specifications documents and the blueprint for the software application.

The test-first approach involves repeating three steps until the code passes the tests:

    create test cases
    develop code
    run tests

While you're testing the code of a component, you may also need to check whether the code correctly responds to or calls other components. However, sometimes, you may not have immediate access to these other components.

The unavailability of the other components in a component-testing scenario is similar to the testing of parts at a car-manufacturing plant. For example, when you begin testing the motor of a particular car model, the braking system or the ignition mechanism might not be ready. Here the braking system is a called component and the ignition mechanism is a component that calls the motor.

To test the functions of the motor in the absence of a braking system and ignition mechanism, you might first create a temporary, no-frills braking system and ignition. Then you could connect both to the motor. Similarly, to check whether a software component can respond to or call other components, you create two temporary components:

stubs
    Stubs simulate called components. While testing a software component in isolation, you use a stub in place of each called component. For example, if an component calls an object that is not yet ready, you can use a stub in place of the object.
drivers
    During component testing, you may also have to create simulated components or test tools known as drivers. A driver acts as a substitute for a component that calls the component you're testing. For example you can use a driver in place of the button that calls the authentication system you're testing.

At the component-testing level, apart from checking the functions of a software component, you also verify whether it meets nonfunctional requirements. For example, you check whether a component can manage memory and storage space efficiently.
Note

A nonfunctional requirement is one that isn’t related to functionality, but to an attribute such as usability, efficiency, reliability, maintainability or portability.

During component testing, you also test the robustness of a component. For example, you check how well the component responds to invalid inputs. You also check whether the components require additional testing and perform the tests, if required.
Question

The training department at Easy Nomad Travel, a worldwide travel agency, has developed various training courses over the years. To manage these courses, the agency hires your company to develop a modular course management system. As a testing manager, you're responsible for testing the system. Identify the steps which are necessary to ensure successful component testing.

Options:

    Assign a developer to test each module created by another developer
    Maintain a formal record of defects
    Ensure all called components are available
    Create test cases before you develop and test code

Answer

Option 1: Correct. To bring objectivity and independence to the component-testing process, you can ask a developer to test a code segment or module created by another developer.

Option 2: Incorrect. It is not necessary to maintain a formal record of defects during component testing. You fix all defects as soon as you detect them.

Option 3: Incorrect. During component testing, you may not have access to all called components. So to check whether the code you're testing correctly calls other components, you substitute the called components with stubs.

Option 4: Correct. A commonly used approach to component testing is the test-first approach. In this approach, you create test cases before you start developing and testing code.

Correct answer(s):

1. Assign a developer to test each module created by another developer
4. Create test cases before you develop and test code
2. Integration testing

After successful component testing, you move on to integration testing. At this test level, you determine whether software components interact with each other as intended.

During integration testing, you also verify whether the software components interact correctly and efficiently with computer hardware and other software, such as an operating system. This level of testing is also known as component integration testing and is typically conducted by either developers or integrators.

You can also conduct an integration test after the system-testing process. At this stage, you refer to integration testing as system integration testing. This type of testing helps you accurately analyze the interactions between a complete software product and other software systems.

During component and system integration testing, you can test the nonfunctional characteristics of the integrated components and systems. For example, after integration, two components may use a single system resource at the same time. This can negatively affect the performance of the components. You can check for such performance degradation during component integration testing.

Before you plan for and perform integration testing, you should choose an integration strategy. This strategy helps you decide the order in which you integrate the components of a software application. The order depends on the number and types of bugs you expect the application to have.

Based on the integration strategy you choose, you can adopt one of two methods to conduct integration testing:

big-bang integration testing
    You perform big-bang (or non-incremental, as it is formally known) integration testing on a fully integrated system. You should use this method of testing only if you plan to integrate the software components first and then test the resulting system. Bang-bang integration testing proves successful if the components have few and uncomplicated bugs.
    Description of the big-bang integration testing animation:
    The animation depicts the pieces of a jigsaw puzzle being assembled to complete the image of a car.
    Description ends. 
incremental integration testing
    Incremental integration testing is opposite to the big-bang method. In this type of testing, you gradually build and test the system on a component-by-component basis. For example, you test the interactions between any two components before you integrate and test additional components.
    Description of the incremental integration testing animation:
    The animation depicts the pieces of a jigsaw puzzle being assembled one-by-one to complete the image of a car.
    Description ends. 

Both integration testing methods have their advantages and disadvantages.

Big-bang integration testing ensures that you don't require stubs and drivers to simulate missing components. Yet this method is time consuming because it involves testing an entire system. While conducting such tests, you may be unable to identify the cause of defects quickly.

Additionally, big-bang integration testing allows you to detect defects only late in the development process. Fixing defects at this late stage can considerably increase the defects and expenses of the project, leading to budget overruns.

The advantage of incremental integration testing is that you start testing on a small scale. For example, you first test the interaction between two or three components. This increases your chance of isolating defects.

However, when you conduct tests using incremental integration testing, you need to use stubs and drivers to substitute for missing components. Creating the stubs and drivers can be time consuming, increasing the cost and effort involved in the test process.

In most cases, incremental integration testing is preferable to big-bang integration testing because the advantages of incremental integration testing outweigh the disadvantages.

You can divide incremental integration testing into two types:

top-down integration testing
    Top-down integration testing involves testing the external features of a software application first and then gradually integrating and testing the internal components. For example, you start by testing the interactions of the graphical user interface (GUI), which isn't called by any other component. If the components the GUI calls aren't ready, you use stubs to simulate them. When you receive the missing components, you perform integration testing on them.

    The advantage of top-down integration testing is that you don't need to create drivers. Also, this type of testing helps you easily identify and fix defects in the design of your software application. However, additional effort is required to create stubs.
bottom-up integration testing
    In bottom-up integration testing, you first test the component at the lowest level in the software application. This would be the component that doesn’t call any other components. You can use drivers to simulate the components that call this component. Similarly, you progressively build the application and test the higher-level components.

    This method helps you test the interactions between software components more effectively than the top-down method.

Static Techniques and Test Designing Software Testing
  -

Black-box Sofware Testing Techniques
  -

White-box Sofware Testing Techniques
  -

Software Test Management
  -                   
  
