                    ISTQB Certified Tester Foundation Level
                    Course Notes Part 6


Sequential Approach Software Models
  - The Waterfall model rigidly follows the SDLC phases
  - This allows the project in 1 phase at a time
  - The Waterfall approach compliments a rigid manage structure
  - The requirements and budget are normally in a contract and are difficult to change
  - The strict adherence to the SDLC makes waterfall easy to understand
  - Everyone associated with the team knows what phase the project is in
  - There is a danger of project being obselete before being delivered
  - This is a good approach for when requirements are known and stable
  - The Sashimi model is a similar approach to Waterfall
  - Unlike Waterfall however Sashimi allows for some phase overlapping
    - This is why it is named after the fish dish where slices overlap 
  - One phase is not complete until the next phase is at least explored
    - One example is design not being complete until at least some implementation is done
    - This can uncover issues with the design quicker than otherwise
  - Rework needed is minimised due to specifications not being frozen
  - The Sashimi approach is most effective in medium sized projects with good informal communications
   - This allows for insights to be passed back to the previous phase
  - Another approach is the V-Model approach
  - The V model places emphasis on validation and verification
  - Project definition phases go down the left, integration and test phases down the right
  - The base of the v is the development phase
  - The x-axis represents time, the y-axis represents the increasing levels of abstraction
  - The project cannot move back in time
  - Each definition phase has a corresponding test phase

The Iterative Software Approach
  - Adaptive software models use a combination of iterative and incremental approaches
  - They iterate through the cycle multiple times per project
  - Each cycle adds a small piece of functionality to the project
  - The new features are developed, tested and shown to the customer
  - Comments will be noted to influence requirements in later cycles
  - This prioritises the requirements
    - It also adapts to changing priorities and requirements
  - At the end of the iteration a potentially deployable app is present
  - Common models include
    - RAD -- Rapid Application Development\Prototype
    - RUP -- Rational Unified Process
    - Spiral 
    - Agile
  - There are several benefits to using the iterative approach
    - Each release delivers an operational product
    - Highest Risk and Priority features are added first
    - There is customer input after each iteration
    - It is adaptive to changing requirements
  - It is quite common for requirements from customers to change
  - There is a need for skilled staff in planning and design
  - There is also a need for an early definition of the complete system
  - These approaches are suited to the cahnging landscape of Software development
  - They are well suited to projects where there is a lot of complexity
  - Also well suited are projects with lots of risk due to requirements changing or new tech
  - Another good use case os for when demands of market need quick releases

