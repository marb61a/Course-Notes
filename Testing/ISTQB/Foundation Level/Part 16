                    ISTQB Certified Tester Foundation Level
                    Course Notes Part 16
                    
                    
Software Testing and Development Models (Continued)
  - The main drawback of the waterfall model is that it incorporates testing toward the end of the development life cycle
  - Because the code for the product is too complex at this stage, fixing bugs or defects in the product can be time consuming
    - While fixing the bugs, you can introduce new bugs in the product.
  - To overcome the drawbacks of the waterfall model, divide the development of the product into various stages 
    - Perform a testing activity at the end of each stage
  - This division of development and testing activities can help identify bugs early where fixes are easier
  - The V-model is a sequential model that improves upon the waterfall model. 
    - In the V-model, the development team first identifies client and system requirements
    - Then an overall and detailed design is created
    - The testing team review the documents generated at the end of these processes
    - Simultaneously plan for the testing activity is going on
    - As the product is progressively developed, the other testers test it
    - Here though divide the testing into four test levels.
      - Component testing
        - During component testing,test each component of your product for defects and fix any defects immediately.
        - Use the detailed design of the product as the basis for creating a component-testing plan.
      - Integration testing
        - Integration testing is used to test the interrelationships between the components of the product
      -
  - 
. During integration testing, you determine whether the components interact correctly with each other and with computer hardware and other software.

To create an integration-testing plan, you refer to the overall design of the product.
System testing
Before you begin system testing, developers integrate all the components and build a functional software product. It exhibits the desired features and functions and performs without any evidence that there are defects present.

You create a system-testing plan based on the system requirements.
Acceptance testing
Acceptance testing is conducted by the representatives of the client. The representatives may either test the product at your site or test it after you've delivered it to them. Their main objective during acceptance testing is to determine whether the product meets all their requirements.

You create an acceptance-testing plan after the client's requirements have been identified.
In the V-model, you test the product at each stage of development. You release the outcome of each stage to the next stage only when all identified defects have been fixed.

However, the V-model also has a drawback. In this model, you verify a product against client requirements only toward the end of the development process. Fixing bugs and adding missing features and functions to the product at this stage can be difficult, expensive, and time consuming.

The iterative development model eliminates the drawback of the V-model. In the iterative model, developers build a product using a series of iterative steps. Each step consists of four tasks – Identify requirements, Create a design, Create code, and Test code. You, as the tester, are part of the development process. Because you are able to test the product while it is being developed, you can identify bugs easily and accurately.

In the iterative model, representatives of your client can participate in the testing process at the end of each step. The representatives can also suggest changes to the product during development.

If you use the iterative model, you
don't prepare formal documents, such as the requirement specification document, before you begin development
don't have to identify all client and system requirements or design the entire product before you start creating code
have a set schedule and cost for the project and for each iterative step
repeat each iterative step until you develop a final product that meets all client and system requirements
The iterative model also has its drawbacks. These drawbacks can adversely affect the testing process.

Two significant drawbacks of the iterative model are absence of formal documentation
In the absence of formal documentation, you can't verify requirements accurately. So you write a functional test for each iterative step and ask the developers to create code that can pass the functional test.
increased testing time and cost
Compared to the other models, the iterative model can increase testing time and cost. For example, during an iterative step, developers can inadvertently modify a previously approved feature. To prevent such modifications and deletions, you have to spend more effort on testing. This can be a drawback for small-scale projects.

The waterfall model is a sequential software development model. In this model, you build and then test a software product.

The V-model is a customized version of the waterfall model. In this model, you combine the testing process with the software-development process. This ensures that you test each component, feature, and function of your product as it is built.

The V-model and the iterative model are not stringent and you can modify them to suit your requirements. For example, you can use the four test levels – component testing, integration testing, system testing, and acceptance testing – during each iterative step of the iterative model.

You can also customize the order in which you perform the four test levels, regardless of the development model you use. For example, if you're testing a web portal that contains a third-party application, you perform acceptance testing on the third-party application first. Then you carry out system testing for the web portal.

Static Techniques and Test Designing Software Testing
  -

Black-box Sofware Testing Techniques
  -

White-box Sofware Testing Techniques
  -

Software Test Management
  -                   
  
