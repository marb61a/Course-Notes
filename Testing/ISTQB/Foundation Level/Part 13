                    ISTQB Certified Tester Foundation Level
                    Course Notes Part 13
                    
                    
2.2 CTFL: Fundamentals (Cont)
  - You may see quality assurance referred to as testing.
    - However, quality assurance and testing are not the same thing
    - They are however related by a larger concept known as quality management.
  - Quality management is a discipline involving activities that are related to software quality
  - Quality assurance is typically focused on the alignment to proper processes
  - Quality assurance supports proper testing
  - A requirements definition error typically leads to a requirements defect
  - If a defect in the code is executed, it can cause a failure, but not necessarily in all circumstances. 
    - For example, some defects require specific inputs or they require conditions to trigger the failure. 
    - And these specific inputs or conditions may not exist. 
    - The result is that some failures may rarely or never actually be triggered.
  - Factors leading to errors include time constraints and pressure. 
    - These tend to cause the individual to make assumptions or to work quickly under pressure and this leads to errors. 
    - A lack of experience or skill is also a factor that leads to errors. - 
    Miscommunication between project participants, including miscommunication regarding the design or requirements
  - Other factors leading to errors include intrasystem or intersystem misinterpretation. 
    - And this is especially when intra and intersystem interactions occur in large numbers. 
  - The complexity of the code, the architecture and/or the design of the system is a factor that can lead to errors.
  - New or unfamiliar technologies that are being employed with the software product can lead to errors. 
  - Not all unexpected test results are failures. False positives or false positive failures can occur 
    -These are reported as defects, even though they're not really defects. 
    - False positive failures can be caused by errors in how the tests were executed as well as other factors 
    - False negative failures occur, and these are due to tests that don't detect errors but should have.
  - Defects may be analyzed when they're detected in order to locate the root cause. 
    - The root cause is the earliest action or condition that leads to the defect. 
  - Identifying and addressing the root cause is really important to software quality
    - If you don't address the root cause, it can continue to have an effect on that software.
    - By identifying and addressing the root cause, on the other hand, it serves to reduce similar defects in the future.
  - Root cause analysis focuses on and zeroes in on the most significant root cause of defects. 
    - The root cause analysis can lead to process improvements and help avoid future similar defects. 
  - So the defect originated in the product owner's misunderstanding of the sales tax calculation rules. 
  -  Testing principle 1. Testing shows the presence of defects, not their absence. With Testing principle 1, we need to understand that testing may be able to show that there are defects in the software. But testing does not prove that there aren't defects in the software.

Testing reduces the likelihood of undiscovered defects that remain in the software, however, but testing in and of itself is no guarantee of correctness even if no defects are found in the software. Testing principle 2, exhaustive testing is just not possible. That is, every potential combination of inputs and conditions can just not be tested. It's only feasible in the most simple of cases.

So exhaustive testing is impossible. So we focus on risk analysis rather than testing everything. We use test techniques and priorities to prioritize those components of testing that need to actually be performed. So rather than trying to exhaustively test everything in a futile attempt, we focus on those three things, risk analysis, the test techniques, and prioritizing tests instead.

Testing Principles 3-4
[Video description begins] Topic title: Testing Principles 3-4. The presenter is Joseph Khoury. [Video description ends]

In this video, we'll consider testing principles three and four of the seven testing principles. Testing principle 3. Early testing saves time and money. In order to find defects as early as possible in the development life cycle, we use static and dynamic testing. This helps reduce or eliminate costly fixes that can occur late in the software development life cycle.

Because, as we know, these fixes only become more expensive the further into the lifecycle that we go. Early testing is also known as shift left. So if you hear of shift left, you'll know that it's referring to early testing. Testing principle 4. Defects cluster together. So that is, a small number of modules typically contain the most defects that are going to be discovered in pre-release testing. And they're typically responsible for the majority of operational errors.

[Video description begins] Defects Cluster together. [Video description ends]

Now, keep in mind that predicted defect clusters and the actual observed defect clusters that occur in testing or in operation, are very important inputs into a risk analysis that will be used to focus the test effort.

Testing Principles 5-6
[Video description begins] Topic title: Testing Principles 5-6. The presenter is Joseph Khoury. [Video description ends]

In this video, we'll consider testing principles five and six of the seven testing principles. Testing principle 5, beware the pesticide paradox. Now what this means is that as testers when you apply the same tests over and over again, eventually those tests will no longer be effective. In other words, they will no longer find new defects. To detect new defects, recognizing the pesticide paradox, existing tests and test data may need to be changed. In addition, you may be required to design and devise new tests.

Keeping this in mind, though, some situations may actually benefit from the pesticide paradox, and that is automated regression testing. Automated regression testing benefits because there is a relatively low number of regression defects. Now, testing principle 6. Testing is performed differently in different contexts, so, testing is context dependent. So we perform testing and those activities differently under different contexts.

For example, consider industrial control software that is safety critical versus a basic e-commerce app. So obviously, the industrial control software that's safety critical will be treated much more carefully than a basic e-commerce app. Similarly, a product developed under an Agile life cycle model versus a sequential life cycle model. Well, this will have a huge impact on the way that testing is performed. Because under the Agile life cycle model, we use early testing.

Of course, we use early testing in sequential life cycle model, too. But we have smaller components to test, so again, the testing is totally context dependent.

Testing Principle 7
[Video description begins] Topic title: Testing Principle 7. The presenter is Joseph Khoury. [Video description ends]

In this video, we'll consider principle seven of the seven testing principles. Principle seven, absence of errors is a fallacy. Consider this, some organizations contend that testers can run all possible tests against software. They also contend that it's possible for testers to detect and find every possible defect. Well, we know that exhaustive testing is impossible.

So it's a fallacy to assume the success of a system is assured. Simply by finding a large number of defects and by fixing a large number of defects. Just by finding and fixing them does not assure the success of the system, consider this. Systematically testing all requirements and addressing each defect can still produce a system that fails to fulfill users' requirements.

[Video description begins] A diagram displays in which two mobile devices are displayed. The mobile devices are labeled as A and B . The mobile device B is checked mark. [Video description ends]

Well, that doesn't indicate success. It may also still produce a system that fails to meet users' expectations, again, that in and of itself does not indicate success. Furthermore, systematically testing all requirements and addressing all the defects that are found can still result in a system that is awkward and difficult to use. That is not success and may also result in a system that is inferior to competitor systems. And in that case that certainly is not success.

Exercise: Concepts of Software Testing
[Video description begins] Topic title: Exercise: Concepts of Software Testing. The presenter is Joseph Khoury. [Video description ends]

In this exercise, you'll practice what you learned about software testing basics. You will describe the two test types, describe why test objectives may vary, describe debugging. And describe why testing should be performed and list the seven testing principles. Now pause the video and perform the exercise. And when you're finished, come back here for my solution. First, the two types of testing.

[Video description begins] Solution. Dynamic and Static Test Type. [Video description ends]

You have dynamic and static test types. Dynamic test types involve testing against running components or systems. And static testing does not involve testing against a running system, for example, doing a requirements review.

[Video description begins] Testing Objective May Vary. [Video description ends]

Testing objectives may vary, because testing objectives are dependent on several factors. Including the component or system under test, the test level, and the software development life cycle model being employed. Debugging. Debugging is a development activity in which defects are located. They're analyzed to find the root cause. The defects are then addressed. And the repaired product is handed back to testing to confirm. So, why perform testing?

[Video description begins] Confirmation testing should be performed to verify resolution. [Video description ends]

We perform testing to identify defects and reduce the risk of operational failure. It also serves to improve software quality and helps comply with requirements. And now, the seven testing principles. Principle one, testing shows the presence of defects, not their absence. Principle two, exhaustive testing is impossible. Principle three, early testing saves time and money. Principle four, defects cluster together. Principle five, beware of the pesticide paradox. Principle six, testing is context dependent. And finally, principle seven, absence of errors is a fallacy.  

Testing Throughout the Software Lifecycle
  -

Static Techniques and Test Designing Software Testing
  -

Black-box Sofware Testing Techniques
  -

White-box Sofware Testing Techniques
  -

Software Test Management
  -                   
