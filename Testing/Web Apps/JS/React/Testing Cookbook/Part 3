                    React Testing Cookbook
                    Course Notes Part 3


9 - Reusing Test Boilerplate
Example Syntax
  // The previous example has a lot of code duplication which can be cleaned up
  // The main principle is to pull out duplicated code so thet it can be refactored into 
  // reusable components
  describe("isActive", () => {
    // A factory function where the duplicate code can be reused
    function renderLikeCounter(isActive){
      const renderer = TestUtils.createRenderer();
      renderer.render(<LikeCounter count={5} isActive={isActive} />);
      return renderer.getRenderOutput().props.className.includes('LikeCounter--active');
    }
    
    it('should show the like count as active', () => {
      expect(renderLikeCounter(true)).toEqual(true);
    })
    
    it('should show the like count as inactive', () => {
      expect(renderLikeCounter(false)).toEqual(false);
    })
  })

10 - Children With Shallow Rendering
Example Syntax
  // Example will be based on an app which allow adding favourite quotes to a collection and like/unlike them
  import React from 'react';
  import TestUtils from 'react-addons-test-utils';
  import expect from 'expect';
  // These libraries are to help when testing elements of the object structure rather than the whole structure 
  import expectJSX from 'expect-jsx';
  expect.extend(expectJSX);
  import LikeCounter from './LikeCounter';
  
  describe('LikeCounter', () => {
    it('should render like counts', () => {
      const renderer = TestUtils.createRenderer();
      renderer.render(<LikeCounter count={5} />);
      const actual = renderer.getRenderOutput();
      const expected = '5 likes';
      expect(actual).toIncludeJSX(expected);
    })
  })

11 - The Redux Store Multiple Actions

12 - The Redux Store Initial State

13 - Redux Reducers
