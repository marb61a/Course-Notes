                    Web Security 
                    Course Notes Part 6


                    Section 3 - Cross-Site Request Forgery (CSRF)
1 - Introducing Cross-Site Request Forgery (CSRF)
CSRF - Cross Site Request Forgery
  - This is the second most prevalent attack
  - This type of attack takes advantage of the fact that cookies for basic authentication are passed along with requests
  - This is one reason to align with REST conventions (GET, POST, DELETE etc)
    - There should be no GET requests that mutate data
    - Just allowing PUT and POST will not solve the issue
  - Example Syntax
    - This form which is hidden will be able to make a request
    - The request itself will not be seen which is called an Opaque request
    - The result will show whether the request was successful or not
    <form name="badform" method="post" action="https://equihax.com/api/transfer">
      <input type="hidden" name="destination" value="2"/>
      <input type="hidden" name="amount" value="8500"/>
    </form>
    <script type="text/javascript">
      document.badform.submit()
    </script>

2 - Challenge 4: CSRF
  - See if you can make a page on JSBin
    - JSBin is recommended instead of other similar sites like CodePen as you can create plain HTTP landing pages
    - The other sites use HTTPS which wil cause a mixed content warning
  - The challenge is to cause transfers for logged-in users
  - This should be tried with both GET and POST
  - Try and do as much damage as possible

3 - Challenge 4: Solution
  - This takes advantage of the fact that a GET request can be made that mutates data
    - Using both the image and form examples
  - IFrames can be used to avoid ongoing attacks being seen
  - GET requests are the most serious
    - You will not have to trick people into clicking a link like with POST

4 - CSRF Tokens
  - How to know if you are vulnerable or not
  - Only Basic or cookie authentication schemes are vulnerable
    - The exception to this is a Client-side Cookie
      - If you remove somethng from a cookie that then needs to be placed into a request header
        - This is not suceptable to CSRF
        - This is because you need to be running code on a domain that can access that cookie
        - Web storage is partitioned on a per domain basis
        - If using the cookie as a means of storage only and the server is not looking at the cookie as a means of identtification
          - Then this type of attack does not work
        - This attack works when code is written on a site and a request is sent to another site
          - Cookies are usually sent in the response and that can be taken advantage of
      - By using this a user has mitigated the broadest form of the CSRF attack
  -

5 - Request Origin

6 - Cross-Origin Resource Sharing (CORS)

7 - Challenge: 5: Defend Against CSRF



                    Section 4 - Clickjacking
1 - Introducing Clickjacking
A quick demo of the clickjacking process
  - Often there is a domain/subdomain very similar to a legitimate one used
  - The illegitimate domain is then placed into an iFrame
  - Its opacity is set to 0 and users therefore think that they are clicking on a legitimate page
  - One of the most famous attacks is the Adobe Global Flash Security Settings Page
  - This falls in the UI redress attack category
  - It can also be used for capturing keystrokes
  - Some of the more sophisticated versions are very difficult to detect

2 - Challenge 6: Clickjacking
The challenge here is
  - 
