                    Web Security 
                    Course Notes Part 6


                    Section 3 - Cross-Site Request Forgery (CSRF)
1 - Introducing Cross-Site Request Forgery (CSRF)
CSRF - Cross Site Request Forgery
  - This is the second most prevalent attack
  - This type of attack takes advantage of the fact that cookies for basic authentication are passed along with requests
  - This is one reason to align with REST conventions (GET, POST, DELETE etc)
    - There should be no GET requests that mutate data
    - Just allowing PUT and POST will not solve the issue
  - Example Syntax
    - This form which is hidden will be able to make a request
    - The request itself will not be seen which is called an Opaque request
    - The result will show whether the request was successful or not
    <form name="badform" method="post" action="https://equihax.com/api/transfer">
      <input type="hidden" name="destination" value="2"/>
      <input type="hidden" name="amount" value="8500"/>
    </form>
    <script type="text/javascript">
      document.badform.submit()
    </script>

2 - Challenge 4: CSRF
  - See if you can make a page on JSBin
    - JSBin is recommended instead of other similar sites like CodePen as you can create plain HTTP landing pages
    - The other sites use HTTPS which wil cause a mixed content warning
  - The challenge is to cause transfers for logged-in users
  - This should be tried with both GET and POST
  - Try and do as much damage as possible

3 - Challenge 4: Solution
  - This takes advantage of the fact that a GET request can be made that mutates data
    - Using both the image and form examples
  - IFrames can be used to avoid ongoing attacks being seen
  - GET requests are the most serious
    - You will not have to trick people into clicking a link like with POST

4 - CSRF Tokens
  - How to know if you are vulnerable or not
  - Only Basic or cookie authentication schemes are vulnerable
    - The exception to this is a Client-side Cookie
      - If you remove somethng from a cookie that then needs to be placed into a request header
        - This is not suceptable to CSRF
        - This is because you need to be running code on a domain that can access that cookie
        - Web storage is partitioned on a per domain basis
        - If using the cookie as a means of storage only and the server is not looking at the cookie as a means of identtification
          - Then this type of attack does not work
        - This attack works when code is written on a site and a request is sent to another site
          - Cookies are usually sent in the response and that can be taken advantage of
      - By using this a user has mitigated the broadest form of the CSRF attack
  - LocalStorage and SessionStorage are only accessible on the client side
    - SessionStorage differs from LocalStorage as when the user closes the browser the SessionStorage data is destroyed
  - To try and solve the CSRF issue there are CSRf Tokens
    - Like a cryptographic nonce they are generated in an unpredictable way with each payload
    - Tokens are disposable meaning they can only be used once then destroyed
      - This means that an iterative algorithm for generating tokens is what should be in place to genereate new tokens
  - This has a level of similarity to 2 factor authentication
    - There are 2 pieces involved in the process
    - The first is something proving that you are authenticated
    - Something that proves that you are sending a request from an appropriate place
  - For server rendered apps meta tags are ok to use

5 - Request Origin
  - Modern Browsers send an Origin heaeder with each request
    - This can not be altered by client side code
    - Although it may appear that you can alter this header your changes will not stick
    - IE11 may not send this header in some instances
  - In cases where there is no Origin header there is usually a Referer header
    - This is misspelled intentionally
  - If behind a proxy then some information can be gotten form the Host and X-Forwarded-Host headers
    - If using Heroku you will be behind Squid

6 - Cross-Origin Resource Sharing (CORS)
  - The next best practice is to set CORS headers properly
  - This is what allows a browser to send a request from one domain to another
  - It involves what is called an OPTIONS Preflight
    - This is a low overhead request to a server to findout what is allowed
  - Example Syntax
    - // Preflight request to server
    - Origin: http://foo.example
    - Access-Control-Request-Method: POST
    - Access-Control-Request-Headers: Authorization, Content-Type
    -
    - // Preflight response from server
    - Access-Control-Allow-Origin: http://foo.example
    - Access-Control-Allow-Methods: POST, PUT, GET, OPTIONS
    - Access-Control-Allow-Headers: Autorization, Content-Type
    - Access-Control-Max-Age: 86400
    - 
    - // Main request to the server
    - Origin: http://foo.example
    - Access-Control-Request-Method: POST
    - Access-Control-Request-Headers: Authorization, Content-Type
    - Authorization: Bearer ashgsdye6yhysythgfjdf
    - Content-Type: application/json

