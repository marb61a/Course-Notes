                    Web Security 
                    Course Notes Part 4


9 - Sanitizing User Data
XSS Defenses - If you unescape then sanitize data first
  - These are some cheats for different libraries so you will know when you are in a danger zone
    - Ember & Vue -- {{{ "unescaped" }}}
      - This string will be treated as Html 
    - React -- return <div dangerouslySetInnerHTML={createMarkup()}/>;
    - Ejs -- <%- "Unescaped" %>
      - The course example app has a couple of examples of this issue which will need to be fixed
      - In this case the minus sign needs to be changed to an equals
    - Angular -- <div [innerHTML]="unescaped"></div>
    - Jade -- ! This is #{"<b>unescaped</b>"}!
Escape before putting user data in attributes
  - <div class="<%= 'UserValue' %>"></div>
  - Be especially careful of this when templating Javascript
    - <script>alert("Hello <%- userValue %>")</script>
  - Recommended to use https://github.com/ESAPI/node-esapi
    - This will check your app for issues, it is highly recommended by the instructor
  - User input should be treated as values not code

10 - Content Security Policy (CSP)
XSS Defenses Content Security Policy
  - Browsers cannot tell the difference between scripts downloaded from you origin vs another
    - This is called a single execution context
  - CSP allows modern browsers to be told which sources they should trust and for what type of resources
  - This information comes from a HTTP response header or meta tag
      - Content-Security_Policy: script-src 'self' https://example.example
                                 ---------         -----------------------
                                   name             sources
                                |--------------- directive ----------------|
                                
    - Multiple directives are allowed and are separated by semi-colon
    - Redefining a driective with the same name has no effect
    - By default directives are permissive
      - Content-Security-Policy: script-src: 'self' https://example.example;
                                 font-src: https://fonts.googleapis.com
  - There are some useful CSP directives
    - child-src -- Child execution contexts eg frames, workers
    - connect-src -- What you can connect to such as fetch, WebSocket, EventSource
    - form-action -- Where you can <form> submit to
    - img-src, media-src, object-src -- Where you can get images, media etc from
    - style-src -- Where external stylesheets can come from
    - upgrade-insecure-requests - Upgrades HTTP requests to HTTPS
    - default-src -- A fallback for when a specific directive is not provided
  - There are also some keywords which can be used alongside sources which are typically origins
    - none -- No sources allowed
    - self -- Current origin
    - unsafe-inline -- Allows inline JS and CSS
    - unsafe-eval -- Allows eval()
      - This is used by templating frameworks where a string is sent and evaluated juust in time
      - This improves the performance of webpages
 There are a few ways the unsafe-inline can be made a little safer
  - Script tags embedded in HTML is the most common form of XSS and banning it mitigates risk considerably
  - There are times however where JavaScript is needed and there are solutions
  - Cryptographic nonces must be generated per page load and must change unpredictably
Example Syntax
  // Cryptographic nonce example
  <script nonce=A9h3pdfn3f03nce8DnMIOErd7Gb>
    alert('This example is done inlne');
  </script>
  
  Content-Security-Policy: script-src 'nonce-A9h3pdfn3f03nce8DnMIOErd7Gb'
  
  Another way to do this is to add a checksum to the security policy 
    - Content-Security-Policy: script-src 'sha256-absd182.....='
    - The easiest way to define this is to use the browser itself
    - Use the error generated and move that into the CSP

11 - Challenge 2: Defend Against XSS Attacks
Implementing XSS defences
  - Custom linting rules can be used to scan and eliminate unsafe-inline
  - This also is useful with a Git pre-commit hook
  - Eliminating using automation is a good idea and it should be done as early as possible
The exercise in this section is to
  - Fix 3 XSS issues
  - Add a reasonable CSP to the example project
    - There is a library available to help with this
      - https://github.com/helmetjs/csp

12 - Challenge 2: Solution, Part 1
The example uses the VS Code IDE search facility which will search for a pattern
  - In this case it is the <%- pattern to be eliminated
  - Some may need to be kept otherwise use <%=
    - Most of these would be layout related eg <%- body -%>
  - There are other XSS vulnerabilities which allow users to see and manipulate other users data

13 - Challenge 2: Solution, Part 2Adding a reasonable CSP to the app
  - The HelmetJS GitHub page has a sample policy which can be used as a template and modified if needed
  - It will then need to be required in order to be used eg cont csp = require('helmet-csp'); 
  - In Express app.use is a stack of middlewares normally
  - CSP should be placed near headers in order to make for better readability
  - reportOnly is normally set to false but for testing purposes is set to true 
    - This means that things will not be blocked but you will be alerted to issues 
  - In the sample directives there is a reportUri directive
    - reportUri: '/report-violation'
    - You can specify an endpoint where errors can be sent from browsers that detect violations
    - This can be used for what is called by some a dynamic-kill-switch
    - This allows for session\user termination for CSP violation and is a good place to hook in security software
    - There are downsides though as information about user status could be available
      - Information from outside domains can bleed through and inferences about user permissions can be drawn
  - The sandbox directive will deal with I-Frames
    - sandbox: ['allow-forms', 'allow-scripts']
    - Basically only I-Frames with the sandbox attribute will be allowed
    - This will limit the functionality of I-Frames
  - The values must be in the valid CSP format between quotes
  - Eliminating inline styles will eliminate an XSS vector completely
    - This is CSS best practice 

14 - Malicious Attachments
This will not completely protect you due to malicious attachments
    - Documents can have embedded code and are not inert
    - PDF files have had trojans added to them which will cause problems
  - Images can also have malware embedded
    - Changing image extensions can cause problems, the example uses jpg changed to html
    - The html in images can have links embedded
  - Allowing users to share attachments can help spread malware

15 - Challenge 3: XSS Attachment
This is an explation of the exercise that students will perform
Attack - XSS Attachment
  - This is broken down into a scenario based exercise
    - Image uploads are allowed in the scenario
    - These are hosted in the same domain as the app
    - There is a need to ensure that uploads are in fact images
    - Users have the ability to rename files
    - Check what happens when you visit the url of a particular renamed image
  - Students are allowed to see how far some of this goes

16 - Challenge 3: Solution
The tool that is used in the example is exif.js
  - Read the Exif comment field and pipe it into the clipboard, the command is as follows
    - node ./scripts/exif.js read ./examples/squirrel.jpg | pbcopy
  - Replace the Exif comment field with the content of a HTML file, the command is as follows
    - node ./scripts/exif.js write ./examples/squirrel.jpg scratch.html
    - One note is that it must all go on to one line, this is because you cannot have a multiline HTML file name
Browser will treat a document and image request completely differently
Using pbcopy will add something to the clipboard
The exif.js library is filetype sensitive

17 - Stopping Malicious Attachments
There are defenses available to combat XSS Attachment attacks
  - Restrict the file types that can be uploaded and also the ability to access these types
    - This reduces how much of an XSS vector an app is
    - Do not blindly trust filetypes
  - When using images, compression usually eliminates non-visible data and is best practice so use this
  - Do research before allowing file types eg PDF's can execute Javascript which a lot of people do not realise
    - Some browsers will allow this straight away    



                    Section 3 - Cross-Site Request Forgery (CSRF)
1 - Introducing Cross-Site Request Forgery (CSRF)
CSRF - Cross Site Request Forgery
  - This type of attack takes advantage of the fact that cookies for basic authentication are passed along with requests
  - This is one reason to align with REST conventions (GET, POST, DELETE etc)

2 - Challenge 4: CSRF

3 - Challenge 4: Solution

4 - CSRF Tokens

5 - Request Origin

6 - Cross-Origin Resource Sharing (CORS)

7 - Challenge: 5: Defend Against CSRF



                    Section 4 - Clickjacking
1 - Introducing Clickjacking
A quick demo of the clickjacking process
  - Often there is a domain/subdomain very similar to a legitimate one used
  - The illegitimate domain is then placed into an iFrame
  - Its opacity is set to 0 and users therefore think that they are clicking on a legitimate page
  - One of the most famous attacks is the Adobe Global Flash Security Settings Page
  - This falls in the UI redress attack category
  - It can also be used for capturing keystrokes
  - Some of the more sophisticated versions are very difficult to detect

2 - Challenge 6: Clickjacking
The challenge here is
  - 

3 - Challenge 6: Solution

4 - Stopping Clickjacking

5 - Challenge 7: Defend Against Clickjacking

6 - Challenge 7: Solution



                    Section 5 - Third Party Assets
1 - Introducing Third Party Assets
Items that fall under third party assets include
  - Non hosted scripts
  - Version dependency for use in development eg "express": "^4.15.2"
    - This is fuzzy as there as multiple possible versions as the ^ signifies from this version up
  - Tracking code eg Google Analytics
    - This maybe the worst of the three
    - The example code is used togenerate its own script tag which then pulls in the real code it uses

2 - Challenge 8: Subresource Integrity

3 - Challenge 8: Solution



                    Section 6 - Man-in-the-Middle
1 - Introducing Man-in-the-Middle Attacks

2 - Hardware

3 - Encrypting Data



                    Section 7 - HTTPS
1 - Introducing HTTPS

2 - HTTPS & Cryptography

3 - TLS Handshake

4 - OpenSSL

5 - Challenge 9: Defend Against Man-in-the-Middle Attack

6 - Challenge 9: Solution



                    Section 8 - HTTPS Downgrade
1 - Introducing HTTPS Downgrade

2 - Defending Against HTTPS Downgrade

3 - Bad Certificate

4 - Defending Against Bad Certificates

5 - Challenge & Solution 10: Defend Against HTTPS Downgrade

6 - Certificate Authority Compromise



                    Section 9 - Wrapping Up
1 - Wrapping Up Web Security
A few final words from the course author and thanking the students
