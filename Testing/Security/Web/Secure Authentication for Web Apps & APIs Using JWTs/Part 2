                    Secure Authentication for Web Apps & APIs Using JWTs
                    Course Notes Part 2


2 - JWT Authentication
User submits credentials which are then checked against a database
If everything is good then a token is signed and returned to the client in response
The token is saved on the client usually in a cookie or web storage
  - Using cookies will create some limitations
The token is sent as an Authorization header on every HTTP request
When the request is received on the backend, the JWT is verified against the secret that only the server knows
The payload is checked to route the the request based on the JWT's claims
  - This is usually done with middleware
If the JWT is valid the request is returned
If the JWT is invalid a 401 is returned

How Does This Help
The Single Page App (SPA) no longer relies on the backend to tell it whether the user is authenticated 
The backend can receive requests from multiple clients and the backend only cares that the token is valid
Requests can flow to downstreeam servers if necessary
The client tells the backend what is permissable instead of asking
  - This means that there is no need for user access lookups 

JWT's may be vulnerable if there is CSRF attacks to grab tokens

3 - Securing the Payload
Taking Q & A from the audience
JWT's can be implemented in SPA's but will look different
JWT supports encryption via JWE
More information available at
  - https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3
Demo app uses BCrypt for password hashing and is recommended by the instructor
Signing JWT Sunction Syntax
  // First the the user will be verified in the database
  // Then a token will be issued
  return jwt.sign({
    sub: user.id,
    username: user.username,
    email: user.email,
    gravatar: createGravatarUrl(user.email),
    scope
  // Secret should be unguessable, strings, about 64 in length
  // Best practice is to have it as an environmental variable and not to have it in a repository
  }, secret, { 
    algorithm: 'HS256',
    expiresIn: "1h" 
  });


4 - Implementing Authentication with JWT
How implementing JWT actually works in practice
How does the SPA get the JWT
  - The user submits their credentials
  - If the credentials are valid a JWT is signed and returned in response
  - A secret key known only by the server is used to sign the JWT
JWT Storage
Once the JWT comes back it will be stored somewhere in the user's browser
Storing in memory would be a poor choice as the token would be lost when the page is refreshed
JWT's are typically stored in browser storage(local storage or session storage) or in HTTP only cookies
Example Syntax -> uses the Angular 2 example app
  finishAuthentication(token): void{
    localStorage.setItem('token', token);
    this.router.navigate([profile]);
  }
  
  logout(): void{
    localStorage.removeItem('token');
  }
Its very important to keep secret keys protected
Good practice is to have short lived tokens you should not have tokens with long expiry times
Expiry time should be around 10 hours
Expiry time is checked when the token is sent to the server
Removing the token from where it is being stored will logout due to it being stateless
If the user has copied the token it could mean that they are still logged in
Some organisations have issues with the way JWT's operate as revoking is not easy in JWT authentication
Login Component Syntax
  export class LoginComponent{
    errorMessage: string;
    
    constructor(private auth: AuthService){};
    
    onLoginSubmit(credentials){
      this.auth.login(credentials)
      .map(res => res.json())
      .subscribe(
        response => this.auth.finishAuthentication(response.token),
        error => this.errorMessage = error.josn().message;
      )
    }
    
    onSignupSubmit(credentials){
      this.auth.signup(credentials)
      .map(res => res.json())
      .subscribe(
        response => this.auth.finishAuthentication(response.token),
        error => this.errorMessage = error.josn().message;
      )
    }
  }
