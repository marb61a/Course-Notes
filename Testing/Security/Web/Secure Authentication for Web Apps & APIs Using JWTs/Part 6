                    Secure Authentication for Web Apps & APIs Using JWTs
                    Course Notes Part 6
                    
                    
4 - Challenge: Protecting Resources

Official repo for the Angular 2 challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/04-protecting-resources-starter

5 - Protecting Resources Challenge Solution
Solution Syntax
  // instructor.service.ts
  @Injectable
  export class InstructorService {
    constructor(private http: Http, private authHttp: AuthHttp){}
    
    public getInstructors(): Observable<Response> {
      return this.authHttp.get(`${API_URL}/instructors`);
    }
    
    public addInstructor(data): Observable<Response> {
      return this.authHttp.post(`${API_URL}/instructors`, data);
    }
  }
  
  //instructor.component.ts
  private getInstructors(){
    this.instructorService.getInstructors()
      .map(res => res.json())
      .subscribe(
        data => this.instructors = data
        error => this.errorMessage = error.json().message
      )
  }
  
  //new-instructor.component.ts
  addInstructor(data){
    this.instructorService.addInstructor(data)
    map(res => res.json())
      .subscribe(
        data => this.goBack(),
        error => console.log( error.json().message)
      )
  }

The official Angular 2 based solution to the challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/04-protecting-resources-solution
  
  
  
                    Section 6 - Protecting Routes
1 - Client-Side Considerations
This section is about the approach to protecting routes in the application
Using SPA means that codes is not segemented into as many folders etc
There are considerations for the client-side that must be kept in mind
  - Server resources are limited to only requests that have a valid JWT
  - What about limiting access on the client side
  - Some common considerations are
    - Users should only be able to navigate to proteted routes if they are authenticated
    - If a route requires a certain access level users should only be able to navigate if they have the appropriate scope
    - Certain UI elements should only be rendered if the above conditions are met
Protecting client side routes and UI elements has a big problem, which is that it is easy to forge
  - The user can modify the exp time or scope in their own JWT
  - We cannot verify the signature of the JWT on the client side because the secret never leaves the server
Protecting Routes
  - But does it matter?
  - In the end protected resources should remain on the server anyway
    - Anything in the client-side is easily visible by anyone using dev-tools
  - If a user manages to hack their way into a protected route they won't be able to get resources from the server
Example Scenario
  - What happens if a User modifies the JWT
    - We use Javascript to limit a route to authenticated users who also have a scope of admin
    - A user who only has a scope of user decides to modify their JWT in the debugger at jwt.io
    - They gain access to the route which is populated by resources from the server
    - What happens?

2 - How Client-Side Routes are Protected
When a route transition begins the exp time in the JWT is checked
  - If the JWT is expired then the transition is disallowed
If a route requires a certain access level the scope in the JWT is checked when the transition starts
  - If the JWT does not include the desired scope then the transaction is disallowed
Implementation details do differ by framework
Many frameworks have their own implementations for controlling route access
  - Angular 1.x router events($routechangestart)
  - Angular 2, this implements a CanActivate hook
  - React (ReactRouter) has an onEnterEvent
Example Syntax
  export interface CanActivate {
    canActivate(route: ActivateRouteSnapshot, state: RouterStateSnapshot):
      Observable<boolean> | Promise<boolean> | boolean
  }

  @Injectable
  export classs AuthGuard implements CanActivate {
    constructor(private auth: AuthService, private router: Router){}
    
    canActivate(){
      if(this.auth.isAuthenticated()){
        return true;
      } else {
        this.router.navigate(['login'])
      }
    }
  }
