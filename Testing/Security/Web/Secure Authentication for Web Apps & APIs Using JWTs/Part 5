                    Secure Authentication for Web Apps & APIs Using JWTs
                    Course Notes Part 5


                    Section 4 - User Information in the Payload
1 - Decoding a JWT
Finding user information in the payload
Example Syntax Profile Component
// You probably won't have that much information in the token about the user
  export class profileComponent implements OnInit{
    profile: Profile,
    payload: Object;
    
    constructor(private auth: AuthService){}
    
    ngOnInit(){
      this.profile = jwtDecode(this.auth.getToken());
      this.payload = jwtDecode(this.auth.getToken());
      this.profile.gravatar = `${this.profile.gravater}?s=200`;
    }
  }

2 - Payload Best Practices
Although tempting do not put the whole profile object in the payload
Important to keep the JWT small as it is sent over the network on all requests
Keep sensitive information out as JWT is decodable
Consider a separate endpoint which retrieves a user profile object if a lot of profile data is needed

3 - Challenge: Reading the Payload
The challenges for this section are
  - Checkout branch 03-user-profile-starter, available at
    - https://github.com/chenkie/angular2-user-authentication/tree/03-user-profile-starter
  - Read the user's profile from the JWT payload
    - There are libraries available
  - Display the user's details in a profile view question asked by a student about stale data
    - What happens if data becomes stale, eg user has elevated permissions during session, would user have to 
      log out and back in.
  - The solution once again is situation dependent and you may want to make use of a token blacklisting mechanism
    - There could also be a data checking mechanism introduced on the backend
  - You can use tokens as similar to API keys as they have the same granular control
    - You can fine tune what resources user has access to and what type of access eg read & write

4 - Reading the Payload Solution
Example Syntax
  // Use the jwtdecode library
  ngOnInit(){
    this.profile = jwtDecode(this.auth.getToken());
    this.payload = jwtDecode(this.auth.getToken());
    this.profile.gravatar = `${this.profile.gravater}?s=200`;
    
  }
The code from the Angular 2 example that is complete is available here
  - https://github.com/chenkie/angular2-user-authentication/tree/03-user-profile-solution
  
  
  
                    Section 5 - Protecting Resources
1 - How JWTâ€™s Protect Resources
Protecting resources is a very important part of JWT
  - The main point of adding authentication to an application is to restrict resource access to thoes who have
    proven that they are allowed access to those resources
  - There are different levels of access
    - Publically Accessible which means that resources are open to everyone
    - Limited to Authenticated Users which means the data is open to anyone that is logged in
    - Limited to only on e authenticated user which means data is open to only the user logged in
    - Limited to a subset of Authenticated Users which means that access is open to anyone of a particular privilege level
How do JWT's help us protect resources
  - We can create endpoints for our resources that require an authentication check
  - To pass the check a valid JWT must be present
  - When making HTTP requests we can send the JWT as an authentication header
  - The header is then read at the API and if valid then the resource becomes valid

2 - Exploring JWT Middleware
Exploring API Verification Code in the example server.js file
Example Syntax
  // This example uses hapi.js rather than express.js
  server.register(require('hapi-auth-jwt'), (err) => {
    // The name of the strategy in the example is jwt
    server.auth.strategy('jwt', 'jwt', 'required', {
      key: process.env.SECRET_KEY,
      verifyOptions: {
        algorithms: ['HS256']
      }
    })
  })

3 - Making Authenticated Requests
Sending authentication requests requires retrieving the JWT from storage and attaching it as an Authorization header
Some of the common implementations are
  - Explicitly on a per-request basis
  - Globally on all requests
  - Only requests of a certain kind
Storing the JWT in a cookie means that it will go to the server on every request
Example Syntax
  let headers = new Headers();
  // The Bearer is used as a authorisation scheme in oauth others include Digest and Basic
  headers.append('Authorization', 'Bearer' + token);
  this.http.get(API_URL, { headers })
    . map(res => res.json())
    .subscribe(data => console.log(data));
  
provideAuth Syntax using Angular 2 syntax
  @NgModule({
    declarations: [],
    imports: [],
    providers: [
      AuthService,
      AuthGuard,
      RoleGuard,
      provideAuth({
        tokenGetter : () => {return localStorage.getItem('token')}  
      }),
      instructorService
    ],
    bootstrap: [AppComponent]
  })
  export class AppModule

4 - Challenge: Protecting Resources

Official repo for the Angular 2 challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/04-protecting-resources-starter

5 - Protecting Resources Challenge Solution
Solution Syntax
  // instructor.service.ts
  @Injectable
  export class InstructorService {
    constructor(private http: Http, private authHttp: AuthHttp){}
    
    public getInstructors(): Observable<Response> {
      return this.authHttp.get(`${API_URL}/instructors`);
    }
    
    public addInstructor(data): Observable<Response> {
      return this.authHttp.post(`${API_URL}/instructors`, data);
    }
  }
  
  //instructor.component.ts
  private getInstructors(){
    this.instructorService.getInstructors()
      .map(res => res.json())
      .subscribe(
        data => this.instructors = data
        error => this.errorMessage = error.json().message
      )
  }
  
  //new-instructor.component.ts
  addInstructor(data){
    this.instructorService.addInstructor(data)
    map(res => res.json())
      .subscribe(
        data => this.goBack(),
        error => console.log( error.json().message)
      )
  }

The official Angular 2 based solution to the challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/04-protecting-resources-solution
  
  
  
                    Section 6 - Protecting Routes
1 - Client-Side Considerations
This section is about the approach to protecting routes in the application
Using SPA means that codes is not segemented into as many folders etc
There are considerations for the client-side that must be kept in mind
  - Server resources are limited to only requests that have a valid JWT
  - What about limiting access on the client side
  - Some common considerations are
    - Users should only be able to navigate to proteted routes if they are authenticated
    - If a route requires a certain access level users should only be able to navigate if they have the appropriate scope
    - Certain UI elements should only be rendered if the above conditions are met
Protecting client side routes and UI elements has a big problem, which is that it is easy to forge
  - The user can modify the exp time or scope in their own JWT
  - We cannot verify the signature of the JWT on the client side because the secret never leaves the server
Protecting Routes
  - But does it matter?
  - In the end protected resources should remain on the server anyway
    - Anything in the client-side is easily visible by anyone using dev-tools
  - If a user manages to hack their way into a protected route they won't be able to get resources from the server
Example Scenario
  - What happens if a User modifies the JWT
    - We use Javascript to limit a route to authenticated users who also have a scope of admin
    - A user who only has a scope of user decides to modify their JWT in the debugger at jwt.io
    - They gain access to the route which is populated by resources from the server
    - What happens?

2 - How Client-Side Routes are Protected
When a route transition begins the exp time in the JWT is checked
  - If the JWT is expired then the transition is disallowed
If a route requires a certain access level the scope in the JWT is checked when the transition starts
  - If the JWT does not include the desired scope then the transaction is disallowed
Implementation details do differ by framework
Many frameworks have their own implementations for controlling route access
  - Angular 1.x router events($routechangestart)
  - Angular 2, this implements a CanActivate hook
  - React (ReactRouter) has an onEnterEvent
Example Syntax
  export interface CanActivate {
    canActivate(route: ActivateRouteSnapshot, state: RouterStateSnapshot):
      Observable<boolean> | Promise<boolean> | boolean
  }

  @Injectable
  export classs AuthGuard implements CanActivate {
    constructor(private auth: AuthService, private router: Router){}
    
    canActivate(){
      if(this.auth.isAuthenticated()){
        return true;
      } else {
        this.router.navigate(['login'])
      }
    }
  }

3 - Challenge: Protecting Routes
Check out the 05 branch
  - 05-protecting-routes-starter
For the instructor route check that the user's JWT is unexpired before the route transition begins
For the instructor/new route check the the user's JWT is unexpired and that they have the scope of admin
Hide the new instructor button if the user is not an admin
Official repo for the Angular 2 challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/05-protecting-routes-starter

4 - Protecting Routes Solution
Solution Syntax
  // The solution will look different from one framework to the other
  // authguard.service.ts file
  @Injectable()
  export class AuthGuard implements CanActivate{
    constructor(private auth: AuthService, private router: Router){}
    
    canActivate(){
      if(this.auth.isAuthenticated()){
        return true;
      } else {
        // Navigate to the login route if the user becomes unauthenticated
        this.router.navigate(['login']);
      }
    }
  }
  
  // In the app.routes.ts check to see that the user is authenticated
  {path: 'instructor', component: 'InstructorComponent', canActivate: [AuthGuard]}
  {path: 'instructor/new', component: 'NewInstructorComponent', canActivate: [RoleGuard]}
  
  //Roleguard.service.ts
  @Injectable()
  export class RoleGuard implements CanActivate{
    constructor(private auth: AuthService, private router: Router){}
    
    canActivate(){
      if(this.auth.isAuthenticated() && this.auth.isAdmin()){
        return true;
      } else {
        // Navigate to the login route if the user becomes unauthenticated
        this.router.navigate(['login']);
      }
    }
  }

The official Angular 2 based solution to the challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/05-protecting-routes-solution

5 - Further Reading & Wrap-Up
There are some important security considerations to be mindful of
  - Nothing is 100% secure including JWT
  - Some common attack vectors include
    - XSS -- Cross Site Scripting (if using local storage)
    - CSRF -- Cross Site Request Forgery (if using cookies)
    - MITM -- Man In The Middle
  - Always server your app and API over HTTPS
  - Always escape user input and put CSRF protections in place if needed
  - JWT describes how computers can communicate securely with each other but does not recommend an implementation
  - It will be up to the person implementing it to decide if it is secure
  - OAuth and OIDC standardise authentication and authorization
    - They maybe the best solution for your needs in cases despite the complexity
Refresh Tokens
  - These are a very special type of token which is exchanged for a new JWT
  - They can be used to extend a client session
  - Refresh tokens should not be stored on the browser and should only live on the server
Some recommended reading 
  - Auth0 blog
  - OpenId Connect blog
  - Various RFC
