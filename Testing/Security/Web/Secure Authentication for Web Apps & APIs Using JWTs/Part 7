                    Secure Authentication for Web Apps & APIs Using JWTs
                    Course Notes Part 7


3 - Challenge: Protecting Routes
Check out the 05 branch
  - 05-protecting-routes-starter
For the instructor route check that the user's JWT is unexpired before the route transition begins
For the instructor/new route check the the user's JWT is unexpired and that they have the scope of admin
Hide the new instructor button if the user is not an admin
Official repo for the Angular 2 challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/05-protecting-routes-starter

4 - Protecting Routes Solution
Solution Syntax
  // The solution will look different from one framework to the other
  // authguard.service.ts file
  @Injectable()
  export class AuthGuard implements CanActivate{
    constructor(private auth: AuthService, private router: Router){}
    
    canActivate(){
      if(this.auth.isAuthenticated()){
        return true;
      } else {
        // Navigate to the login route if the user becomes unauthenticated
        this.router.navigate(['login']);
      }
    }
  }
  
  // In the app.routes.ts check to see that the user is authenticated
  {path: 'instructor', component: 'InstructorComponent', canActivate: [AuthGuard]}
  {path: 'instructor/new', component: 'NewInstructorComponent', canActivate: [RoleGuard]}
  
  //Roleguard.service.ts
  @Injectable()
  export class RoleGuard implements CanActivate{
    constructor(private auth: AuthService, private router: Router){}
    
    canActivate(){
      if(this.auth.isAuthenticated() && this.auth.isAdmin()){
        return true;
      } else {
        // Navigate to the login route if the user becomes unauthenticated
        this.router.navigate(['login']);
      }
    }
  }

The official Angular 2 based solution to the challenge
  - https://github.com/chenkie/angular2-user-authentication/tree/05-protecting-routes-solution

5 - Further Reading & Wrap-Up
There are some important security considerations to be mindful of
  - Nothing is 100% secure including JWT
  - Some common attack vectors include
    - XSS -- Cross Site Scripting (if using local storage)
    - CSRF -- Cross Site Request Forgery (if using cookies)
    - MITM -- Man In The Middle
  - Always server your app and API over HTTPS
  - Always escape user input and put CSRF protections in place if needed
  - JWT describes how computers can communicate securely with each other but does not recommend an implementation
  - It will be up to the person implementing it to decide if it is secure
  - OAuth and OIDC standardise authentication and authorization
    - They maybe the best solution for your needs in cases despite the complexity
Refresh Tokens
  - These are a very special type of token which is exchanged for a new JWT
  - They can be used to extend a client session
  - Refresh tokens should not be stored on the browser and should only live on the server
Some recommended reading 
  - Auth0 blog
  - OpenId Connect blog
  - Various RFC
                    
