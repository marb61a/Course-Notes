                    Web Security 
                    Course Notes
                    
                    
                    Section - 1 
Web Development has a huge security problem
  - Web Developers have fallen behind DevOps and Back End developers
Features & Deadlines are always in competition with security
  - This is true also of Techical Debt
  - The main reason is the business value or perceived value to the business
Attacks are escalating in their severity and impact
  - This is compounded by the fact that barriers to attack launch are lower than ever
There is a sample app provided that the course will use for launching practice attacks on
  - There are some incomplete features which expand the list of available attack vectors
  - This can happen in real life with future feature flags left in which arent working yet
There course will make use of both viewpoints 
  - The student will be launching attacks on the app
  - After the attacks then there will be how to shore up the defences
    - This will hopefully get to the stage of negating many of the attacks
The app will use cookie based authentication
  - It will be tested using IE9
  - This is because of the need for different data points
    - Modern browsers which negate some attacks automatically and older ones which don't but are still in use

There are 3 main types of hackers
  - Black Hat
    - These break into systems to cause damage or hold data for ransom and are usually drive by personal gain
  - Grey Hat
    - These types break into systems but cause no damage and are usually driven by curiosity
  - White Hat
    - These types of hackers break into systems with permission and report what they find
    - They also use a process called responsible disclosure for vulnerabilities they find to give time for fixes

The M.O. of an attacker
  - Use various methods to gather information about your system
  - Research any vulnerabilities which may exist
  - Get an initial foothold in the system
    - Use the foothold to escalate to more serious attacks
    - The vulnerability is the game-over situation
    - Small scale footholds mean that the situation maybe beyond fixing
    - This means that the bar on recognising game-over situations should be lowered
The Agenda of the course will cover
  - Multiple attacks on the client
  - Cross Site Scripting (xss)
  - 3rd party assets eg npm dependencies
  - Cross Site Request Forgeries (CSRF)
  - Clickjacking Attcks which are also called UI redress attacks
  - CDN resource tampering
    - CDN's are not bullet proof, they are ran by people too!!
  - Https downgrade attacks
  - Man In The Middle Attacks

Client Side Attacks
  - The first client side attack to be discussed is also the most prevalent XSS
    - It is called XSS because CSS already means something else
    - It is basically putting code where text is expected and tricking the browser into executing the code
    - It is an injection attack
    - Vulnerabilities are prevalent
      - The number of sites vulnerable is a minimum of 30%
      - Accurate data is not easy to obtain as most reports are from firms selling pen testing services
    - It allows an attacker to read data or perform operations on a users behalf
    - Example code which could allow XSS
      - This is ejs (embedded JS)
      <h1>Welcome, <%- name %></h1>
      name = "Mike";
      // Welcome Mike is returned
      // What would happen if code was injected
      <h1>Welcome, <%- name %></h1>
      name = "Mike<script>terrible()</script>"
      // This would be returned and the terrible script ran
      <h1>Welcome, Mike<script>terrible()</script></h1>
  - There are 4 main categories of XSS attacks
    - The instructor says 3 + 1 as the final one is debatable
  - Stored XSS
    - Code that executes the attackers script is persisted
    - This is usually added to a database
  - Reflected XSS
    - Transient response from a server causes a script to execute
    - A temporary server response can be tricked in to executing code
  - DOM Based XSS
    - These attacks do not have any server involvement
    - This means that code is passed in via queryParams
  - Blind XSS
    - It could be argued that this is the same as Stored XSS
    - This exploits a vulnerability in another app that an attacker cannot see or access under normal means
      - The example used is of a log reader app
      - There is likely to be less scrutiny of an internal app
      - These internal apps usually pull in public data so are attack veectors

There are several XSS danger zones where attacks can happen
  - User-generated rich content eg WYSIWYG
  - Embedded content eg IFrame
  - Anywhere where users have control over a URL
    - Older browsers allowed url's like -- javascript:image_url
  - Anywhere that user input is reflected back
  - QueryParameters that are rendered into DOM
  - element.innerHTML = ?
    - This is a very easy exploit as it allows script tags

Using the Linux distro Kali for demonstration
  - https://www.kali.org
  - This has a whole suite of security tools
  - The tools themselves can be used for good and bad
  - The course demonstrates an ARP attack
    - Web developers don't usually know how these things work
  - HTTPS can obviate some of the ARP attacks
  - There can be simple XSS attacks that do not need to be crafted
  - Phonegap and similar can be very dangerous
    - Ionic is highly optimised Phonegap
    - Most dangerous is the frameworks that essentially use webview iframes
      - These can break through traditional web app sandboxing
      - This is dangerous as Javascript binds to native functions and breaks through mobile sandboxes

XSS - As a feature
  - Some companies are starting to treat XSS as a feature
  - This is a very bad idea
    - A compnay called XFinity has been injecting its script on Reddit

XSS Questions you should ask yourself
  - How confident are you in the XSS protection of your OSS libraries
    - One thing that should be looked for particularly in a view library is that
      - There is a procedure for resolving security issues eg email address that supports specific issues
      - GitHub issues are not appropriate in this case
      - Be careful about using browsers older than supported
  - How carefully do people scrutinize browser plugins
    - Few people read the full permissions of plugins
    - Be skeptical of plugins asking for permissions going beyond what is needed
    - Instructor suggests using incognito tab for online banking
  - If XSS happens what is the exposure
  - In your app waht could a successful XSS attack escalate to 
    - This will differ form one organisation to another
    - This will also determine bug fixes etc at compromise will take precedence
There are 3 XSS vulnerabilities in the sample app
  - 2 of these are Reflected-XSS
  - Use multiple browsers to simulate multiple users
  - Students should try use at least one legacy browser when testing
  - Hosting can be done locally using *.lvh.me
    - This is essentially a DNS trick that resolves to localhost
    - It allows for having multiple domains, which is good for experimenting
The sample app
  - Will have to be cloned from a GitHub repo
  - Use yarn to install the packages
  - When registering in the app do not use a password that is used elsewhere
  - The challenge is to find the other 2 XSS vulnerabilities

    
                    Section - 2                 
The solutions to the XSS challenges
  - When creating an account HTML tags can be added
    - In the example this is a <b> tag which makes things bold
    - This should be eliminated without being run as it means other code will be run
  - The next vulnerability is both a stored and reflected vulnerability
    - This happens after an account with a script is ran
    - The account is registered without warnings and a success message is shown
    - Inspecting the element shows the script tags inside the panel
  - The third vulnerabiity is found on the profile page
    - In the url the user is listed which should not happen
    - Adding a script tag is ran which would not happen in modern browsers
    - There is a console.log added in the script tags to stop pattern matching which would stop the script being ran
    
XSS Defenses - You should never put untrusted data in the following places
  - Directly in a script -- EG <script> <%- userData %> </script>
  - In a HTML comment -- EG <!--- <%- userData %> --->
  - In an attribute name -- EG <iframe <%- userData %>="myValue" />
  - In a tag name -- EG <<%- userData %> class="myElement">
  - Directly in a style block -- EG <style> <%- userData %> </style>
    - This is very difficult to do in modern browsers
  - On a general basis never trust raw user data
  - Escape user data before putting it into HTML, there are 2 things which you should do
    - Sanitize user data prior to persisting
    - Then sanitize it prior to being rendered to a screen
    - You should typically do both of these
    - Its easier to sanitize before rendering than worrying about disallowing all bad things without interfering with
      genuine user input
Example Syntax
  <script>alert('hi')</script>
  // This is gotten by using encodeURIComponent() function
  "%3Cscript%3Ealert('hi')%3C%2Fscript%3E"
  - Most view libraries do this automatically
  - EJS is used for the class and its the following
    <%= "Escaped Expression" %>
    <%- "Unescaped Expression" %>
    <% "Non-Rendered Expression" %>

XSS Defenses - If you unescape then sanitize data first
  - These are some cheats for different libraries so you will know when you are in a danger zone
    - Ember & Vue -- {{{ "unescaped" }}}
      - This string will be treated as Html 
    - React -- return <div dangerouslySetInnerHTML={createMarkup()}/>;
    - Ejs -- <%- "Unescaped" %>
      - The course example app has a couple of examples of this issue which will need to be fixed
      - In this case the minus sign needs to be changed to an equals
    - Angular -- <div [innerHTML]="unescaped"></div>
    - Jade -- ! This is #{"<b>unescaped</b>"}!

Escape before putting user data in attributes
  - <div class="<%= 'UserValue' %>"></div>
  - Be especially careful of this when templating Javascript
    - <script>alert("Hello <%- userValue %>")</script>
  - Recommended to use https://github.com/ESAPI/node-esapi
    - This will check your app for issues, it is highly recommended by the instructor
  - User input should be treated as values not code

XSS Defenses Content Security Policy
  - Browsers cannot tell the difference between scripts downloaded from you origin vs another
    - This is called a single execution context
  - CSP allows modern browsers to be told which sources they should trust and for what type of resources
  - This information comes from a HTTP response header or meta tag
      - Content-Security_Policy: script-src 'self' https://example.example
                                 ---------         -----------------------
                                   name             sources
                                |--------------- directive ----------------|
                                
    - Multiple directives are allowed and are separated by semi-colon
    - Redefining a driective with the same name has no effect
    - By default directives are permissive
      - Content-Security-Policy: script-src: 'self' https://example.example;
                                 font-src: https://fonts.googleapis.com
  - There are some useful CSP directivess
    - child-src -- Child execution contexts eg frames, workers
    - connect-src -- What you can connect to such as fetch, WebSocket, EventSource
    - form-action -- Where you can <form> submit to
    - img-src, media-src, object-src -- Where you can get images, media etc from
    - style-src -- Where external stylesheets can come from
    - upgrade-insecure-requests - Upgrades HTTP requests to HTTPS
    - default-src -- A fallback for when a specific directive is not provided
  - There are also some keywords which can be used alongside sources which are typically origins
    - none -- No sources allowed
    - self -- Current origin
    - unsafe-inline -- Allows inline JS and CSS
    - unsafe-eval -- Allows eval()
      - This is used by templating frameworks where a string is sent and evaluated juust in time
      - This improves the performance of webpages
 There are a few ways the unsafe-inline can be made a little safer
  - Script tags embedded in HTML is the most common form of XSS and banning it mitigates risk considerably
  - There are times however where JavaScript is needed and there are solutions
  - Cryptographic nonces must be generated per page load and must change unpredictably
Example Syntax
  // Cryptographic nonce example
  <script nonce=A9h3pdfn3f03nce8DnMIOErd7Gb>
    alert('This example is done inlne');
  </script>
  
  Content-Security-Policy: script-src 'nonce-A9h3pdfn3f03nce8DnMIOErd7Gb'
  
  Another way to do this is to add a checksum to the security policy 
    - Content-Security-Policy: script-src 'sha256-absd182.....='
    - The easiest way to define this is to use the browser itself
    - Use the error generated and move that into the CSP

The exercise in this section is to
  - Fix 3 XSS issues
  - Add a reasonable CSP to the example project
    - There is a library available to help with this
      - https://github.com/helmetjs/csp



Section - 3       
Implementing XSS defences
  - Custom linting rules can be used to scan and eliminate unsafe-inline
  - This also is useful with a Git pre-commit hook
  - Eliminating using automation is a good idea and it should be done as early as possible
  
                    

Section - 4                   
                    
                    Section - 5                   
                    
                    Section - 6                   
                    
                    Section - 7                   
                    
                    Section - 8                   
                    
                    Section - 9                   
                    
                    Section - 10                   
