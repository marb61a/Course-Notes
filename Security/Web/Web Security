                    Web Security 
                    Course Notes


                    Section 1 - Introduction
1 - Introduction
Web Development has a huge security problem
  - Web Developers have fallen behind DevOps and Back End developers
Features & Deadlines are always in competition with security
  - This is true also of Techical Debt
  - The main reason is the business value or perceived value to the business
Attacks are escalating in their severity and impact
  - This is compounded by the fact that barriers to attack launch are lower than ever
  
2 - Course Demo Application
There is a sample app provided that the course will use for launching practice attacks on
  - There are some incomplete features which expand the list of available attack vectors
  - This can happen in real life with future feature flags left in which arent working yet
There course will make use of both viewpoints 
  - The student will be launching attacks on the app
  - After the attacks then there will be how to shore up the defences
    - This will hopefully get to the stage of negating many of the attacks
The app will use cookie based authentication
  - It will be tested using IE9
  - This is because of the need for different data points
    - Modern browsers which negate some attacks automatically and older ones which don't but are still in use

3 - Types of Hackers
There are 3 main types of hackers
  - Black Hat
    - These break into systems to cause damage or hold data for ransom and are usually drive by personal gain
  - Grey Hat
    - These types break into systems but cause no damage and are usually driven by curiosity
  - White Hat
    - These types of hackers break into systems with permission and report what they find
    - They also use a process called responsible disclosure for vulnerabilities they find to give time for fixes

4 - Hacker Motives
The M.O. of an attacker
  - Use various methods to gather information about your system
  - Research any vulnerabilities which may exist
  - Get an initial foothold in the system
    - Use the foothold to escalate to more serious attacks
    - The vulnerability is the game-over situation
    - Small scale footholds mean that the situation maybe beyond fixing
    - This means that the bar on recognising game-over situations should be lowered

5 - Course Agenda
The Agenda of the course will cover
  - Multiple attacks on the client
  - Cross Site Scripting (xss)
  - 3rd party assets eg npm dependencies
  - Cross Site Request Forgeries (CSRF)
  - Clickjacking Attcks which are also called UI redress attacks
  - CDN resource tampering
    - CDN's are not bullet proof, they are ran by people too!!
  - Https downgrade attacks
  - Man In The Middle Attacks



                    Section 2 - Cross-Site Scripting (XSS)
1 - Introducing Cross-Site Scripting (XSS)

2 - Types of XSS Attacks

3 - Locations for XSS Attacks

4 - XSS Attack Demonstration

5 - Prevent XSS Attacks Quiz

6 - Challenge 1: XSS Attack

7 - Challenge 1: Solution

8 - User Data

9 - Sanitizing User Data

10 - Content Security Policy (CSP)

11 - Challenge 2: Defend Against XSS Attacks

12 - Challenge 2: Solution, Part 1

13 - Challenge 2: Solution, Part 2

14 - Malicious Attachments

15 - Challenge 3: XSS Attachment

16 - Challenge 3: Solution

17 - Stopping Malicious Attachments



                    Section 3 - Cross-Site Request Forgery (CSRF)
1 - Introducing Cross-Site Request Forgery (CSRF)

2 - Challenge 4: CSRF

3 - Challenge 4: Solution

4 - CSRF Tokens

5 - Request Origin
02:17:34 - 02:19:14
Request Origin
Mike introduces the Origin header, which indicates where a fetch originates from. The Origin includess only the server name and not any additional path information.
Cross-Origin Resource Sharing (CORS)
02:19:15 - 02:21:19
Cross-Origin Resource Sharing (CORS)
Mike reviews Cross-Origin Resource Sharing, which allows servers a mechanism for restricting resources requested from another site hosted outside the domain from which the first resource was served.
Challenge: 5: Defend Against CSRF
02:21:20 - 02:25:07
Challenge: 5: Defend Against CSRF
In this challenge, students add CSRF protection. JSBIN
Challenge: 5: Solution



                    Section 4 - Clickjacking
1 - Introducing Clickjacking

2 - Challenge 6: Clickjacking

3 - Challenge 6: Solution

4 - Stopping Clickjacking

5 - Challenge 7: Defend Against Clickjacking
02:42:45 - 02:45:06
Challenge 7: Defend Against Clickjacking
In this challenge, students add modern and legacy defense against clickjacking.
Challenge 7: Solution
02:45:07 - 02:50:06
Challenge 7: Solution
Mike walks through the solution to Challenge 7.



                    Section 5 - Third Party Assets
1 - Introducing Third Party Assets

2 - Challenge 8: Subresource Integrity

3 - Challenge 8: Solution
03:04:03 - 03:08:31
Challenge 8: Solution
Mike walks through the solution to Challenge 8.
Man-in-the-Middle

Introducing Man-in-the-Middle Attacks
03:08:32 - 03:16:42
Introducing Man-in-the-Middle Attacks
After reviewing client-side security, Mike starts examining into server-side security by first looking at Man-in-the-Middle attacks. Man-in-the-Middle is a result of an unknown attacker channeling network communication between two parties.
Hardware
03:16:43 - 03:21:12
Hardware
Mike examines hardware gear necessary to perform Man-in-the-Middle attacks.
Encrypting Data
03:21:13 - 03:23:52
Encrypting Data
Mike introduces data encryption for defending against Man-in-the-Middle attacks.
HTTPS

Introducing HTTPS
03:23:53 - 03:26:44
Introducing HTTPS
Mike reviews HTTPS recent prominence and easy access through Let's Encrypt, a service that provides free SSL/TLS certificates. - https://letsencrypt.org/
HTTPS & Cryptography
03:26:45 - 03:34:21
HTTPS & Cryptography
Mike illustrates how cryptography is used in securing communication, especially with the use of public key encryption.
TLS Handshake
03:34:22 - 03:36:52
TLS Handshake
Mike deconstructs a TLS Handshake, a protocol in charge of the authentication and key exchange necessary to establish secure sessions.
OpenSSL
03:36:53 - 03:40:13
OpenSSL
Mike reviews how to generate keys and sign certificates with OpenSSL, a software library for applications that secure communications over computer networks.
Challenge 9: Defend Against Man-in-the-Middle Attack
03:40:14 - 03:41:17
Challenge 9: Defend Against Man-in-the-Middle Attack
In this challenge, students generate a private, serve the course demo application over HTTPS, and add a certificate to OS's trust store.
Challenge 9: Solution
03:41:18 - 03:58:34
Challenge 9: Solution
Mike walks through the solution to Challenge 9.
HTTPS Downgrade

Introducing HTTPS Downgrade
03:58:35 - 04:01:35
Introducing HTTPS Downgrade
Mike describes HTTPS downgrade, which is a variant of the Man-in-the-Middle attack where the attacker acts a proxy between the user and the secure server.
Defending Against HTTPS Downgrade
04:01:36 - 04:03:12
Defending Against HTTPS Downgrade
Mike discusses techniques to force conntections to use HTTPS.
Bad Certificate
04:03:13 - 04:08:12
Bad Certificate
Through a Man-in-the-Middle approach, Mike reviews how an attacker might forge a certificate to compromise communication between two networks.
Defending Against Bad Certificates
04:08:13 - 04:11:42
Defending Against Bad Certificates
To defend against an attack using bad certificates, Mike discusses setting the HTTP Strict-Transport-Security (HSTS) response header that tells browsers to only accept access through HTTPS. - https://hstspreload.org/
Challenge & Solution 10: Defend Against HTTPS Downgrade
04:11:43 - 04:21:29
Challenge & Solution 10: Defend Against HTTPS Downgrade
After reviewing the challenge of adding HSTS to course demo application, Mike walks through the solution.
Certificate Authority Compromise
04:21:30 - 04:29:15
Certificate Authority Compromise
Mike discusses concerns for when certificate authority, organizations entrusted with distributing certificates, become compromised. Due to modern browsers, Public Key Pinning Extension for HTML5 (HPKP) lowers the risks of forged certificates. - http://www.computerweekly.com/news/4500242932/Google-warns-of-fake-digital-certificates
Wrapping Up

Wrapping Up Web Security
04:29:16 - 04:31:47
Wrapping Up Web Security
Mike recaps the attacks and defenses covered in the Web Security course.

                    
                    Section - 1 
    


Client Side Attacks
  - The first client side attack to be discussed is also the most prevalent XSS
    - It is called XSS because CSS already means something else
    - It is basically putting code where text is expected and tricking the browser into executing the code
    - It is an injection attack
    - Vulnerabilities are prevalent
      - The number of sites vulnerable is a minimum of 30%
      - Accurate data is not easy to obtain as most reports are from firms selling pen testing services
    - It allows an attacker to read data or perform operations on a users behalf
    - Example code which could allow XSS
      - This is ejs (embedded JS)
      <h1>Welcome, <%- name %></h1>
      name = "Mike";
      // Welcome Mike is returned
      // What would happen if code was injected
      <h1>Welcome, <%- name %></h1>
      name = "Mike<script>terrible()</script>"
      // This would be returned and the terrible script ran
      <h1>Welcome, Mike<script>terrible()</script></h1>
  - There are 4 main categories of XSS attacks
    - The instructor says 3 + 1 as the final one is debatable
  - Stored XSS
    - Code that executes the attackers script is persisted
    - This is usually added to a database
  - Reflected XSS
    - Transient response from a server causes a script to execute
    - A temporary server response can be tricked in to executing code
  - DOM Based XSS
    - These attacks do not have any server involvement
    - This means that code is passed in via queryParams
  - Blind XSS
    - It could be argued that this is the same as Stored XSS
    - This exploits a vulnerability in another app that an attacker cannot see or access under normal means
      - The example used is of a log reader app
      - There is likely to be less scrutiny of an internal app
      - These internal apps usually pull in public data so are attack veectors

There are several XSS danger zones where attacks can happen
  - User-generated rich content eg WYSIWYG
  - Embedded content eg IFrame
  - Anywhere where users have control over a URL
    - Older browsers allowed url's like -- javascript:image_url
  - Anywhere that user input is reflected back
  - QueryParameters that are rendered into DOM
  - element.innerHTML = ?
    - This is a very easy exploit as it allows script tags

Using the Linux distro Kali for demonstration
  - https://www.kali.org
  - This has a whole suite of security tools
  - The tools themselves can be used for good and bad
  - The course demonstrates an ARP attack
    - Web developers don't usually know how these things work
  - HTTPS can obviate some of the ARP attacks
  - There can be simple XSS attacks that do not need to be crafted
  - Phonegap and similar can be very dangerous
    - Ionic is highly optimised Phonegap
    - Most dangerous is the frameworks that essentially use webview iframes
      - These can break through traditional web app sandboxing
      - This is dangerous as Javascript binds to native functions and breaks through mobile sandboxes

XSS - As a feature
  - Some companies are starting to treat XSS as a feature
  - This is a very bad idea
    - A compnay called XFinity has been injecting its script on Reddit

XSS Questions you should ask yourself
  - How confident are you in the XSS protection of your OSS libraries
    - One thing that should be looked for particularly in a view library is that
      - There is a procedure for resolving security issues eg email address that supports specific issues
      - GitHub issues are not appropriate in this case
      - Be careful about using browsers older than supported
  - How carefully do people scrutinize browser plugins
    - Few people read the full permissions of plugins
    - Be skeptical of plugins asking for permissions going beyond what is needed
    - Instructor suggests using incognito tab for online banking
  - If XSS happens what is the exposure
  - In your app waht could a successful XSS attack escalate to 
    - This will differ form one organisation to another
    - This will also determine bug fixes etc at compromise will take precedence
There are 3 XSS vulnerabilities in the sample app
  - 2 of these are Reflected-XSS
  - Use multiple browsers to simulate multiple users
  - Students should try use at least one legacy browser when testing
  - Hosting can be done locally using *.lvh.me
    - This is essentially a DNS trick that resolves to localhost
    - It allows for having multiple domains, which is good for experimenting
The sample app
  - Will have to be cloned from a GitHub repo
  - Use yarn to install the packages
  - When registering in the app do not use a password that is used elsewhere
  - The challenge is to find the other 2 XSS vulnerabilities

    
                    Section - 2                 
The solutions to the XSS challenges
  - When creating an account HTML tags can be added
    - In the example this is a <b> tag which makes things bold
    - This should be eliminated without being run as it means other code will be run
  - The next vulnerability is both a stored and reflected vulnerability
    - This happens after an account with a script is ran
    - The account is registered without warnings and a success message is shown
    - Inspecting the element shows the script tags inside the panel
  - The third vulnerabiity is found on the profile page
    - In the url the user is listed which should not happen
    - Adding a script tag is ran which would not happen in modern browsers
    - There is a console.log added in the script tags to stop pattern matching which would stop the script being ran
    
XSS Defenses - You should never put untrusted data in the following places
  - Directly in a script -- EG <script> <%- userData %> </script>
  - In a HTML comment -- EG <!--- <%- userData %> --->
  - In an attribute name -- EG <iframe <%- userData %>="myValue" />
  - In a tag name -- EG <<%- userData %> class="myElement">
  - Directly in a style block -- EG <style> <%- userData %> </style>
    - This is very difficult to do in modern browsers
  - On a general basis never trust raw user data
  - Escape user data before putting it into HTML, there are 2 things which you should do
    - Sanitize user data prior to persisting
    - Then sanitize it prior to being rendered to a screen
    - You should typically do both of these
    - Its easier to sanitize before rendering than worrying about disallowing all bad things without interfering with
      genuine user input
Example Syntax
  <script>alert('hi')</script>
  // This is gotten by using encodeURIComponent() function
  "%3Cscript%3Ealert('hi')%3C%2Fscript%3E"
  - Most view libraries do this automatically
  - EJS is used for the class and its the following
    <%= "Escaped Expression" %>
    <%- "Unescaped Expression" %>
    <% "Non-Rendered Expression" %>

XSS Defenses - If you unescape then sanitize data first
  - These are some cheats for different libraries so you will know when you are in a danger zone
    - Ember & Vue -- {{{ "unescaped" }}}
      - This string will be treated as Html 
    - React -- return <div dangerouslySetInnerHTML={createMarkup()}/>;
    - Ejs -- <%- "Unescaped" %>
      - The course example app has a couple of examples of this issue which will need to be fixed
      - In this case the minus sign needs to be changed to an equals
    - Angular -- <div [innerHTML]="unescaped"></div>
    - Jade -- ! This is #{"<b>unescaped</b>"}!

Escape before putting user data in attributes
  - <div class="<%= 'UserValue' %>"></div>
  - Be especially careful of this when templating Javascript
    - <script>alert("Hello <%- userValue %>")</script>
  - Recommended to use https://github.com/ESAPI/node-esapi
    - This will check your app for issues, it is highly recommended by the instructor
  - User input should be treated as values not code

XSS Defenses Content Security Policy
  - Browsers cannot tell the difference between scripts downloaded from you origin vs another
    - This is called a single execution context
  - CSP allows modern browsers to be told which sources they should trust and for what type of resources
  - This information comes from a HTTP response header or meta tag
      - Content-Security_Policy: script-src 'self' https://example.example
                                 ---------         -----------------------
                                   name             sources
                                |--------------- directive ----------------|
                                
    - Multiple directives are allowed and are separated by semi-colon
    - Redefining a driective with the same name has no effect
    - By default directives are permissive
      - Content-Security-Policy: script-src: 'self' https://example.example;
                                 font-src: https://fonts.googleapis.com
  - There are some useful CSP directivess
    - child-src -- Child execution contexts eg frames, workers
    - connect-src -- What you can connect to such as fetch, WebSocket, EventSource
    - form-action -- Where you can <form> submit to
    - img-src, media-src, object-src -- Where you can get images, media etc from
    - style-src -- Where external stylesheets can come from
    - upgrade-insecure-requests - Upgrades HTTP requests to HTTPS
    - default-src -- A fallback for when a specific directive is not provided
  - There are also some keywords which can be used alongside sources which are typically origins
    - none -- No sources allowed
    - self -- Current origin
    - unsafe-inline -- Allows inline JS and CSS
    - unsafe-eval -- Allows eval()
      - This is used by templating frameworks where a string is sent and evaluated juust in time
      - This improves the performance of webpages
 There are a few ways the unsafe-inline can be made a little safer
  - Script tags embedded in HTML is the most common form of XSS and banning it mitigates risk considerably
  - There are times however where JavaScript is needed and there are solutions
  - Cryptographic nonces must be generated per page load and must change unpredictably
Example Syntax
  // Cryptographic nonce example
  <script nonce=A9h3pdfn3f03nce8DnMIOErd7Gb>
    alert('This example is done inlne');
  </script>
  
  Content-Security-Policy: script-src 'nonce-A9h3pdfn3f03nce8DnMIOErd7Gb'
  
  Another way to do this is to add a checksum to the security policy 
    - Content-Security-Policy: script-src 'sha256-absd182.....='
    - The easiest way to define this is to use the browser itself
    - Use the error generated and move that into the CSP

The exercise in this section is to
  - Fix 3 XSS issues
  - Add a reasonable CSP to the example project
    - There is a library available to help with this
      - https://github.com/helmetjs/csp



Section - 3       
Implementing XSS defences
  - Custom linting rules can be used to scan and eliminate unsafe-inline
  - This also is useful with a Git pre-commit hook
  - Eliminating using automation is a good idea and it should be done as early as possible
The example uses the VS Code IDE search facility which will search for a pattern
  - In this case it is the <%- pattern to be eliminated
  - Some may need to be kept otherwise use <%=
    - Most of these would be layout related eg <%- body -%>
  - There are other XSS vulnerabilities which allow users to see and manipulate other users data
Adding a reasonable CSP to the app
  - The HelmetJS GitHub page has a sample policy which can be used as a template and modified if needed
  - It will then need to be required in order to be used eg cont csp = require('helmet-csp'); 
  - In Express app.use is a stack of middlewares normally
  - CSP should be placed near headers in order to make for better readability
  - reportOnly is normally set to false but for testing purposes is set to true 
    - This means that things will not be blocked but you will be alerted to issues 
  - In the sample directives there is a reportUri directive
    - reportUri: '/report-violation'
    - You can specify an endpoint where errors can be sent from browsers that detect violations
    - This can be used for what is called by some a dynamic-kill-switch
    - This allows for session\user termination for CSP violation and is a good place to hook in security software
    - There are downsides though as information about user status could be available
      - Information from outside domains can bleed through and inferences about user permissions can be drawn
  - The sandbox directive will deal with I-Frames
    - sandbox: ['allow-forms', 'allow-scripts']
    - Basically only I-Frames with the sandbox attribute will be allowed
    - This will limit the functionality of I-Frames
  - The values must be in the valid CSP format between quotes
  - Eliminating inline styles will eliminate an XSS vector completely
    - This is CSS best practice 
  - This will not completely protect you due to malicious attachments
    - Documents can have embedded code and are not inert
    - PDF files have had trojans added to them which will cause problems
  - Images can also have malware embedded
    - Changing image extensions can cause problems, the example uses jpg changed to html
    - The html in images can have links embedded
  - Allowing users to share attachments can help spread malware



Section - 4                   
This is an explation of the exercise that students will perform
Attack - XSS Attachment
  - This is broken down into a scenario based exercise
    - Image uploads are allowed in the scenario
    - These are hosted in the same domain as the app
    - There is a need to ensure that uploads are in fact images
    - Users have the ability to rename files
    - Check what happens when you visit the url of a particular renamed image
  - Students are allowed to see how far some of this goes
  - The tool that is used in the example is exif.js
    - Read the Exif comment field and pipe it into the clipboard, the command is as follows
      - node ./scripts/exif.js read ./examples/squirrel.jpg | pbcopy
    - Replace the Exif comment field with the content of a HTML file, the command is as follows
      - node ./scripts/exif.js write ./examples/squirrel.jpg scratch.html
      - One note is that it must all go on to one line, this is because you cannot have a multiline HTML file name
  - Browser will treat a document and image request completely differently


                
Section - 5   
Continuing the demo/exercise from the previous section
  - Using pbcopy will add something to the clipboard
  - The exif.js library is filetype sensitive
There are defenses available to combat XSS Attahment attacks
  - Restrict the file types that can be uploaded and also the ability to access these types
    - This reduces how much of an XSS vector an app is
    - Do not blindly trust filetypes
  - When using images, compression usually eliminates non-visible data and is best practice so use this
  - Do research before allowing file types eg PDF's can execute Javascript which a lot of people do not realise
    - Some browsers will allow this straight away    
CSRF - Cross Site Request Forgery
  - This type of attack takes advantage of the fact that cookies for basic authentication are passed along with requests
  - This is one reason to align with REST conventions (GET, POST, DELETE etc)
  
  
                    
Section - 6                   
                    
                    
Section - 7                   
                    
                    Section - 8                   
                    
                    Section - 9                   
                    
                    Section - 10                   
